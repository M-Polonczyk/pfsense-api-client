# coding: utf-8

"""
    pfSense REST API Documentation

    ### Getting Started<br>- [Authentication and Authorization](https://pfrest.org/AUTHENTICATION_AND_AUTHORIZATION/)<br>- [Working with Object IDs](https://pfrest.org/WORKING_WITH_OBJECT_IDS/)<br>- [Queries, Filters, and Sorting](https://pfrest.org/QUERIES_FILTERS_AND_SORTING/)<br>- [Common Control Parameters](https://pfrest.org/COMMON_CONTROL_PARAMETERS/)<br>- [Working with HATEOAS](https://pfrest.org/WORKING_WITH_HATEOAS/)<br>

    The version of the OpenAPI document: v2.4.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, Dict, List, Optional
from typing_extensions import Annotated
from pfsense_api_client.models.get_firewall_advanced_settings_endpoint200_response import GetFirewallAdvancedSettingsEndpoint200Response
from pfsense_api_client.models.get_firewall_alias_endpoint200_response import GetFirewallAliasEndpoint200Response
from pfsense_api_client.models.get_firewall_aliases_endpoint200_response import GetFirewallAliasesEndpoint200Response
from pfsense_api_client.models.get_firewall_apply_endpoint200_response import GetFirewallApplyEndpoint200Response
from pfsense_api_client.models.get_firewall_nat_one_to_one_mapping_endpoint200_response import GetFirewallNATOneToOneMappingEndpoint200Response
from pfsense_api_client.models.get_firewall_nat_one_to_one_mappings_endpoint200_response import GetFirewallNATOneToOneMappingsEndpoint200Response
from pfsense_api_client.models.get_firewall_nat_outbound_mapping_endpoint200_response import GetFirewallNATOutboundMappingEndpoint200Response
from pfsense_api_client.models.get_firewall_nat_outbound_mappings_endpoint200_response import GetFirewallNATOutboundMappingsEndpoint200Response
from pfsense_api_client.models.get_firewall_nat_outbound_mode_endpoint200_response import GetFirewallNATOutboundModeEndpoint200Response
from pfsense_api_client.models.get_firewall_nat_port_forward_endpoint200_response import GetFirewallNATPortForwardEndpoint200Response
from pfsense_api_client.models.get_firewall_nat_port_forwards_endpoint200_response import GetFirewallNATPortForwardsEndpoint200Response
from pfsense_api_client.models.get_firewall_rule_endpoint200_response import GetFirewallRuleEndpoint200Response
from pfsense_api_client.models.get_firewall_rules_endpoint200_response import GetFirewallRulesEndpoint200Response
from pfsense_api_client.models.get_firewall_schedule_endpoint200_response import GetFirewallScheduleEndpoint200Response
from pfsense_api_client.models.get_firewall_schedule_time_range_endpoint200_response import GetFirewallScheduleTimeRangeEndpoint200Response
from pfsense_api_client.models.get_firewall_schedules_endpoint200_response import GetFirewallSchedulesEndpoint200Response
from pfsense_api_client.models.get_firewall_state_endpoint200_response import GetFirewallStateEndpoint200Response
from pfsense_api_client.models.get_firewall_states_endpoint200_response import GetFirewallStatesEndpoint200Response
from pfsense_api_client.models.get_firewall_states_size_endpoint200_response import GetFirewallStatesSizeEndpoint200Response
from pfsense_api_client.models.get_firewall_traffic_shaper_endpoint200_response import GetFirewallTrafficShaperEndpoint200Response
from pfsense_api_client.models.get_firewall_traffic_shaper_limiter_bandwidth_endpoint200_response import GetFirewallTrafficShaperLimiterBandwidthEndpoint200Response
from pfsense_api_client.models.get_firewall_traffic_shaper_limiter_endpoint200_response import GetFirewallTrafficShaperLimiterEndpoint200Response
from pfsense_api_client.models.get_firewall_traffic_shaper_limiter_queue_endpoint200_response import GetFirewallTrafficShaperLimiterQueueEndpoint200Response
from pfsense_api_client.models.get_firewall_traffic_shaper_limiters_endpoint200_response import GetFirewallTrafficShaperLimitersEndpoint200Response
from pfsense_api_client.models.get_firewall_traffic_shaper_queue_endpoint200_response import GetFirewallTrafficShaperQueueEndpoint200Response
from pfsense_api_client.models.get_firewall_traffic_shapers_endpoint200_response import GetFirewallTrafficShapersEndpoint200Response
from pfsense_api_client.models.get_firewall_virtual_ip_apply_endpoint200_response import GetFirewallVirtualIPApplyEndpoint200Response
from pfsense_api_client.models.get_firewall_virtual_ip_endpoint200_response import GetFirewallVirtualIPEndpoint200Response
from pfsense_api_client.models.get_firewall_virtual_ips_endpoint200_response import GetFirewallVirtualIPsEndpoint200Response
from pfsense_api_client.models.patch_firewall_advanced_settings_endpoint_request import PatchFirewallAdvancedSettingsEndpointRequest
from pfsense_api_client.models.patch_firewall_alias_endpoint_request import PatchFirewallAliasEndpointRequest
from pfsense_api_client.models.patch_firewall_nat_one_to_one_mapping_endpoint_request import PatchFirewallNATOneToOneMappingEndpointRequest
from pfsense_api_client.models.patch_firewall_nat_outbound_mapping_endpoint_request import PatchFirewallNATOutboundMappingEndpointRequest
from pfsense_api_client.models.patch_firewall_nat_outbound_mode_endpoint_request import PatchFirewallNATOutboundModeEndpointRequest
from pfsense_api_client.models.patch_firewall_nat_port_forward_endpoint_request import PatchFirewallNATPortForwardEndpointRequest
from pfsense_api_client.models.patch_firewall_rule_endpoint_request import PatchFirewallRuleEndpointRequest
from pfsense_api_client.models.patch_firewall_schedule_endpoint_request import PatchFirewallScheduleEndpointRequest
from pfsense_api_client.models.patch_firewall_schedule_time_range_endpoint_request import PatchFirewallScheduleTimeRangeEndpointRequest
from pfsense_api_client.models.patch_firewall_states_size_endpoint_request import PatchFirewallStatesSizeEndpointRequest
from pfsense_api_client.models.patch_firewall_traffic_shaper_endpoint_request import PatchFirewallTrafficShaperEndpointRequest
from pfsense_api_client.models.patch_firewall_traffic_shaper_limiter_bandwidth_endpoint_request import PatchFirewallTrafficShaperLimiterBandwidthEndpointRequest
from pfsense_api_client.models.patch_firewall_traffic_shaper_limiter_endpoint_request import PatchFirewallTrafficShaperLimiterEndpointRequest
from pfsense_api_client.models.patch_firewall_traffic_shaper_limiter_queue_endpoint_request import PatchFirewallTrafficShaperLimiterQueueEndpointRequest
from pfsense_api_client.models.patch_firewall_traffic_shaper_queue_endpoint_request import PatchFirewallTrafficShaperQueueEndpointRequest
from pfsense_api_client.models.patch_firewall_virtual_ip_endpoint_request import PatchFirewallVirtualIPEndpointRequest
from pfsense_api_client.models.post_firewall_alias_endpoint_request import PostFirewallAliasEndpointRequest
from pfsense_api_client.models.post_firewall_apply_endpoint_request import PostFirewallApplyEndpointRequest
from pfsense_api_client.models.post_firewall_nat_one_to_one_mapping_endpoint_request import PostFirewallNATOneToOneMappingEndpointRequest
from pfsense_api_client.models.post_firewall_nat_outbound_mapping_endpoint_request import PostFirewallNATOutboundMappingEndpointRequest
from pfsense_api_client.models.post_firewall_nat_port_forward_endpoint_request import PostFirewallNATPortForwardEndpointRequest
from pfsense_api_client.models.post_firewall_rule_endpoint_request import PostFirewallRuleEndpointRequest
from pfsense_api_client.models.post_firewall_schedule_endpoint_request import PostFirewallScheduleEndpointRequest
from pfsense_api_client.models.post_firewall_schedule_time_range_endpoint_request import PostFirewallScheduleTimeRangeEndpointRequest
from pfsense_api_client.models.post_firewall_traffic_shaper_endpoint_request import PostFirewallTrafficShaperEndpointRequest
from pfsense_api_client.models.post_firewall_traffic_shaper_limiter_bandwidth_endpoint_request import PostFirewallTrafficShaperLimiterBandwidthEndpointRequest
from pfsense_api_client.models.post_firewall_traffic_shaper_limiter_endpoint_request import PostFirewallTrafficShaperLimiterEndpointRequest
from pfsense_api_client.models.post_firewall_traffic_shaper_limiter_queue_endpoint_request import PostFirewallTrafficShaperLimiterQueueEndpointRequest
from pfsense_api_client.models.post_firewall_traffic_shaper_queue_endpoint_request import PostFirewallTrafficShaperQueueEndpointRequest
from pfsense_api_client.models.post_firewall_virtual_ip_apply_endpoint_request import PostFirewallVirtualIPApplyEndpointRequest
from pfsense_api_client.models.post_firewall_virtual_ip_endpoint_request import PostFirewallVirtualIPEndpointRequest

from pfsense_api_client.api_client import ApiClient, RequestSerialized
from pfsense_api_client.api_response import ApiResponse
from pfsense_api_client.rest import RESTResponseType


class FIREWALLApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def delete_firewall_alias_endpoint(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        apply: Annotated[Optional[StrictBool], Field(description="Apply this deletion immediately.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallAliasEndpoint200Response:
        """delete_firewall_alias_endpoint

        <h3>Description:</h3>Deletes an existing Firewall Alias.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallAlias<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-alias-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param apply: Apply this deletion immediately.
        :type apply: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_alias_endpoint_serialize(
            id=id,
            apply=apply,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallAliasEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_firewall_alias_endpoint_with_http_info(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        apply: Annotated[Optional[StrictBool], Field(description="Apply this deletion immediately.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallAliasEndpoint200Response]:
        """delete_firewall_alias_endpoint

        <h3>Description:</h3>Deletes an existing Firewall Alias.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallAlias<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-alias-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param apply: Apply this deletion immediately.
        :type apply: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_alias_endpoint_serialize(
            id=id,
            apply=apply,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallAliasEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_firewall_alias_endpoint_without_preload_content(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        apply: Annotated[Optional[StrictBool], Field(description="Apply this deletion immediately.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_firewall_alias_endpoint

        <h3>Description:</h3>Deletes an existing Firewall Alias.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallAlias<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-alias-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param apply: Apply this deletion immediately.
        :type apply: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_alias_endpoint_serialize(
            id=id,
            apply=apply,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallAliasEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_firewall_alias_endpoint_serialize(
        self,
        id,
        apply,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if apply is not None:
            
            _query_params.append(('apply', apply))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/firewall/alias',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_firewall_aliases_endpoint(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to delete at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallAliasesEndpoint200Response:
        """delete_firewall_aliases_endpoint

        <h3>Description:</h3>Deletes multiple existing Firewall Aliases using a query.<br><br>WARNING: This will delete all objects that match the query, use with caution.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallAlias<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-aliases-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The maximum number of objects to delete at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_aliases_endpoint_serialize(
            limit=limit,
            offset=offset,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallAliasesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_firewall_aliases_endpoint_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to delete at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallAliasesEndpoint200Response]:
        """delete_firewall_aliases_endpoint

        <h3>Description:</h3>Deletes multiple existing Firewall Aliases using a query.<br><br>WARNING: This will delete all objects that match the query, use with caution.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallAlias<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-aliases-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The maximum number of objects to delete at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_aliases_endpoint_serialize(
            limit=limit,
            offset=offset,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallAliasesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_firewall_aliases_endpoint_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to delete at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_firewall_aliases_endpoint

        <h3>Description:</h3>Deletes multiple existing Firewall Aliases using a query.<br><br>WARNING: This will delete all objects that match the query, use with caution.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallAlias<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-aliases-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The maximum number of objects to delete at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_aliases_endpoint_serialize(
            limit=limit,
            offset=offset,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallAliasesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_firewall_aliases_endpoint_serialize(
        self,
        limit,
        offset,
        query,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/firewall/aliases',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_firewall_nat_one_to_one_mapping_endpoint(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        apply: Annotated[Optional[StrictBool], Field(description="Apply this deletion immediately.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallNATOneToOneMappingEndpoint200Response:
        """delete_firewall_nat_one_to_one_mapping_endpoint

        <h3>Description:</h3>Deletes an existing 1:1 NAT mapping.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OneToOneNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-one-to-one-mapping-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param apply: Apply this deletion immediately.
        :type apply: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_nat_one_to_one_mapping_endpoint_serialize(
            id=id,
            apply=apply,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOneToOneMappingEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_firewall_nat_one_to_one_mapping_endpoint_with_http_info(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        apply: Annotated[Optional[StrictBool], Field(description="Apply this deletion immediately.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallNATOneToOneMappingEndpoint200Response]:
        """delete_firewall_nat_one_to_one_mapping_endpoint

        <h3>Description:</h3>Deletes an existing 1:1 NAT mapping.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OneToOneNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-one-to-one-mapping-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param apply: Apply this deletion immediately.
        :type apply: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_nat_one_to_one_mapping_endpoint_serialize(
            id=id,
            apply=apply,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOneToOneMappingEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_firewall_nat_one_to_one_mapping_endpoint_without_preload_content(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        apply: Annotated[Optional[StrictBool], Field(description="Apply this deletion immediately.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_firewall_nat_one_to_one_mapping_endpoint

        <h3>Description:</h3>Deletes an existing 1:1 NAT mapping.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OneToOneNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-one-to-one-mapping-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param apply: Apply this deletion immediately.
        :type apply: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_nat_one_to_one_mapping_endpoint_serialize(
            id=id,
            apply=apply,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOneToOneMappingEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_firewall_nat_one_to_one_mapping_endpoint_serialize(
        self,
        id,
        apply,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if apply is not None:
            
            _query_params.append(('apply', apply))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/firewall/nat/one_to_one/mapping',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_firewall_nat_one_to_one_mappings_endpoint(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to delete at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallNATOneToOneMappingsEndpoint200Response:
        """delete_firewall_nat_one_to_one_mappings_endpoint

        <h3>Description:</h3>Deletes multiple existing 1:1 NAT mappings using a query.<br><br>WARNING: This will delete all objects that match the query, use with caution.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: OneToOneNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-one-to-one-mappings-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The maximum number of objects to delete at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_nat_one_to_one_mappings_endpoint_serialize(
            limit=limit,
            offset=offset,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOneToOneMappingsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_firewall_nat_one_to_one_mappings_endpoint_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to delete at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallNATOneToOneMappingsEndpoint200Response]:
        """delete_firewall_nat_one_to_one_mappings_endpoint

        <h3>Description:</h3>Deletes multiple existing 1:1 NAT mappings using a query.<br><br>WARNING: This will delete all objects that match the query, use with caution.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: OneToOneNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-one-to-one-mappings-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The maximum number of objects to delete at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_nat_one_to_one_mappings_endpoint_serialize(
            limit=limit,
            offset=offset,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOneToOneMappingsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_firewall_nat_one_to_one_mappings_endpoint_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to delete at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_firewall_nat_one_to_one_mappings_endpoint

        <h3>Description:</h3>Deletes multiple existing 1:1 NAT mappings using a query.<br><br>WARNING: This will delete all objects that match the query, use with caution.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: OneToOneNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-one-to-one-mappings-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The maximum number of objects to delete at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_nat_one_to_one_mappings_endpoint_serialize(
            limit=limit,
            offset=offset,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOneToOneMappingsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_firewall_nat_one_to_one_mappings_endpoint_serialize(
        self,
        limit,
        offset,
        query,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/firewall/nat/one_to_one/mappings',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_firewall_nat_outbound_mapping_endpoint(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        apply: Annotated[Optional[StrictBool], Field(description="Apply this deletion immediately.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallNATOutboundMappingEndpoint200Response:
        """delete_firewall_nat_outbound_mapping_endpoint

        <h3>Description:</h3>Deletes an existing Outbound NAT Mapping.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OutboundNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-outbound-mapping-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param apply: Apply this deletion immediately.
        :type apply: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_nat_outbound_mapping_endpoint_serialize(
            id=id,
            apply=apply,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOutboundMappingEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_firewall_nat_outbound_mapping_endpoint_with_http_info(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        apply: Annotated[Optional[StrictBool], Field(description="Apply this deletion immediately.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallNATOutboundMappingEndpoint200Response]:
        """delete_firewall_nat_outbound_mapping_endpoint

        <h3>Description:</h3>Deletes an existing Outbound NAT Mapping.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OutboundNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-outbound-mapping-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param apply: Apply this deletion immediately.
        :type apply: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_nat_outbound_mapping_endpoint_serialize(
            id=id,
            apply=apply,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOutboundMappingEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_firewall_nat_outbound_mapping_endpoint_without_preload_content(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        apply: Annotated[Optional[StrictBool], Field(description="Apply this deletion immediately.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_firewall_nat_outbound_mapping_endpoint

        <h3>Description:</h3>Deletes an existing Outbound NAT Mapping.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OutboundNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-outbound-mapping-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param apply: Apply this deletion immediately.
        :type apply: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_nat_outbound_mapping_endpoint_serialize(
            id=id,
            apply=apply,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOutboundMappingEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_firewall_nat_outbound_mapping_endpoint_serialize(
        self,
        id,
        apply,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if apply is not None:
            
            _query_params.append(('apply', apply))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/firewall/nat/outbound/mapping',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_firewall_nat_outbound_mappings_endpoint(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to delete at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallNATOutboundMappingsEndpoint200Response:
        """delete_firewall_nat_outbound_mappings_endpoint

        <h3>Description:</h3>Deletes multiple existing Outbound NAT Mappings using a query.<br><br>WARNING: This will delete all objects that match the query, use with caution.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: OutboundNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-outbound-mappings-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The maximum number of objects to delete at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_nat_outbound_mappings_endpoint_serialize(
            limit=limit,
            offset=offset,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOutboundMappingsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_firewall_nat_outbound_mappings_endpoint_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to delete at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallNATOutboundMappingsEndpoint200Response]:
        """delete_firewall_nat_outbound_mappings_endpoint

        <h3>Description:</h3>Deletes multiple existing Outbound NAT Mappings using a query.<br><br>WARNING: This will delete all objects that match the query, use with caution.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: OutboundNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-outbound-mappings-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The maximum number of objects to delete at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_nat_outbound_mappings_endpoint_serialize(
            limit=limit,
            offset=offset,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOutboundMappingsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_firewall_nat_outbound_mappings_endpoint_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to delete at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_firewall_nat_outbound_mappings_endpoint

        <h3>Description:</h3>Deletes multiple existing Outbound NAT Mappings using a query.<br><br>WARNING: This will delete all objects that match the query, use with caution.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: OutboundNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-outbound-mappings-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The maximum number of objects to delete at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_nat_outbound_mappings_endpoint_serialize(
            limit=limit,
            offset=offset,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOutboundMappingsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_firewall_nat_outbound_mappings_endpoint_serialize(
        self,
        limit,
        offset,
        query,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/firewall/nat/outbound/mappings',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_firewall_nat_port_forward_endpoint(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        apply: Annotated[Optional[StrictBool], Field(description="Apply this deletion immediately.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallNATPortForwardEndpoint200Response:
        """delete_firewall_nat_port_forward_endpoint

        <h3>Description:</h3>Deletes an existing Port Forward.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: PortForward<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-port-forward-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param apply: Apply this deletion immediately.
        :type apply: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_nat_port_forward_endpoint_serialize(
            id=id,
            apply=apply,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATPortForwardEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_firewall_nat_port_forward_endpoint_with_http_info(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        apply: Annotated[Optional[StrictBool], Field(description="Apply this deletion immediately.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallNATPortForwardEndpoint200Response]:
        """delete_firewall_nat_port_forward_endpoint

        <h3>Description:</h3>Deletes an existing Port Forward.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: PortForward<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-port-forward-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param apply: Apply this deletion immediately.
        :type apply: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_nat_port_forward_endpoint_serialize(
            id=id,
            apply=apply,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATPortForwardEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_firewall_nat_port_forward_endpoint_without_preload_content(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        apply: Annotated[Optional[StrictBool], Field(description="Apply this deletion immediately.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_firewall_nat_port_forward_endpoint

        <h3>Description:</h3>Deletes an existing Port Forward.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: PortForward<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-port-forward-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param apply: Apply this deletion immediately.
        :type apply: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_nat_port_forward_endpoint_serialize(
            id=id,
            apply=apply,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATPortForwardEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_firewall_nat_port_forward_endpoint_serialize(
        self,
        id,
        apply,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if apply is not None:
            
            _query_params.append(('apply', apply))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/firewall/nat/port_forward',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_firewall_nat_port_forwards_endpoint(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to delete at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallNATPortForwardsEndpoint200Response:
        """delete_firewall_nat_port_forwards_endpoint

        <h3>Description:</h3>Deletes multiple existing Port Forwards using a query.<br><br>WARNING: This will delete all objects that match the query, use with caution.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: PortForward<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-port-forwards-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The maximum number of objects to delete at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_nat_port_forwards_endpoint_serialize(
            limit=limit,
            offset=offset,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATPortForwardsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_firewall_nat_port_forwards_endpoint_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to delete at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallNATPortForwardsEndpoint200Response]:
        """delete_firewall_nat_port_forwards_endpoint

        <h3>Description:</h3>Deletes multiple existing Port Forwards using a query.<br><br>WARNING: This will delete all objects that match the query, use with caution.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: PortForward<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-port-forwards-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The maximum number of objects to delete at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_nat_port_forwards_endpoint_serialize(
            limit=limit,
            offset=offset,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATPortForwardsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_firewall_nat_port_forwards_endpoint_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to delete at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_firewall_nat_port_forwards_endpoint

        <h3>Description:</h3>Deletes multiple existing Port Forwards using a query.<br><br>WARNING: This will delete all objects that match the query, use with caution.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: PortForward<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-port-forwards-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The maximum number of objects to delete at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_nat_port_forwards_endpoint_serialize(
            limit=limit,
            offset=offset,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATPortForwardsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_firewall_nat_port_forwards_endpoint_serialize(
        self,
        limit,
        offset,
        query,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/firewall/nat/port_forwards',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_firewall_rule_endpoint(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallRuleEndpoint200Response:
        """delete_firewall_rule_endpoint

        <h3>Description:</h3>Deletes an existing Firewall Rule.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallRule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-rule-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_rule_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallRuleEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_firewall_rule_endpoint_with_http_info(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallRuleEndpoint200Response]:
        """delete_firewall_rule_endpoint

        <h3>Description:</h3>Deletes an existing Firewall Rule.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallRule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-rule-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_rule_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallRuleEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_firewall_rule_endpoint_without_preload_content(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_firewall_rule_endpoint

        <h3>Description:</h3>Deletes an existing Firewall Rule.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallRule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-rule-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_rule_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallRuleEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_firewall_rule_endpoint_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/firewall/rule',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_firewall_rules_endpoint(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to delete at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallRulesEndpoint200Response:
        """delete_firewall_rules_endpoint

        <h3>Description:</h3>Deletes multiple existing Firewall Rules using a query.<br><br>WARNING: This will delete all objects that match the query, use with caution.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallRule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-rules-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The maximum number of objects to delete at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_rules_endpoint_serialize(
            limit=limit,
            offset=offset,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallRulesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_firewall_rules_endpoint_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to delete at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallRulesEndpoint200Response]:
        """delete_firewall_rules_endpoint

        <h3>Description:</h3>Deletes multiple existing Firewall Rules using a query.<br><br>WARNING: This will delete all objects that match the query, use with caution.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallRule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-rules-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The maximum number of objects to delete at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_rules_endpoint_serialize(
            limit=limit,
            offset=offset,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallRulesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_firewall_rules_endpoint_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to delete at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_firewall_rules_endpoint

        <h3>Description:</h3>Deletes multiple existing Firewall Rules using a query.<br><br>WARNING: This will delete all objects that match the query, use with caution.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallRule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-rules-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The maximum number of objects to delete at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_rules_endpoint_serialize(
            limit=limit,
            offset=offset,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallRulesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_firewall_rules_endpoint_serialize(
        self,
        limit,
        offset,
        query,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/firewall/rules',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_firewall_schedule_endpoint(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallScheduleEndpoint200Response:
        """delete_firewall_schedule_endpoint

        <h3>Description:</h3>Deletes an existing Firewall Schedule.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallSchedule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedule-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_schedule_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallScheduleEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_firewall_schedule_endpoint_with_http_info(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallScheduleEndpoint200Response]:
        """delete_firewall_schedule_endpoint

        <h3>Description:</h3>Deletes an existing Firewall Schedule.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallSchedule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedule-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_schedule_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallScheduleEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_firewall_schedule_endpoint_without_preload_content(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_firewall_schedule_endpoint

        <h3>Description:</h3>Deletes an existing Firewall Schedule.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallSchedule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedule-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_schedule_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallScheduleEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_firewall_schedule_endpoint_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/firewall/schedule',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_firewall_schedule_time_range_endpoint(
        self,
        parent_id: Annotated[Any, Field(description="The ID of the parent this object is nested under.")],
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallScheduleTimeRangeEndpoint200Response:
        """delete_firewall_schedule_time_range_endpoint

        <h3>Description:</h3>Deletes an existing Firewall Schedule Time Range.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallScheduleTimeRange<br>**Parent model**: FirewallSchedule<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedule-time-range-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param parent_id: The ID of the parent this object is nested under. (required)
        :type parent_id: DeleteAuthKeyEndpointIdParameter
        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_schedule_time_range_endpoint_serialize(
            parent_id=parent_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallScheduleTimeRangeEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_firewall_schedule_time_range_endpoint_with_http_info(
        self,
        parent_id: Annotated[Any, Field(description="The ID of the parent this object is nested under.")],
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallScheduleTimeRangeEndpoint200Response]:
        """delete_firewall_schedule_time_range_endpoint

        <h3>Description:</h3>Deletes an existing Firewall Schedule Time Range.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallScheduleTimeRange<br>**Parent model**: FirewallSchedule<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedule-time-range-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param parent_id: The ID of the parent this object is nested under. (required)
        :type parent_id: DeleteAuthKeyEndpointIdParameter
        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_schedule_time_range_endpoint_serialize(
            parent_id=parent_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallScheduleTimeRangeEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_firewall_schedule_time_range_endpoint_without_preload_content(
        self,
        parent_id: Annotated[Any, Field(description="The ID of the parent this object is nested under.")],
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_firewall_schedule_time_range_endpoint

        <h3>Description:</h3>Deletes an existing Firewall Schedule Time Range.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallScheduleTimeRange<br>**Parent model**: FirewallSchedule<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedule-time-range-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param parent_id: The ID of the parent this object is nested under. (required)
        :type parent_id: DeleteAuthKeyEndpointIdParameter
        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_schedule_time_range_endpoint_serialize(
            parent_id=parent_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallScheduleTimeRangeEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_firewall_schedule_time_range_endpoint_serialize(
        self,
        parent_id,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if parent_id is not None:
            
            _query_params.append(('parent_id', parent_id))
            
        if id is not None:
            
            _query_params.append(('id', id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/firewall/schedule/time_range',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_firewall_schedules_endpoint(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to delete at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallSchedulesEndpoint200Response:
        """delete_firewall_schedules_endpoint

        <h3>Description:</h3>Deletes multiple existing Firewall Schedules using a query.<br><br>WARNING: This will delete all objects that match the query, use with caution.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallSchedule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedules-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param limit: The maximum number of objects to delete at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_schedules_endpoint_serialize(
            limit=limit,
            offset=offset,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallSchedulesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_firewall_schedules_endpoint_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to delete at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallSchedulesEndpoint200Response]:
        """delete_firewall_schedules_endpoint

        <h3>Description:</h3>Deletes multiple existing Firewall Schedules using a query.<br><br>WARNING: This will delete all objects that match the query, use with caution.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallSchedule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedules-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param limit: The maximum number of objects to delete at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_schedules_endpoint_serialize(
            limit=limit,
            offset=offset,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallSchedulesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_firewall_schedules_endpoint_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to delete at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_firewall_schedules_endpoint

        <h3>Description:</h3>Deletes multiple existing Firewall Schedules using a query.<br><br>WARNING: This will delete all objects that match the query, use with caution.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallSchedule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedules-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param limit: The maximum number of objects to delete at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_schedules_endpoint_serialize(
            limit=limit,
            offset=offset,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallSchedulesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_firewall_schedules_endpoint_serialize(
        self,
        limit,
        offset,
        query,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/firewall/schedules',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_firewall_state_endpoint(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallStateEndpoint200Response:
        """(Deprecated) delete_firewall_state_endpoint

        <h3>Description:</h3>Please use the /api/v2/firewall/states endpoint with a query to kill the state you are looking for.<br><br>Kills an existing Firewall State. Please note that the firewall state table changes very quickly which may result in the state's `id` suddenly changing. Use caution when deleting states.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallState<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-state-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Not Applicable<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("DELETE /api/v2/firewall/state is deprecated.", DeprecationWarning)

        _param = self._delete_firewall_state_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallStateEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_firewall_state_endpoint_with_http_info(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallStateEndpoint200Response]:
        """(Deprecated) delete_firewall_state_endpoint

        <h3>Description:</h3>Please use the /api/v2/firewall/states endpoint with a query to kill the state you are looking for.<br><br>Kills an existing Firewall State. Please note that the firewall state table changes very quickly which may result in the state's `id` suddenly changing. Use caution when deleting states.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallState<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-state-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Not Applicable<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("DELETE /api/v2/firewall/state is deprecated.", DeprecationWarning)

        _param = self._delete_firewall_state_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallStateEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_firewall_state_endpoint_without_preload_content(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) delete_firewall_state_endpoint

        <h3>Description:</h3>Please use the /api/v2/firewall/states endpoint with a query to kill the state you are looking for.<br><br>Kills an existing Firewall State. Please note that the firewall state table changes very quickly which may result in the state's `id` suddenly changing. Use caution when deleting states.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallState<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-state-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Not Applicable<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("DELETE /api/v2/firewall/state is deprecated.", DeprecationWarning)

        _param = self._delete_firewall_state_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallStateEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_firewall_state_endpoint_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/firewall/state',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_firewall_states_endpoint(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to delete at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallStatesEndpoint200Response:
        """delete_firewall_states_endpoint

        <h3>Description:</h3>Deletes multiple existing Firewall States using a query.<br><br>WARNING: This will delete all objects that match the query, use with caution.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallState<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-states-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Not Applicable<br>**Utilizes cache**: None

        :param limit: The maximum number of objects to delete at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_states_endpoint_serialize(
            limit=limit,
            offset=offset,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallStatesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_firewall_states_endpoint_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to delete at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallStatesEndpoint200Response]:
        """delete_firewall_states_endpoint

        <h3>Description:</h3>Deletes multiple existing Firewall States using a query.<br><br>WARNING: This will delete all objects that match the query, use with caution.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallState<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-states-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Not Applicable<br>**Utilizes cache**: None

        :param limit: The maximum number of objects to delete at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_states_endpoint_serialize(
            limit=limit,
            offset=offset,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallStatesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_firewall_states_endpoint_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to delete at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_firewall_states_endpoint

        <h3>Description:</h3>Deletes multiple existing Firewall States using a query.<br><br>WARNING: This will delete all objects that match the query, use with caution.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallState<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-states-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Not Applicable<br>**Utilizes cache**: None

        :param limit: The maximum number of objects to delete at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_states_endpoint_serialize(
            limit=limit,
            offset=offset,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallStatesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_firewall_states_endpoint_serialize(
        self,
        limit,
        offset,
        query,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/firewall/states',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_firewall_traffic_shaper_endpoint(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        apply: Annotated[Optional[StrictBool], Field(description="Apply this deletion immediately.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallTrafficShaperEndpoint200Response:
        """delete_firewall_traffic_shaper_endpoint

        <h3>Description:</h3>Deletes an existing Traffic Shaper.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaper<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param apply: Apply this deletion immediately.
        :type apply: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_traffic_shaper_endpoint_serialize(
            id=id,
            apply=apply,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_firewall_traffic_shaper_endpoint_with_http_info(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        apply: Annotated[Optional[StrictBool], Field(description="Apply this deletion immediately.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallTrafficShaperEndpoint200Response]:
        """delete_firewall_traffic_shaper_endpoint

        <h3>Description:</h3>Deletes an existing Traffic Shaper.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaper<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param apply: Apply this deletion immediately.
        :type apply: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_traffic_shaper_endpoint_serialize(
            id=id,
            apply=apply,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_firewall_traffic_shaper_endpoint_without_preload_content(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        apply: Annotated[Optional[StrictBool], Field(description="Apply this deletion immediately.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_firewall_traffic_shaper_endpoint

        <h3>Description:</h3>Deletes an existing Traffic Shaper.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaper<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param apply: Apply this deletion immediately.
        :type apply: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_traffic_shaper_endpoint_serialize(
            id=id,
            apply=apply,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_firewall_traffic_shaper_endpoint_serialize(
        self,
        id,
        apply,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if apply is not None:
            
            _query_params.append(('apply', apply))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/firewall/traffic_shaper',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_firewall_traffic_shaper_limiter_bandwidth_endpoint(
        self,
        parent_id: Annotated[Any, Field(description="The ID of the parent this object is nested under.")],
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallTrafficShaperLimiterBandwidthEndpoint200Response:
        """delete_firewall_traffic_shaper_limiter_bandwidth_endpoint

        <h3>Description:</h3>Deletes an existing Traffic Shaper Limiter Bandwidth.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiterBandwidth<br>**Parent model**: TrafficShaperLimiter<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-bandwidth-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param parent_id: The ID of the parent this object is nested under. (required)
        :type parent_id: DeleteAuthKeyEndpointIdParameter
        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_traffic_shaper_limiter_bandwidth_endpoint_serialize(
            parent_id=parent_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterBandwidthEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_firewall_traffic_shaper_limiter_bandwidth_endpoint_with_http_info(
        self,
        parent_id: Annotated[Any, Field(description="The ID of the parent this object is nested under.")],
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallTrafficShaperLimiterBandwidthEndpoint200Response]:
        """delete_firewall_traffic_shaper_limiter_bandwidth_endpoint

        <h3>Description:</h3>Deletes an existing Traffic Shaper Limiter Bandwidth.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiterBandwidth<br>**Parent model**: TrafficShaperLimiter<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-bandwidth-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param parent_id: The ID of the parent this object is nested under. (required)
        :type parent_id: DeleteAuthKeyEndpointIdParameter
        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_traffic_shaper_limiter_bandwidth_endpoint_serialize(
            parent_id=parent_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterBandwidthEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_firewall_traffic_shaper_limiter_bandwidth_endpoint_without_preload_content(
        self,
        parent_id: Annotated[Any, Field(description="The ID of the parent this object is nested under.")],
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_firewall_traffic_shaper_limiter_bandwidth_endpoint

        <h3>Description:</h3>Deletes an existing Traffic Shaper Limiter Bandwidth.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiterBandwidth<br>**Parent model**: TrafficShaperLimiter<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-bandwidth-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param parent_id: The ID of the parent this object is nested under. (required)
        :type parent_id: DeleteAuthKeyEndpointIdParameter
        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_traffic_shaper_limiter_bandwidth_endpoint_serialize(
            parent_id=parent_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterBandwidthEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_firewall_traffic_shaper_limiter_bandwidth_endpoint_serialize(
        self,
        parent_id,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if parent_id is not None:
            
            _query_params.append(('parent_id', parent_id))
            
        if id is not None:
            
            _query_params.append(('id', id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/firewall/traffic_shaper/limiter/bandwidth',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_firewall_traffic_shaper_limiter_endpoint(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        apply: Annotated[Optional[StrictBool], Field(description="Apply this deletion immediately.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallTrafficShaperLimiterEndpoint200Response:
        """delete_firewall_traffic_shaper_limiter_endpoint

        <h3>Description:</h3>Deletes an existing Traffic Shaper Limiter.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiter<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param apply: Apply this deletion immediately.
        :type apply: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_traffic_shaper_limiter_endpoint_serialize(
            id=id,
            apply=apply,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_firewall_traffic_shaper_limiter_endpoint_with_http_info(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        apply: Annotated[Optional[StrictBool], Field(description="Apply this deletion immediately.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallTrafficShaperLimiterEndpoint200Response]:
        """delete_firewall_traffic_shaper_limiter_endpoint

        <h3>Description:</h3>Deletes an existing Traffic Shaper Limiter.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiter<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param apply: Apply this deletion immediately.
        :type apply: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_traffic_shaper_limiter_endpoint_serialize(
            id=id,
            apply=apply,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_firewall_traffic_shaper_limiter_endpoint_without_preload_content(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        apply: Annotated[Optional[StrictBool], Field(description="Apply this deletion immediately.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_firewall_traffic_shaper_limiter_endpoint

        <h3>Description:</h3>Deletes an existing Traffic Shaper Limiter.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiter<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param apply: Apply this deletion immediately.
        :type apply: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_traffic_shaper_limiter_endpoint_serialize(
            id=id,
            apply=apply,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_firewall_traffic_shaper_limiter_endpoint_serialize(
        self,
        id,
        apply,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if apply is not None:
            
            _query_params.append(('apply', apply))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/firewall/traffic_shaper/limiter',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_firewall_traffic_shaper_limiter_queue_endpoint(
        self,
        parent_id: Annotated[Any, Field(description="The ID of the parent this object is nested under.")],
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        apply: Annotated[Optional[StrictBool], Field(description="Apply this deletion immediately.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallTrafficShaperLimiterQueueEndpoint200Response:
        """delete_firewall_traffic_shaper_limiter_queue_endpoint

        <h3>Description:</h3>Deletes an existing Traffic Shaper Limiter Queue.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiterQueue<br>**Parent model**: TrafficShaperLimiter<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-queue-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param parent_id: The ID of the parent this object is nested under. (required)
        :type parent_id: DeleteAuthKeyEndpointIdParameter
        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param apply: Apply this deletion immediately.
        :type apply: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_traffic_shaper_limiter_queue_endpoint_serialize(
            parent_id=parent_id,
            id=id,
            apply=apply,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterQueueEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_firewall_traffic_shaper_limiter_queue_endpoint_with_http_info(
        self,
        parent_id: Annotated[Any, Field(description="The ID of the parent this object is nested under.")],
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        apply: Annotated[Optional[StrictBool], Field(description="Apply this deletion immediately.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallTrafficShaperLimiterQueueEndpoint200Response]:
        """delete_firewall_traffic_shaper_limiter_queue_endpoint

        <h3>Description:</h3>Deletes an existing Traffic Shaper Limiter Queue.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiterQueue<br>**Parent model**: TrafficShaperLimiter<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-queue-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param parent_id: The ID of the parent this object is nested under. (required)
        :type parent_id: DeleteAuthKeyEndpointIdParameter
        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param apply: Apply this deletion immediately.
        :type apply: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_traffic_shaper_limiter_queue_endpoint_serialize(
            parent_id=parent_id,
            id=id,
            apply=apply,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterQueueEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_firewall_traffic_shaper_limiter_queue_endpoint_without_preload_content(
        self,
        parent_id: Annotated[Any, Field(description="The ID of the parent this object is nested under.")],
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        apply: Annotated[Optional[StrictBool], Field(description="Apply this deletion immediately.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_firewall_traffic_shaper_limiter_queue_endpoint

        <h3>Description:</h3>Deletes an existing Traffic Shaper Limiter Queue.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiterQueue<br>**Parent model**: TrafficShaperLimiter<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-queue-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param parent_id: The ID of the parent this object is nested under. (required)
        :type parent_id: DeleteAuthKeyEndpointIdParameter
        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param apply: Apply this deletion immediately.
        :type apply: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_traffic_shaper_limiter_queue_endpoint_serialize(
            parent_id=parent_id,
            id=id,
            apply=apply,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterQueueEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_firewall_traffic_shaper_limiter_queue_endpoint_serialize(
        self,
        parent_id,
        id,
        apply,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if parent_id is not None:
            
            _query_params.append(('parent_id', parent_id))
            
        if id is not None:
            
            _query_params.append(('id', id))
            
        if apply is not None:
            
            _query_params.append(('apply', apply))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/firewall/traffic_shaper/limiter/queue',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_firewall_traffic_shaper_queue_endpoint(
        self,
        parent_id: Annotated[Any, Field(description="The ID of the parent this object is nested under.")],
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        apply: Annotated[Optional[StrictBool], Field(description="Apply this deletion immediately.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallTrafficShaperQueueEndpoint200Response:
        """delete_firewall_traffic_shaper_queue_endpoint

        <h3>Description:</h3>Deletes an existing Traffic Shaper Queue.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperQueue<br>**Parent model**: TrafficShaper<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-queue-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param parent_id: The ID of the parent this object is nested under. (required)
        :type parent_id: DeleteAuthKeyEndpointIdParameter
        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param apply: Apply this deletion immediately.
        :type apply: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_traffic_shaper_queue_endpoint_serialize(
            parent_id=parent_id,
            id=id,
            apply=apply,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperQueueEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_firewall_traffic_shaper_queue_endpoint_with_http_info(
        self,
        parent_id: Annotated[Any, Field(description="The ID of the parent this object is nested under.")],
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        apply: Annotated[Optional[StrictBool], Field(description="Apply this deletion immediately.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallTrafficShaperQueueEndpoint200Response]:
        """delete_firewall_traffic_shaper_queue_endpoint

        <h3>Description:</h3>Deletes an existing Traffic Shaper Queue.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperQueue<br>**Parent model**: TrafficShaper<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-queue-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param parent_id: The ID of the parent this object is nested under. (required)
        :type parent_id: DeleteAuthKeyEndpointIdParameter
        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param apply: Apply this deletion immediately.
        :type apply: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_traffic_shaper_queue_endpoint_serialize(
            parent_id=parent_id,
            id=id,
            apply=apply,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperQueueEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_firewall_traffic_shaper_queue_endpoint_without_preload_content(
        self,
        parent_id: Annotated[Any, Field(description="The ID of the parent this object is nested under.")],
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        apply: Annotated[Optional[StrictBool], Field(description="Apply this deletion immediately.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_firewall_traffic_shaper_queue_endpoint

        <h3>Description:</h3>Deletes an existing Traffic Shaper Queue.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperQueue<br>**Parent model**: TrafficShaper<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-queue-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param parent_id: The ID of the parent this object is nested under. (required)
        :type parent_id: DeleteAuthKeyEndpointIdParameter
        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param apply: Apply this deletion immediately.
        :type apply: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_traffic_shaper_queue_endpoint_serialize(
            parent_id=parent_id,
            id=id,
            apply=apply,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperQueueEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_firewall_traffic_shaper_queue_endpoint_serialize(
        self,
        parent_id,
        id,
        apply,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if parent_id is not None:
            
            _query_params.append(('parent_id', parent_id))
            
        if id is not None:
            
            _query_params.append(('id', id))
            
        if apply is not None:
            
            _query_params.append(('apply', apply))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/firewall/traffic_shaper/queue',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_firewall_traffic_shapers_endpoint(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to delete at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallTrafficShapersEndpoint200Response:
        """delete_firewall_traffic_shapers_endpoint

        <h3>Description:</h3>Deletes multiple existing Traffic Shapers using a query.<br><br>WARNING: This will delete all objects that match the query, use with caution.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: TrafficShaper<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shapers-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The maximum number of objects to delete at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_traffic_shapers_endpoint_serialize(
            limit=limit,
            offset=offset,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShapersEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_firewall_traffic_shapers_endpoint_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to delete at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallTrafficShapersEndpoint200Response]:
        """delete_firewall_traffic_shapers_endpoint

        <h3>Description:</h3>Deletes multiple existing Traffic Shapers using a query.<br><br>WARNING: This will delete all objects that match the query, use with caution.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: TrafficShaper<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shapers-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The maximum number of objects to delete at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_traffic_shapers_endpoint_serialize(
            limit=limit,
            offset=offset,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShapersEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_firewall_traffic_shapers_endpoint_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to delete at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_firewall_traffic_shapers_endpoint

        <h3>Description:</h3>Deletes multiple existing Traffic Shapers using a query.<br><br>WARNING: This will delete all objects that match the query, use with caution.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: TrafficShaper<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shapers-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The maximum number of objects to delete at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_traffic_shapers_endpoint_serialize(
            limit=limit,
            offset=offset,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShapersEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_firewall_traffic_shapers_endpoint_serialize(
        self,
        limit,
        offset,
        query,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/firewall/traffic_shapers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_firewall_virtual_ip_endpoint(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        apply: Annotated[Optional[StrictBool], Field(description="Apply this deletion immediately.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallVirtualIPEndpoint200Response:
        """delete_firewall_virtual_ip_endpoint

        <h3>Description:</h3>Deletes an existing Virtual IP.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: VirtualIP<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-virtual-ip-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param apply: Apply this deletion immediately.
        :type apply: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_virtual_ip_endpoint_serialize(
            id=id,
            apply=apply,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallVirtualIPEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_firewall_virtual_ip_endpoint_with_http_info(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        apply: Annotated[Optional[StrictBool], Field(description="Apply this deletion immediately.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallVirtualIPEndpoint200Response]:
        """delete_firewall_virtual_ip_endpoint

        <h3>Description:</h3>Deletes an existing Virtual IP.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: VirtualIP<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-virtual-ip-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param apply: Apply this deletion immediately.
        :type apply: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_virtual_ip_endpoint_serialize(
            id=id,
            apply=apply,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallVirtualIPEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_firewall_virtual_ip_endpoint_without_preload_content(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        apply: Annotated[Optional[StrictBool], Field(description="Apply this deletion immediately.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_firewall_virtual_ip_endpoint

        <h3>Description:</h3>Deletes an existing Virtual IP.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: VirtualIP<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-virtual-ip-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param apply: Apply this deletion immediately.
        :type apply: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_virtual_ip_endpoint_serialize(
            id=id,
            apply=apply,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallVirtualIPEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_firewall_virtual_ip_endpoint_serialize(
        self,
        id,
        apply,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        if apply is not None:
            
            _query_params.append(('apply', apply))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/firewall/virtual_ip',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_firewall_virtual_ips_endpoint(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to delete at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallVirtualIPsEndpoint200Response:
        """delete_firewall_virtual_ips_endpoint

        <h3>Description:</h3>Deletes multiple existing Virtual IPs using a query.<br><br>WARNING: This will delete all objects that match the query, use with caution.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: VirtualIP<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-virtual-ips-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The maximum number of objects to delete at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_virtual_ips_endpoint_serialize(
            limit=limit,
            offset=offset,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallVirtualIPsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_firewall_virtual_ips_endpoint_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to delete at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallVirtualIPsEndpoint200Response]:
        """delete_firewall_virtual_ips_endpoint

        <h3>Description:</h3>Deletes multiple existing Virtual IPs using a query.<br><br>WARNING: This will delete all objects that match the query, use with caution.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: VirtualIP<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-virtual-ips-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The maximum number of objects to delete at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_virtual_ips_endpoint_serialize(
            limit=limit,
            offset=offset,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallVirtualIPsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_firewall_virtual_ips_endpoint_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The maximum number of objects to delete at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete_firewall_virtual_ips_endpoint

        <h3>Description:</h3>Deletes multiple existing Virtual IPs using a query.<br><br>WARNING: This will delete all objects that match the query, use with caution.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: VirtualIP<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-virtual-ips-delete ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The maximum number of objects to delete at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_firewall_virtual_ips_endpoint_serialize(
            limit=limit,
            offset=offset,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallVirtualIPsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_firewall_virtual_ips_endpoint_serialize(
        self,
        limit,
        offset,
        query,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/v2/firewall/virtual_ips',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_firewall_advanced_settings_endpoint(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallAdvancedSettingsEndpoint200Response:
        """get_firewall_advanced_settings_endpoint

        <h3>Description:</h3>Reads current Firewall Advanced Settings.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallAdvancedSettings<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-advanced-settings-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_advanced_settings_endpoint_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallAdvancedSettingsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_firewall_advanced_settings_endpoint_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallAdvancedSettingsEndpoint200Response]:
        """get_firewall_advanced_settings_endpoint

        <h3>Description:</h3>Reads current Firewall Advanced Settings.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallAdvancedSettings<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-advanced-settings-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_advanced_settings_endpoint_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallAdvancedSettingsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_firewall_advanced_settings_endpoint_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_firewall_advanced_settings_endpoint

        <h3>Description:</h3>Reads current Firewall Advanced Settings.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallAdvancedSettings<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-advanced-settings-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_advanced_settings_endpoint_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallAdvancedSettingsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_firewall_advanced_settings_endpoint_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/firewall/advanced_settings',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_firewall_alias_endpoint(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallAliasEndpoint200Response:
        """get_firewall_alias_endpoint

        <h3>Description:</h3>Reads an existing Firewall Alias.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallAlias<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-alias-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_alias_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallAliasEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_firewall_alias_endpoint_with_http_info(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallAliasEndpoint200Response]:
        """get_firewall_alias_endpoint

        <h3>Description:</h3>Reads an existing Firewall Alias.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallAlias<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-alias-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_alias_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallAliasEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_firewall_alias_endpoint_without_preload_content(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_firewall_alias_endpoint

        <h3>Description:</h3>Reads an existing Firewall Alias.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallAlias<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-alias-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_alias_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallAliasEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_firewall_alias_endpoint_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/firewall/alias',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_firewall_aliases_endpoint(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallAliasesEndpoint200Response:
        """get_firewall_aliases_endpoint

        <h3>Description:</h3>Reads all existing Firewall Aliases.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallAlias<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-aliases-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_aliases_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallAliasesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_firewall_aliases_endpoint_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallAliasesEndpoint200Response]:
        """get_firewall_aliases_endpoint

        <h3>Description:</h3>Reads all existing Firewall Aliases.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallAlias<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-aliases-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_aliases_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallAliasesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_firewall_aliases_endpoint_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_firewall_aliases_endpoint

        <h3>Description:</h3>Reads all existing Firewall Aliases.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallAlias<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-aliases-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_aliases_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallAliasesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_firewall_aliases_endpoint_serialize(
        self,
        limit,
        offset,
        sort_by,
        sort_order,
        sort_flags,
        query,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort_by': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort_by is not None:
            
            _query_params.append(('sort_by', sort_by))
            
        if sort_order is not None:
            
            _query_params.append(('sort_order', sort_order))
            
        if sort_flags is not None:
            
            _query_params.append(('sort_flags', sort_flags))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/firewall/aliases',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_firewall_apply_endpoint(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallApplyEndpoint200Response:
        """get_firewall_apply_endpoint

        <h3>Description:</h3>Read pending firewall change status.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallApply<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-apply-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Not Applicable<br>**Utilizes cache**: None

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_apply_endpoint_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallApplyEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_firewall_apply_endpoint_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallApplyEndpoint200Response]:
        """get_firewall_apply_endpoint

        <h3>Description:</h3>Read pending firewall change status.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallApply<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-apply-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Not Applicable<br>**Utilizes cache**: None

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_apply_endpoint_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallApplyEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_firewall_apply_endpoint_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_firewall_apply_endpoint

        <h3>Description:</h3>Read pending firewall change status.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallApply<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-apply-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Not Applicable<br>**Utilizes cache**: None

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_apply_endpoint_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallApplyEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_firewall_apply_endpoint_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/firewall/apply',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_firewall_nat_one_to_one_mapping_endpoint(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallNATOneToOneMappingEndpoint200Response:
        """get_firewall_nat_one_to_one_mapping_endpoint

        <h3>Description:</h3>Reads an existing 1:1 NAT mapping.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OneToOneNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-one-to-one-mapping-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_nat_one_to_one_mapping_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOneToOneMappingEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_firewall_nat_one_to_one_mapping_endpoint_with_http_info(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallNATOneToOneMappingEndpoint200Response]:
        """get_firewall_nat_one_to_one_mapping_endpoint

        <h3>Description:</h3>Reads an existing 1:1 NAT mapping.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OneToOneNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-one-to-one-mapping-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_nat_one_to_one_mapping_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOneToOneMappingEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_firewall_nat_one_to_one_mapping_endpoint_without_preload_content(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_firewall_nat_one_to_one_mapping_endpoint

        <h3>Description:</h3>Reads an existing 1:1 NAT mapping.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OneToOneNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-one-to-one-mapping-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_nat_one_to_one_mapping_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOneToOneMappingEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_firewall_nat_one_to_one_mapping_endpoint_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/firewall/nat/one_to_one/mapping',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_firewall_nat_one_to_one_mappings_endpoint(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallNATOneToOneMappingsEndpoint200Response:
        """get_firewall_nat_one_to_one_mappings_endpoint

        <h3>Description:</h3>Reads all existing 1:1 NAT mappings.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: OneToOneNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-one-to-one-mappings-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_nat_one_to_one_mappings_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOneToOneMappingsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_firewall_nat_one_to_one_mappings_endpoint_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallNATOneToOneMappingsEndpoint200Response]:
        """get_firewall_nat_one_to_one_mappings_endpoint

        <h3>Description:</h3>Reads all existing 1:1 NAT mappings.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: OneToOneNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-one-to-one-mappings-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_nat_one_to_one_mappings_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOneToOneMappingsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_firewall_nat_one_to_one_mappings_endpoint_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_firewall_nat_one_to_one_mappings_endpoint

        <h3>Description:</h3>Reads all existing 1:1 NAT mappings.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: OneToOneNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-one-to-one-mappings-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_nat_one_to_one_mappings_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOneToOneMappingsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_firewall_nat_one_to_one_mappings_endpoint_serialize(
        self,
        limit,
        offset,
        sort_by,
        sort_order,
        sort_flags,
        query,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort_by': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort_by is not None:
            
            _query_params.append(('sort_by', sort_by))
            
        if sort_order is not None:
            
            _query_params.append(('sort_order', sort_order))
            
        if sort_flags is not None:
            
            _query_params.append(('sort_flags', sort_flags))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/firewall/nat/one_to_one/mappings',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_firewall_nat_outbound_mapping_endpoint(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallNATOutboundMappingEndpoint200Response:
        """get_firewall_nat_outbound_mapping_endpoint

        <h3>Description:</h3>Reads an existing Outbound NAT Mapping.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OutboundNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-outbound-mapping-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_nat_outbound_mapping_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOutboundMappingEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_firewall_nat_outbound_mapping_endpoint_with_http_info(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallNATOutboundMappingEndpoint200Response]:
        """get_firewall_nat_outbound_mapping_endpoint

        <h3>Description:</h3>Reads an existing Outbound NAT Mapping.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OutboundNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-outbound-mapping-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_nat_outbound_mapping_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOutboundMappingEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_firewall_nat_outbound_mapping_endpoint_without_preload_content(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_firewall_nat_outbound_mapping_endpoint

        <h3>Description:</h3>Reads an existing Outbound NAT Mapping.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OutboundNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-outbound-mapping-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_nat_outbound_mapping_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOutboundMappingEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_firewall_nat_outbound_mapping_endpoint_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/firewall/nat/outbound/mapping',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_firewall_nat_outbound_mappings_endpoint(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallNATOutboundMappingsEndpoint200Response:
        """get_firewall_nat_outbound_mappings_endpoint

        <h3>Description:</h3>Reads all existing Outbound NAT Mappings.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: OutboundNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-outbound-mappings-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_nat_outbound_mappings_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOutboundMappingsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_firewall_nat_outbound_mappings_endpoint_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallNATOutboundMappingsEndpoint200Response]:
        """get_firewall_nat_outbound_mappings_endpoint

        <h3>Description:</h3>Reads all existing Outbound NAT Mappings.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: OutboundNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-outbound-mappings-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_nat_outbound_mappings_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOutboundMappingsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_firewall_nat_outbound_mappings_endpoint_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_firewall_nat_outbound_mappings_endpoint

        <h3>Description:</h3>Reads all existing Outbound NAT Mappings.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: OutboundNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-outbound-mappings-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_nat_outbound_mappings_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOutboundMappingsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_firewall_nat_outbound_mappings_endpoint_serialize(
        self,
        limit,
        offset,
        sort_by,
        sort_order,
        sort_flags,
        query,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort_by': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort_by is not None:
            
            _query_params.append(('sort_by', sort_by))
            
        if sort_order is not None:
            
            _query_params.append(('sort_order', sort_order))
            
        if sort_flags is not None:
            
            _query_params.append(('sort_flags', sort_flags))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/firewall/nat/outbound/mappings',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_firewall_nat_outbound_mode_endpoint(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallNATOutboundModeEndpoint200Response:
        """get_firewall_nat_outbound_mode_endpoint

        <h3>Description:</h3>Reads current Outbound NAT Mode.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OutboundNATMode<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-outbound-mode-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_nat_outbound_mode_endpoint_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOutboundModeEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_firewall_nat_outbound_mode_endpoint_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallNATOutboundModeEndpoint200Response]:
        """get_firewall_nat_outbound_mode_endpoint

        <h3>Description:</h3>Reads current Outbound NAT Mode.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OutboundNATMode<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-outbound-mode-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_nat_outbound_mode_endpoint_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOutboundModeEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_firewall_nat_outbound_mode_endpoint_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_firewall_nat_outbound_mode_endpoint

        <h3>Description:</h3>Reads current Outbound NAT Mode.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OutboundNATMode<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-outbound-mode-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_nat_outbound_mode_endpoint_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOutboundModeEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_firewall_nat_outbound_mode_endpoint_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/firewall/nat/outbound/mode',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_firewall_nat_port_forward_endpoint(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallNATPortForwardEndpoint200Response:
        """get_firewall_nat_port_forward_endpoint

        <h3>Description:</h3>Reads an existing Port Forward.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: PortForward<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-port-forward-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_nat_port_forward_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATPortForwardEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_firewall_nat_port_forward_endpoint_with_http_info(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallNATPortForwardEndpoint200Response]:
        """get_firewall_nat_port_forward_endpoint

        <h3>Description:</h3>Reads an existing Port Forward.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: PortForward<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-port-forward-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_nat_port_forward_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATPortForwardEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_firewall_nat_port_forward_endpoint_without_preload_content(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_firewall_nat_port_forward_endpoint

        <h3>Description:</h3>Reads an existing Port Forward.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: PortForward<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-port-forward-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_nat_port_forward_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATPortForwardEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_firewall_nat_port_forward_endpoint_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/firewall/nat/port_forward',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_firewall_nat_port_forwards_endpoint(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallNATPortForwardsEndpoint200Response:
        """get_firewall_nat_port_forwards_endpoint

        <h3>Description:</h3>Reads all existing Port Forwards.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: PortForward<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-port-forwards-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_nat_port_forwards_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATPortForwardsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_firewall_nat_port_forwards_endpoint_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallNATPortForwardsEndpoint200Response]:
        """get_firewall_nat_port_forwards_endpoint

        <h3>Description:</h3>Reads all existing Port Forwards.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: PortForward<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-port-forwards-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_nat_port_forwards_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATPortForwardsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_firewall_nat_port_forwards_endpoint_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_firewall_nat_port_forwards_endpoint

        <h3>Description:</h3>Reads all existing Port Forwards.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: PortForward<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-port-forwards-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_nat_port_forwards_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATPortForwardsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_firewall_nat_port_forwards_endpoint_serialize(
        self,
        limit,
        offset,
        sort_by,
        sort_order,
        sort_flags,
        query,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort_by': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort_by is not None:
            
            _query_params.append(('sort_by', sort_by))
            
        if sort_order is not None:
            
            _query_params.append(('sort_order', sort_order))
            
        if sort_flags is not None:
            
            _query_params.append(('sort_flags', sort_flags))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/firewall/nat/port_forwards',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_firewall_rule_endpoint(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallRuleEndpoint200Response:
        """get_firewall_rule_endpoint

        <h3>Description:</h3>Reads an existing Firewall Rule.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallRule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-rule-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_rule_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallRuleEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_firewall_rule_endpoint_with_http_info(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallRuleEndpoint200Response]:
        """get_firewall_rule_endpoint

        <h3>Description:</h3>Reads an existing Firewall Rule.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallRule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-rule-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_rule_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallRuleEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_firewall_rule_endpoint_without_preload_content(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_firewall_rule_endpoint

        <h3>Description:</h3>Reads an existing Firewall Rule.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallRule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-rule-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_rule_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallRuleEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_firewall_rule_endpoint_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/firewall/rule',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_firewall_rules_endpoint(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallRulesEndpoint200Response:
        """get_firewall_rules_endpoint

        <h3>Description:</h3>Reads all existing Firewall Rules.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallRule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-rules-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_rules_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallRulesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_firewall_rules_endpoint_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallRulesEndpoint200Response]:
        """get_firewall_rules_endpoint

        <h3>Description:</h3>Reads all existing Firewall Rules.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallRule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-rules-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_rules_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallRulesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_firewall_rules_endpoint_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_firewall_rules_endpoint

        <h3>Description:</h3>Reads all existing Firewall Rules.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallRule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-rules-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_rules_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallRulesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_firewall_rules_endpoint_serialize(
        self,
        limit,
        offset,
        sort_by,
        sort_order,
        sort_flags,
        query,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort_by': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort_by is not None:
            
            _query_params.append(('sort_by', sort_by))
            
        if sort_order is not None:
            
            _query_params.append(('sort_order', sort_order))
            
        if sort_flags is not None:
            
            _query_params.append(('sort_flags', sort_flags))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/firewall/rules',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_firewall_schedule_endpoint(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallScheduleEndpoint200Response:
        """get_firewall_schedule_endpoint

        <h3>Description:</h3>Reads an existing Firewall Schedule.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallSchedule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedule-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_schedule_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallScheduleEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_firewall_schedule_endpoint_with_http_info(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallScheduleEndpoint200Response]:
        """get_firewall_schedule_endpoint

        <h3>Description:</h3>Reads an existing Firewall Schedule.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallSchedule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedule-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_schedule_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallScheduleEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_firewall_schedule_endpoint_without_preload_content(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_firewall_schedule_endpoint

        <h3>Description:</h3>Reads an existing Firewall Schedule.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallSchedule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedule-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_schedule_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallScheduleEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_firewall_schedule_endpoint_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/firewall/schedule',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_firewall_schedule_time_range_endpoint(
        self,
        parent_id: Annotated[Any, Field(description="The ID of the parent this object is nested under.")],
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallScheduleTimeRangeEndpoint200Response:
        """get_firewall_schedule_time_range_endpoint

        <h3>Description:</h3>Reads an existing Firewall Schedule Time Range.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallScheduleTimeRange<br>**Parent model**: FirewallSchedule<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedule-time-range-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param parent_id: The ID of the parent this object is nested under. (required)
        :type parent_id: DeleteAuthKeyEndpointIdParameter
        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_schedule_time_range_endpoint_serialize(
            parent_id=parent_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallScheduleTimeRangeEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_firewall_schedule_time_range_endpoint_with_http_info(
        self,
        parent_id: Annotated[Any, Field(description="The ID of the parent this object is nested under.")],
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallScheduleTimeRangeEndpoint200Response]:
        """get_firewall_schedule_time_range_endpoint

        <h3>Description:</h3>Reads an existing Firewall Schedule Time Range.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallScheduleTimeRange<br>**Parent model**: FirewallSchedule<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedule-time-range-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param parent_id: The ID of the parent this object is nested under. (required)
        :type parent_id: DeleteAuthKeyEndpointIdParameter
        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_schedule_time_range_endpoint_serialize(
            parent_id=parent_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallScheduleTimeRangeEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_firewall_schedule_time_range_endpoint_without_preload_content(
        self,
        parent_id: Annotated[Any, Field(description="The ID of the parent this object is nested under.")],
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_firewall_schedule_time_range_endpoint

        <h3>Description:</h3>Reads an existing Firewall Schedule Time Range.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallScheduleTimeRange<br>**Parent model**: FirewallSchedule<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedule-time-range-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param parent_id: The ID of the parent this object is nested under. (required)
        :type parent_id: DeleteAuthKeyEndpointIdParameter
        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_schedule_time_range_endpoint_serialize(
            parent_id=parent_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallScheduleTimeRangeEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_firewall_schedule_time_range_endpoint_serialize(
        self,
        parent_id,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if parent_id is not None:
            
            _query_params.append(('parent_id', parent_id))
            
        if id is not None:
            
            _query_params.append(('id', id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/firewall/schedule/time_range',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_firewall_schedules_endpoint(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallSchedulesEndpoint200Response:
        """get_firewall_schedules_endpoint

        <h3>Description:</h3>Reads all existing Firewall Schedules.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallSchedule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedules-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_schedules_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallSchedulesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_firewall_schedules_endpoint_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallSchedulesEndpoint200Response]:
        """get_firewall_schedules_endpoint

        <h3>Description:</h3>Reads all existing Firewall Schedules.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallSchedule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedules-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_schedules_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallSchedulesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_firewall_schedules_endpoint_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_firewall_schedules_endpoint

        <h3>Description:</h3>Reads all existing Firewall Schedules.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallSchedule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedules-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_schedules_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallSchedulesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_firewall_schedules_endpoint_serialize(
        self,
        limit,
        offset,
        sort_by,
        sort_order,
        sort_flags,
        query,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort_by': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort_by is not None:
            
            _query_params.append(('sort_by', sort_by))
            
        if sort_order is not None:
            
            _query_params.append(('sort_order', sort_order))
            
        if sort_flags is not None:
            
            _query_params.append(('sort_flags', sort_flags))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/firewall/schedules',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_firewall_state_endpoint(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallStateEndpoint200Response:
        """(Deprecated) get_firewall_state_endpoint

        <h3>Description:</h3>Please use the /api/v2/firewall/states endpoint with a query to find the state you are looking for.<br><br>Reads an existing Firewall State. Please note that the firewall state table changes very quickly which may result in the state's `id` suddenly changing. It is recommended to use the /api/v2/firewall/states endpoint with a query to find the state you are looking for.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallState<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-state-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Not Applicable<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v2/firewall/state is deprecated.", DeprecationWarning)

        _param = self._get_firewall_state_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallStateEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_firewall_state_endpoint_with_http_info(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallStateEndpoint200Response]:
        """(Deprecated) get_firewall_state_endpoint

        <h3>Description:</h3>Please use the /api/v2/firewall/states endpoint with a query to find the state you are looking for.<br><br>Reads an existing Firewall State. Please note that the firewall state table changes very quickly which may result in the state's `id` suddenly changing. It is recommended to use the /api/v2/firewall/states endpoint with a query to find the state you are looking for.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallState<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-state-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Not Applicable<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v2/firewall/state is deprecated.", DeprecationWarning)

        _param = self._get_firewall_state_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallStateEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_firewall_state_endpoint_without_preload_content(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) get_firewall_state_endpoint

        <h3>Description:</h3>Please use the /api/v2/firewall/states endpoint with a query to find the state you are looking for.<br><br>Reads an existing Firewall State. Please note that the firewall state table changes very quickly which may result in the state's `id` suddenly changing. It is recommended to use the /api/v2/firewall/states endpoint with a query to find the state you are looking for.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallState<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-state-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Not Applicable<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v2/firewall/state is deprecated.", DeprecationWarning)

        _param = self._get_firewall_state_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallStateEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_firewall_state_endpoint_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/firewall/state',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_firewall_states_endpoint(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallStatesEndpoint200Response:
        """get_firewall_states_endpoint

        <h3>Description:</h3>Reads all current Firewall States. A normal firewall may have thousands, millions, or even billions of firewall states registered at a time. This can quickly become too much for this endpoint to handle. It is strongly recommended to limit the number of objects obtained by the API using the `limit` parameter or using a query to only target specific states you are looking for.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallState<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-states-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Not Applicable<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_states_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallStatesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_firewall_states_endpoint_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallStatesEndpoint200Response]:
        """get_firewall_states_endpoint

        <h3>Description:</h3>Reads all current Firewall States. A normal firewall may have thousands, millions, or even billions of firewall states registered at a time. This can quickly become too much for this endpoint to handle. It is strongly recommended to limit the number of objects obtained by the API using the `limit` parameter or using a query to only target specific states you are looking for.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallState<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-states-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Not Applicable<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_states_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallStatesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_firewall_states_endpoint_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_firewall_states_endpoint

        <h3>Description:</h3>Reads all current Firewall States. A normal firewall may have thousands, millions, or even billions of firewall states registered at a time. This can quickly become too much for this endpoint to handle. It is strongly recommended to limit the number of objects obtained by the API using the `limit` parameter or using a query to only target specific states you are looking for.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallState<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-states-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Not Applicable<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_states_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallStatesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_firewall_states_endpoint_serialize(
        self,
        limit,
        offset,
        sort_by,
        sort_order,
        sort_flags,
        query,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort_by': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort_by is not None:
            
            _query_params.append(('sort_by', sort_by))
            
        if sort_order is not None:
            
            _query_params.append(('sort_order', sort_order))
            
        if sort_flags is not None:
            
            _query_params.append(('sort_flags', sort_flags))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/firewall/states',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_firewall_states_size_endpoint(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallStatesSizeEndpoint200Response:
        """get_firewall_states_size_endpoint

        <h3>Description:</h3>Reads current Firewall States Size.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallStatesSize<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-states-size-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_states_size_endpoint_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallStatesSizeEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_firewall_states_size_endpoint_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallStatesSizeEndpoint200Response]:
        """get_firewall_states_size_endpoint

        <h3>Description:</h3>Reads current Firewall States Size.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallStatesSize<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-states-size-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_states_size_endpoint_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallStatesSizeEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_firewall_states_size_endpoint_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_firewall_states_size_endpoint

        <h3>Description:</h3>Reads current Firewall States Size.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallStatesSize<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-states-size-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_states_size_endpoint_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallStatesSizeEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_firewall_states_size_endpoint_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/firewall/states/size',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_firewall_traffic_shaper_endpoint(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallTrafficShaperEndpoint200Response:
        """get_firewall_traffic_shaper_endpoint

        <h3>Description:</h3>Reads an existing Traffic Shaper.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaper<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_traffic_shaper_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_firewall_traffic_shaper_endpoint_with_http_info(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallTrafficShaperEndpoint200Response]:
        """get_firewall_traffic_shaper_endpoint

        <h3>Description:</h3>Reads an existing Traffic Shaper.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaper<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_traffic_shaper_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_firewall_traffic_shaper_endpoint_without_preload_content(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_firewall_traffic_shaper_endpoint

        <h3>Description:</h3>Reads an existing Traffic Shaper.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaper<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_traffic_shaper_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_firewall_traffic_shaper_endpoint_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/firewall/traffic_shaper',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_firewall_traffic_shaper_limiter_bandwidth_endpoint(
        self,
        parent_id: Annotated[Any, Field(description="The ID of the parent this object is nested under.")],
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallTrafficShaperLimiterBandwidthEndpoint200Response:
        """get_firewall_traffic_shaper_limiter_bandwidth_endpoint

        <h3>Description:</h3>Reads an existing Traffic Shaper Limiter Bandwidth.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiterBandwidth<br>**Parent model**: TrafficShaperLimiter<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-bandwidth-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param parent_id: The ID of the parent this object is nested under. (required)
        :type parent_id: DeleteAuthKeyEndpointIdParameter
        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_traffic_shaper_limiter_bandwidth_endpoint_serialize(
            parent_id=parent_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterBandwidthEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_firewall_traffic_shaper_limiter_bandwidth_endpoint_with_http_info(
        self,
        parent_id: Annotated[Any, Field(description="The ID of the parent this object is nested under.")],
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallTrafficShaperLimiterBandwidthEndpoint200Response]:
        """get_firewall_traffic_shaper_limiter_bandwidth_endpoint

        <h3>Description:</h3>Reads an existing Traffic Shaper Limiter Bandwidth.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiterBandwidth<br>**Parent model**: TrafficShaperLimiter<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-bandwidth-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param parent_id: The ID of the parent this object is nested under. (required)
        :type parent_id: DeleteAuthKeyEndpointIdParameter
        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_traffic_shaper_limiter_bandwidth_endpoint_serialize(
            parent_id=parent_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterBandwidthEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_firewall_traffic_shaper_limiter_bandwidth_endpoint_without_preload_content(
        self,
        parent_id: Annotated[Any, Field(description="The ID of the parent this object is nested under.")],
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_firewall_traffic_shaper_limiter_bandwidth_endpoint

        <h3>Description:</h3>Reads an existing Traffic Shaper Limiter Bandwidth.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiterBandwidth<br>**Parent model**: TrafficShaperLimiter<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-bandwidth-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param parent_id: The ID of the parent this object is nested under. (required)
        :type parent_id: DeleteAuthKeyEndpointIdParameter
        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_traffic_shaper_limiter_bandwidth_endpoint_serialize(
            parent_id=parent_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterBandwidthEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_firewall_traffic_shaper_limiter_bandwidth_endpoint_serialize(
        self,
        parent_id,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if parent_id is not None:
            
            _query_params.append(('parent_id', parent_id))
            
        if id is not None:
            
            _query_params.append(('id', id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/firewall/traffic_shaper/limiter/bandwidth',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_firewall_traffic_shaper_limiter_endpoint(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallTrafficShaperLimiterEndpoint200Response:
        """get_firewall_traffic_shaper_limiter_endpoint

        <h3>Description:</h3>Reads an existing Traffic Shaper Limiter.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiter<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_traffic_shaper_limiter_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_firewall_traffic_shaper_limiter_endpoint_with_http_info(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallTrafficShaperLimiterEndpoint200Response]:
        """get_firewall_traffic_shaper_limiter_endpoint

        <h3>Description:</h3>Reads an existing Traffic Shaper Limiter.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiter<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_traffic_shaper_limiter_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_firewall_traffic_shaper_limiter_endpoint_without_preload_content(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_firewall_traffic_shaper_limiter_endpoint

        <h3>Description:</h3>Reads an existing Traffic Shaper Limiter.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiter<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_traffic_shaper_limiter_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_firewall_traffic_shaper_limiter_endpoint_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/firewall/traffic_shaper/limiter',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_firewall_traffic_shaper_limiter_queue_endpoint(
        self,
        parent_id: Annotated[Any, Field(description="The ID of the parent this object is nested under.")],
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallTrafficShaperLimiterQueueEndpoint200Response:
        """get_firewall_traffic_shaper_limiter_queue_endpoint

        <h3>Description:</h3>Reads an existing Traffic Shaper Limiter Queue.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiterQueue<br>**Parent model**: TrafficShaperLimiter<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-queue-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param parent_id: The ID of the parent this object is nested under. (required)
        :type parent_id: DeleteAuthKeyEndpointIdParameter
        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_traffic_shaper_limiter_queue_endpoint_serialize(
            parent_id=parent_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterQueueEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_firewall_traffic_shaper_limiter_queue_endpoint_with_http_info(
        self,
        parent_id: Annotated[Any, Field(description="The ID of the parent this object is nested under.")],
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallTrafficShaperLimiterQueueEndpoint200Response]:
        """get_firewall_traffic_shaper_limiter_queue_endpoint

        <h3>Description:</h3>Reads an existing Traffic Shaper Limiter Queue.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiterQueue<br>**Parent model**: TrafficShaperLimiter<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-queue-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param parent_id: The ID of the parent this object is nested under. (required)
        :type parent_id: DeleteAuthKeyEndpointIdParameter
        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_traffic_shaper_limiter_queue_endpoint_serialize(
            parent_id=parent_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterQueueEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_firewall_traffic_shaper_limiter_queue_endpoint_without_preload_content(
        self,
        parent_id: Annotated[Any, Field(description="The ID of the parent this object is nested under.")],
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_firewall_traffic_shaper_limiter_queue_endpoint

        <h3>Description:</h3>Reads an existing Traffic Shaper Limiter Queue.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiterQueue<br>**Parent model**: TrafficShaperLimiter<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-queue-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param parent_id: The ID of the parent this object is nested under. (required)
        :type parent_id: DeleteAuthKeyEndpointIdParameter
        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_traffic_shaper_limiter_queue_endpoint_serialize(
            parent_id=parent_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterQueueEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_firewall_traffic_shaper_limiter_queue_endpoint_serialize(
        self,
        parent_id,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if parent_id is not None:
            
            _query_params.append(('parent_id', parent_id))
            
        if id is not None:
            
            _query_params.append(('id', id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/firewall/traffic_shaper/limiter/queue',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_firewall_traffic_shaper_limiters_endpoint(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallTrafficShaperLimitersEndpoint200Response:
        """get_firewall_traffic_shaper_limiters_endpoint

        <h3>Description:</h3>Reads all existing Traffic Shaper Limiters.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: TrafficShaperLimiter<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiters-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_traffic_shaper_limiters_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimitersEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_firewall_traffic_shaper_limiters_endpoint_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallTrafficShaperLimitersEndpoint200Response]:
        """get_firewall_traffic_shaper_limiters_endpoint

        <h3>Description:</h3>Reads all existing Traffic Shaper Limiters.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: TrafficShaperLimiter<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiters-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_traffic_shaper_limiters_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimitersEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_firewall_traffic_shaper_limiters_endpoint_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_firewall_traffic_shaper_limiters_endpoint

        <h3>Description:</h3>Reads all existing Traffic Shaper Limiters.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: TrafficShaperLimiter<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiters-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_traffic_shaper_limiters_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimitersEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_firewall_traffic_shaper_limiters_endpoint_serialize(
        self,
        limit,
        offset,
        sort_by,
        sort_order,
        sort_flags,
        query,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort_by': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort_by is not None:
            
            _query_params.append(('sort_by', sort_by))
            
        if sort_order is not None:
            
            _query_params.append(('sort_order', sort_order))
            
        if sort_flags is not None:
            
            _query_params.append(('sort_flags', sort_flags))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/firewall/traffic_shaper/limiters',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_firewall_traffic_shaper_queue_endpoint(
        self,
        parent_id: Annotated[Any, Field(description="The ID of the parent this object is nested under.")],
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallTrafficShaperQueueEndpoint200Response:
        """get_firewall_traffic_shaper_queue_endpoint

        <h3>Description:</h3>Reads an existing Traffic Shaper Queue.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperQueue<br>**Parent model**: TrafficShaper<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-queue-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param parent_id: The ID of the parent this object is nested under. (required)
        :type parent_id: DeleteAuthKeyEndpointIdParameter
        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_traffic_shaper_queue_endpoint_serialize(
            parent_id=parent_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperQueueEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_firewall_traffic_shaper_queue_endpoint_with_http_info(
        self,
        parent_id: Annotated[Any, Field(description="The ID of the parent this object is nested under.")],
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallTrafficShaperQueueEndpoint200Response]:
        """get_firewall_traffic_shaper_queue_endpoint

        <h3>Description:</h3>Reads an existing Traffic Shaper Queue.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperQueue<br>**Parent model**: TrafficShaper<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-queue-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param parent_id: The ID of the parent this object is nested under. (required)
        :type parent_id: DeleteAuthKeyEndpointIdParameter
        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_traffic_shaper_queue_endpoint_serialize(
            parent_id=parent_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperQueueEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_firewall_traffic_shaper_queue_endpoint_without_preload_content(
        self,
        parent_id: Annotated[Any, Field(description="The ID of the parent this object is nested under.")],
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_firewall_traffic_shaper_queue_endpoint

        <h3>Description:</h3>Reads an existing Traffic Shaper Queue.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperQueue<br>**Parent model**: TrafficShaper<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-queue-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param parent_id: The ID of the parent this object is nested under. (required)
        :type parent_id: DeleteAuthKeyEndpointIdParameter
        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_traffic_shaper_queue_endpoint_serialize(
            parent_id=parent_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperQueueEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_firewall_traffic_shaper_queue_endpoint_serialize(
        self,
        parent_id,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if parent_id is not None:
            
            _query_params.append(('parent_id', parent_id))
            
        if id is not None:
            
            _query_params.append(('id', id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/firewall/traffic_shaper/queue',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_firewall_traffic_shapers_endpoint(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallTrafficShapersEndpoint200Response:
        """get_firewall_traffic_shapers_endpoint

        <h3>Description:</h3>Reads all existing Traffic Shapers.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: TrafficShaper<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shapers-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_traffic_shapers_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShapersEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_firewall_traffic_shapers_endpoint_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallTrafficShapersEndpoint200Response]:
        """get_firewall_traffic_shapers_endpoint

        <h3>Description:</h3>Reads all existing Traffic Shapers.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: TrafficShaper<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shapers-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_traffic_shapers_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShapersEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_firewall_traffic_shapers_endpoint_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_firewall_traffic_shapers_endpoint

        <h3>Description:</h3>Reads all existing Traffic Shapers.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: TrafficShaper<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shapers-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_traffic_shapers_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShapersEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_firewall_traffic_shapers_endpoint_serialize(
        self,
        limit,
        offset,
        sort_by,
        sort_order,
        sort_flags,
        query,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort_by': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort_by is not None:
            
            _query_params.append(('sort_by', sort_by))
            
        if sort_order is not None:
            
            _query_params.append(('sort_order', sort_order))
            
        if sort_flags is not None:
            
            _query_params.append(('sort_flags', sort_flags))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/firewall/traffic_shapers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_firewall_virtual_ip_apply_endpoint(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallVirtualIPApplyEndpoint200Response:
        """get_firewall_virtual_ip_apply_endpoint

        <h3>Description:</h3>Read pending virtual IP status.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: VirtualIPApply<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-virtual-ip-apply-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Not Applicable<br>**Utilizes cache**: None

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_virtual_ip_apply_endpoint_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallVirtualIPApplyEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_firewall_virtual_ip_apply_endpoint_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallVirtualIPApplyEndpoint200Response]:
        """get_firewall_virtual_ip_apply_endpoint

        <h3>Description:</h3>Read pending virtual IP status.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: VirtualIPApply<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-virtual-ip-apply-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Not Applicable<br>**Utilizes cache**: None

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_virtual_ip_apply_endpoint_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallVirtualIPApplyEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_firewall_virtual_ip_apply_endpoint_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_firewall_virtual_ip_apply_endpoint

        <h3>Description:</h3>Read pending virtual IP status.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: VirtualIPApply<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-virtual-ip-apply-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Not Applicable<br>**Utilizes cache**: None

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_virtual_ip_apply_endpoint_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallVirtualIPApplyEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_firewall_virtual_ip_apply_endpoint_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/firewall/virtual_ip/apply',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_firewall_virtual_ip_endpoint(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallVirtualIPEndpoint200Response:
        """get_firewall_virtual_ip_endpoint

        <h3>Description:</h3>Reads an existing Virtual IP.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: VirtualIP<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-virtual-ip-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_virtual_ip_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallVirtualIPEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_firewall_virtual_ip_endpoint_with_http_info(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallVirtualIPEndpoint200Response]:
        """get_firewall_virtual_ip_endpoint

        <h3>Description:</h3>Reads an existing Virtual IP.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: VirtualIP<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-virtual-ip-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_virtual_ip_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallVirtualIPEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_firewall_virtual_ip_endpoint_without_preload_content(
        self,
        id: Annotated[Any, Field(description="The ID of the object to target.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_firewall_virtual_ip_endpoint

        <h3>Description:</h3>Reads an existing Virtual IP.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: VirtualIP<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-virtual-ip-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param id: The ID of the object to target. (required)
        :type id: DeleteAuthKeyEndpointIdParameter
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_virtual_ip_endpoint_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallVirtualIPEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_firewall_virtual_ip_endpoint_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:
            
            _query_params.append(('id', id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/firewall/virtual_ip',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_firewall_virtual_ips_endpoint(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallVirtualIPsEndpoint200Response:
        """get_firewall_virtual_ips_endpoint

        <h3>Description:</h3>Reads all existing Virtual IPs.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: VirtualIP<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-virtual-ips-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_virtual_ips_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallVirtualIPsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_firewall_virtual_ips_endpoint_with_http_info(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallVirtualIPsEndpoint200Response]:
        """get_firewall_virtual_ips_endpoint

        <h3>Description:</h3>Reads all existing Virtual IPs.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: VirtualIP<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-virtual-ips-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_virtual_ips_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallVirtualIPsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_firewall_virtual_ips_endpoint_without_preload_content(
        self,
        limit: Annotated[Optional[StrictInt], Field(description="The number of objects to obtain at once. Set to 0 for no limit.")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="The starting point in the dataset to begin fetching objects.")] = None,
        sort_by: Annotated[Optional[List[StrictStr]], Field(description="The fields to sort response data by.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The order to sort response data by.")] = None,
        sort_flags: Annotated[Optional[StrictStr], Field(description="The sort flag to use to customize the behavior of the sort.")] = None,
        query: Annotated[Optional[Dict[str, StrictStr]], Field(description="The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """get_firewall_virtual_ips_endpoint

        <h3>Description:</h3>Reads all existing Virtual IPs.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: VirtualIP<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-virtual-ips-get ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param limit: The number of objects to obtain at once. Set to 0 for no limit.
        :type limit: int
        :param offset: The starting point in the dataset to begin fetching objects.
        :type offset: int
        :param sort_by: The fields to sort response data by.
        :type sort_by: List[str]
        :param sort_order: The order to sort response data by.
        :type sort_order: str
        :param sort_flags: The sort flag to use to customize the behavior of the sort.
        :type sort_flags: str
        :param query: The arbitrary query parameters to include in the request.<br><br>Note: This does not define a real parameter (e.g. there is no `query` parameter), rather it allows for any arbitrary query parameters to be included in the request.
        :type query: Dict[str, str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_firewall_virtual_ips_endpoint_serialize(
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order,
            sort_flags=sort_flags,
            query=query,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallVirtualIPsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_firewall_virtual_ips_endpoint_serialize(
        self,
        limit,
        offset,
        sort_by,
        sort_order,
        sort_flags,
        query,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort_by': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if sort_by is not None:
            
            _query_params.append(('sort_by', sort_by))
            
        if sort_order is not None:
            
            _query_params.append(('sort_order', sort_order))
            
        if sort_flags is not None:
            
            _query_params.append(('sort_flags', sort_flags))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2/firewall/virtual_ips',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def patch_firewall_advanced_settings_endpoint(
        self,
        patch_firewall_advanced_settings_endpoint_request: Optional[PatchFirewallAdvancedSettingsEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallAdvancedSettingsEndpoint200Response:
        """patch_firewall_advanced_settings_endpoint

        <h3>Description:</h3>Updates current Firewall Advanced Settings.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallAdvancedSettings<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-advanced-settings-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_advanced_settings_endpoint_request:
        :type patch_firewall_advanced_settings_endpoint_request: PatchFirewallAdvancedSettingsEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_advanced_settings_endpoint_serialize(
            patch_firewall_advanced_settings_endpoint_request=patch_firewall_advanced_settings_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallAdvancedSettingsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def patch_firewall_advanced_settings_endpoint_with_http_info(
        self,
        patch_firewall_advanced_settings_endpoint_request: Optional[PatchFirewallAdvancedSettingsEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallAdvancedSettingsEndpoint200Response]:
        """patch_firewall_advanced_settings_endpoint

        <h3>Description:</h3>Updates current Firewall Advanced Settings.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallAdvancedSettings<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-advanced-settings-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_advanced_settings_endpoint_request:
        :type patch_firewall_advanced_settings_endpoint_request: PatchFirewallAdvancedSettingsEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_advanced_settings_endpoint_serialize(
            patch_firewall_advanced_settings_endpoint_request=patch_firewall_advanced_settings_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallAdvancedSettingsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def patch_firewall_advanced_settings_endpoint_without_preload_content(
        self,
        patch_firewall_advanced_settings_endpoint_request: Optional[PatchFirewallAdvancedSettingsEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """patch_firewall_advanced_settings_endpoint

        <h3>Description:</h3>Updates current Firewall Advanced Settings.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallAdvancedSettings<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-advanced-settings-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_advanced_settings_endpoint_request:
        :type patch_firewall_advanced_settings_endpoint_request: PatchFirewallAdvancedSettingsEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_advanced_settings_endpoint_serialize(
            patch_firewall_advanced_settings_endpoint_request=patch_firewall_advanced_settings_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallAdvancedSettingsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _patch_firewall_advanced_settings_endpoint_serialize(
        self,
        patch_firewall_advanced_settings_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if patch_firewall_advanced_settings_endpoint_request is not None:
            _body_params = patch_firewall_advanced_settings_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/v2/firewall/advanced_settings',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def patch_firewall_alias_endpoint(
        self,
        patch_firewall_alias_endpoint_request: Optional[PatchFirewallAliasEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallAliasEndpoint200Response:
        """patch_firewall_alias_endpoint

        <h3>Description:</h3>Updates an existing Firewall Alias.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallAlias<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-alias-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_alias_endpoint_request:
        :type patch_firewall_alias_endpoint_request: PatchFirewallAliasEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_alias_endpoint_serialize(
            patch_firewall_alias_endpoint_request=patch_firewall_alias_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallAliasEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def patch_firewall_alias_endpoint_with_http_info(
        self,
        patch_firewall_alias_endpoint_request: Optional[PatchFirewallAliasEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallAliasEndpoint200Response]:
        """patch_firewall_alias_endpoint

        <h3>Description:</h3>Updates an existing Firewall Alias.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallAlias<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-alias-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_alias_endpoint_request:
        :type patch_firewall_alias_endpoint_request: PatchFirewallAliasEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_alias_endpoint_serialize(
            patch_firewall_alias_endpoint_request=patch_firewall_alias_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallAliasEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def patch_firewall_alias_endpoint_without_preload_content(
        self,
        patch_firewall_alias_endpoint_request: Optional[PatchFirewallAliasEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """patch_firewall_alias_endpoint

        <h3>Description:</h3>Updates an existing Firewall Alias.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallAlias<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-alias-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_alias_endpoint_request:
        :type patch_firewall_alias_endpoint_request: PatchFirewallAliasEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_alias_endpoint_serialize(
            patch_firewall_alias_endpoint_request=patch_firewall_alias_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallAliasEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _patch_firewall_alias_endpoint_serialize(
        self,
        patch_firewall_alias_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if patch_firewall_alias_endpoint_request is not None:
            _body_params = patch_firewall_alias_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/v2/firewall/alias',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def patch_firewall_nat_one_to_one_mapping_endpoint(
        self,
        patch_firewall_nat_one_to_one_mapping_endpoint_request: Optional[PatchFirewallNATOneToOneMappingEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallNATOneToOneMappingEndpoint200Response:
        """patch_firewall_nat_one_to_one_mapping_endpoint

        <h3>Description:</h3>Updates an existing 1:1 NAT mapping.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OneToOneNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-one-to-one-mapping-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_nat_one_to_one_mapping_endpoint_request:
        :type patch_firewall_nat_one_to_one_mapping_endpoint_request: PatchFirewallNATOneToOneMappingEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_nat_one_to_one_mapping_endpoint_serialize(
            patch_firewall_nat_one_to_one_mapping_endpoint_request=patch_firewall_nat_one_to_one_mapping_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOneToOneMappingEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def patch_firewall_nat_one_to_one_mapping_endpoint_with_http_info(
        self,
        patch_firewall_nat_one_to_one_mapping_endpoint_request: Optional[PatchFirewallNATOneToOneMappingEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallNATOneToOneMappingEndpoint200Response]:
        """patch_firewall_nat_one_to_one_mapping_endpoint

        <h3>Description:</h3>Updates an existing 1:1 NAT mapping.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OneToOneNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-one-to-one-mapping-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_nat_one_to_one_mapping_endpoint_request:
        :type patch_firewall_nat_one_to_one_mapping_endpoint_request: PatchFirewallNATOneToOneMappingEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_nat_one_to_one_mapping_endpoint_serialize(
            patch_firewall_nat_one_to_one_mapping_endpoint_request=patch_firewall_nat_one_to_one_mapping_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOneToOneMappingEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def patch_firewall_nat_one_to_one_mapping_endpoint_without_preload_content(
        self,
        patch_firewall_nat_one_to_one_mapping_endpoint_request: Optional[PatchFirewallNATOneToOneMappingEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """patch_firewall_nat_one_to_one_mapping_endpoint

        <h3>Description:</h3>Updates an existing 1:1 NAT mapping.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OneToOneNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-one-to-one-mapping-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_nat_one_to_one_mapping_endpoint_request:
        :type patch_firewall_nat_one_to_one_mapping_endpoint_request: PatchFirewallNATOneToOneMappingEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_nat_one_to_one_mapping_endpoint_serialize(
            patch_firewall_nat_one_to_one_mapping_endpoint_request=patch_firewall_nat_one_to_one_mapping_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOneToOneMappingEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _patch_firewall_nat_one_to_one_mapping_endpoint_serialize(
        self,
        patch_firewall_nat_one_to_one_mapping_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if patch_firewall_nat_one_to_one_mapping_endpoint_request is not None:
            _body_params = patch_firewall_nat_one_to_one_mapping_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/v2/firewall/nat/one_to_one/mapping',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def patch_firewall_nat_outbound_mapping_endpoint(
        self,
        patch_firewall_nat_outbound_mapping_endpoint_request: Optional[PatchFirewallNATOutboundMappingEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallNATOutboundMappingEndpoint200Response:
        """patch_firewall_nat_outbound_mapping_endpoint

        <h3>Description:</h3>Updates an existing Outbound NAT Mapping.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OutboundNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-outbound-mapping-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_nat_outbound_mapping_endpoint_request:
        :type patch_firewall_nat_outbound_mapping_endpoint_request: PatchFirewallNATOutboundMappingEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_nat_outbound_mapping_endpoint_serialize(
            patch_firewall_nat_outbound_mapping_endpoint_request=patch_firewall_nat_outbound_mapping_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOutboundMappingEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def patch_firewall_nat_outbound_mapping_endpoint_with_http_info(
        self,
        patch_firewall_nat_outbound_mapping_endpoint_request: Optional[PatchFirewallNATOutboundMappingEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallNATOutboundMappingEndpoint200Response]:
        """patch_firewall_nat_outbound_mapping_endpoint

        <h3>Description:</h3>Updates an existing Outbound NAT Mapping.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OutboundNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-outbound-mapping-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_nat_outbound_mapping_endpoint_request:
        :type patch_firewall_nat_outbound_mapping_endpoint_request: PatchFirewallNATOutboundMappingEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_nat_outbound_mapping_endpoint_serialize(
            patch_firewall_nat_outbound_mapping_endpoint_request=patch_firewall_nat_outbound_mapping_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOutboundMappingEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def patch_firewall_nat_outbound_mapping_endpoint_without_preload_content(
        self,
        patch_firewall_nat_outbound_mapping_endpoint_request: Optional[PatchFirewallNATOutboundMappingEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """patch_firewall_nat_outbound_mapping_endpoint

        <h3>Description:</h3>Updates an existing Outbound NAT Mapping.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OutboundNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-outbound-mapping-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_nat_outbound_mapping_endpoint_request:
        :type patch_firewall_nat_outbound_mapping_endpoint_request: PatchFirewallNATOutboundMappingEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_nat_outbound_mapping_endpoint_serialize(
            patch_firewall_nat_outbound_mapping_endpoint_request=patch_firewall_nat_outbound_mapping_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOutboundMappingEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _patch_firewall_nat_outbound_mapping_endpoint_serialize(
        self,
        patch_firewall_nat_outbound_mapping_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if patch_firewall_nat_outbound_mapping_endpoint_request is not None:
            _body_params = patch_firewall_nat_outbound_mapping_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/v2/firewall/nat/outbound/mapping',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def patch_firewall_nat_outbound_mode_endpoint(
        self,
        patch_firewall_nat_outbound_mode_endpoint_request: Optional[PatchFirewallNATOutboundModeEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallNATOutboundModeEndpoint200Response:
        """patch_firewall_nat_outbound_mode_endpoint

        <h3>Description:</h3>Updates current Outbound NAT Mode.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OutboundNATMode<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-outbound-mode-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_nat_outbound_mode_endpoint_request:
        :type patch_firewall_nat_outbound_mode_endpoint_request: PatchFirewallNATOutboundModeEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_nat_outbound_mode_endpoint_serialize(
            patch_firewall_nat_outbound_mode_endpoint_request=patch_firewall_nat_outbound_mode_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOutboundModeEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def patch_firewall_nat_outbound_mode_endpoint_with_http_info(
        self,
        patch_firewall_nat_outbound_mode_endpoint_request: Optional[PatchFirewallNATOutboundModeEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallNATOutboundModeEndpoint200Response]:
        """patch_firewall_nat_outbound_mode_endpoint

        <h3>Description:</h3>Updates current Outbound NAT Mode.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OutboundNATMode<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-outbound-mode-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_nat_outbound_mode_endpoint_request:
        :type patch_firewall_nat_outbound_mode_endpoint_request: PatchFirewallNATOutboundModeEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_nat_outbound_mode_endpoint_serialize(
            patch_firewall_nat_outbound_mode_endpoint_request=patch_firewall_nat_outbound_mode_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOutboundModeEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def patch_firewall_nat_outbound_mode_endpoint_without_preload_content(
        self,
        patch_firewall_nat_outbound_mode_endpoint_request: Optional[PatchFirewallNATOutboundModeEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """patch_firewall_nat_outbound_mode_endpoint

        <h3>Description:</h3>Updates current Outbound NAT Mode.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OutboundNATMode<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-outbound-mode-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_nat_outbound_mode_endpoint_request:
        :type patch_firewall_nat_outbound_mode_endpoint_request: PatchFirewallNATOutboundModeEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_nat_outbound_mode_endpoint_serialize(
            patch_firewall_nat_outbound_mode_endpoint_request=patch_firewall_nat_outbound_mode_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOutboundModeEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _patch_firewall_nat_outbound_mode_endpoint_serialize(
        self,
        patch_firewall_nat_outbound_mode_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if patch_firewall_nat_outbound_mode_endpoint_request is not None:
            _body_params = patch_firewall_nat_outbound_mode_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/v2/firewall/nat/outbound/mode',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def patch_firewall_nat_port_forward_endpoint(
        self,
        patch_firewall_nat_port_forward_endpoint_request: Optional[PatchFirewallNATPortForwardEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallNATPortForwardEndpoint200Response:
        """patch_firewall_nat_port_forward_endpoint

        <h3>Description:</h3>Updates an existing Port Forward.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: PortForward<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-port-forward-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_nat_port_forward_endpoint_request:
        :type patch_firewall_nat_port_forward_endpoint_request: PatchFirewallNATPortForwardEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_nat_port_forward_endpoint_serialize(
            patch_firewall_nat_port_forward_endpoint_request=patch_firewall_nat_port_forward_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATPortForwardEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def patch_firewall_nat_port_forward_endpoint_with_http_info(
        self,
        patch_firewall_nat_port_forward_endpoint_request: Optional[PatchFirewallNATPortForwardEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallNATPortForwardEndpoint200Response]:
        """patch_firewall_nat_port_forward_endpoint

        <h3>Description:</h3>Updates an existing Port Forward.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: PortForward<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-port-forward-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_nat_port_forward_endpoint_request:
        :type patch_firewall_nat_port_forward_endpoint_request: PatchFirewallNATPortForwardEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_nat_port_forward_endpoint_serialize(
            patch_firewall_nat_port_forward_endpoint_request=patch_firewall_nat_port_forward_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATPortForwardEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def patch_firewall_nat_port_forward_endpoint_without_preload_content(
        self,
        patch_firewall_nat_port_forward_endpoint_request: Optional[PatchFirewallNATPortForwardEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """patch_firewall_nat_port_forward_endpoint

        <h3>Description:</h3>Updates an existing Port Forward.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: PortForward<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-port-forward-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_nat_port_forward_endpoint_request:
        :type patch_firewall_nat_port_forward_endpoint_request: PatchFirewallNATPortForwardEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_nat_port_forward_endpoint_serialize(
            patch_firewall_nat_port_forward_endpoint_request=patch_firewall_nat_port_forward_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATPortForwardEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _patch_firewall_nat_port_forward_endpoint_serialize(
        self,
        patch_firewall_nat_port_forward_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if patch_firewall_nat_port_forward_endpoint_request is not None:
            _body_params = patch_firewall_nat_port_forward_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/v2/firewall/nat/port_forward',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def patch_firewall_rule_endpoint(
        self,
        patch_firewall_rule_endpoint_request: Optional[PatchFirewallRuleEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallRuleEndpoint200Response:
        """patch_firewall_rule_endpoint

        <h3>Description:</h3>Updates an existing Firewall Rule.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallRule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-rule-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_rule_endpoint_request:
        :type patch_firewall_rule_endpoint_request: PatchFirewallRuleEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_rule_endpoint_serialize(
            patch_firewall_rule_endpoint_request=patch_firewall_rule_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallRuleEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def patch_firewall_rule_endpoint_with_http_info(
        self,
        patch_firewall_rule_endpoint_request: Optional[PatchFirewallRuleEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallRuleEndpoint200Response]:
        """patch_firewall_rule_endpoint

        <h3>Description:</h3>Updates an existing Firewall Rule.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallRule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-rule-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_rule_endpoint_request:
        :type patch_firewall_rule_endpoint_request: PatchFirewallRuleEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_rule_endpoint_serialize(
            patch_firewall_rule_endpoint_request=patch_firewall_rule_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallRuleEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def patch_firewall_rule_endpoint_without_preload_content(
        self,
        patch_firewall_rule_endpoint_request: Optional[PatchFirewallRuleEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """patch_firewall_rule_endpoint

        <h3>Description:</h3>Updates an existing Firewall Rule.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallRule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-rule-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_rule_endpoint_request:
        :type patch_firewall_rule_endpoint_request: PatchFirewallRuleEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_rule_endpoint_serialize(
            patch_firewall_rule_endpoint_request=patch_firewall_rule_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallRuleEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _patch_firewall_rule_endpoint_serialize(
        self,
        patch_firewall_rule_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if patch_firewall_rule_endpoint_request is not None:
            _body_params = patch_firewall_rule_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/v2/firewall/rule',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def patch_firewall_schedule_endpoint(
        self,
        patch_firewall_schedule_endpoint_request: Optional[PatchFirewallScheduleEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallScheduleEndpoint200Response:
        """patch_firewall_schedule_endpoint

        <h3>Description:</h3>Updates an existing Firewall Schedule.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallSchedule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedule-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param patch_firewall_schedule_endpoint_request:
        :type patch_firewall_schedule_endpoint_request: PatchFirewallScheduleEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_schedule_endpoint_serialize(
            patch_firewall_schedule_endpoint_request=patch_firewall_schedule_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallScheduleEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def patch_firewall_schedule_endpoint_with_http_info(
        self,
        patch_firewall_schedule_endpoint_request: Optional[PatchFirewallScheduleEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallScheduleEndpoint200Response]:
        """patch_firewall_schedule_endpoint

        <h3>Description:</h3>Updates an existing Firewall Schedule.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallSchedule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedule-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param patch_firewall_schedule_endpoint_request:
        :type patch_firewall_schedule_endpoint_request: PatchFirewallScheduleEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_schedule_endpoint_serialize(
            patch_firewall_schedule_endpoint_request=patch_firewall_schedule_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallScheduleEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def patch_firewall_schedule_endpoint_without_preload_content(
        self,
        patch_firewall_schedule_endpoint_request: Optional[PatchFirewallScheduleEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """patch_firewall_schedule_endpoint

        <h3>Description:</h3>Updates an existing Firewall Schedule.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallSchedule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedule-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param patch_firewall_schedule_endpoint_request:
        :type patch_firewall_schedule_endpoint_request: PatchFirewallScheduleEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_schedule_endpoint_serialize(
            patch_firewall_schedule_endpoint_request=patch_firewall_schedule_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallScheduleEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _patch_firewall_schedule_endpoint_serialize(
        self,
        patch_firewall_schedule_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if patch_firewall_schedule_endpoint_request is not None:
            _body_params = patch_firewall_schedule_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/v2/firewall/schedule',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def patch_firewall_schedule_time_range_endpoint(
        self,
        patch_firewall_schedule_time_range_endpoint_request: Optional[PatchFirewallScheduleTimeRangeEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallScheduleTimeRangeEndpoint200Response:
        """patch_firewall_schedule_time_range_endpoint

        <h3>Description:</h3>Updates an existing Firewall Schedule Time Range.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallScheduleTimeRange<br>**Parent model**: FirewallSchedule<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedule-time-range-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param patch_firewall_schedule_time_range_endpoint_request:
        :type patch_firewall_schedule_time_range_endpoint_request: PatchFirewallScheduleTimeRangeEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_schedule_time_range_endpoint_serialize(
            patch_firewall_schedule_time_range_endpoint_request=patch_firewall_schedule_time_range_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallScheduleTimeRangeEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def patch_firewall_schedule_time_range_endpoint_with_http_info(
        self,
        patch_firewall_schedule_time_range_endpoint_request: Optional[PatchFirewallScheduleTimeRangeEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallScheduleTimeRangeEndpoint200Response]:
        """patch_firewall_schedule_time_range_endpoint

        <h3>Description:</h3>Updates an existing Firewall Schedule Time Range.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallScheduleTimeRange<br>**Parent model**: FirewallSchedule<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedule-time-range-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param patch_firewall_schedule_time_range_endpoint_request:
        :type patch_firewall_schedule_time_range_endpoint_request: PatchFirewallScheduleTimeRangeEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_schedule_time_range_endpoint_serialize(
            patch_firewall_schedule_time_range_endpoint_request=patch_firewall_schedule_time_range_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallScheduleTimeRangeEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def patch_firewall_schedule_time_range_endpoint_without_preload_content(
        self,
        patch_firewall_schedule_time_range_endpoint_request: Optional[PatchFirewallScheduleTimeRangeEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """patch_firewall_schedule_time_range_endpoint

        <h3>Description:</h3>Updates an existing Firewall Schedule Time Range.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallScheduleTimeRange<br>**Parent model**: FirewallSchedule<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedule-time-range-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param patch_firewall_schedule_time_range_endpoint_request:
        :type patch_firewall_schedule_time_range_endpoint_request: PatchFirewallScheduleTimeRangeEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_schedule_time_range_endpoint_serialize(
            patch_firewall_schedule_time_range_endpoint_request=patch_firewall_schedule_time_range_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallScheduleTimeRangeEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _patch_firewall_schedule_time_range_endpoint_serialize(
        self,
        patch_firewall_schedule_time_range_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if patch_firewall_schedule_time_range_endpoint_request is not None:
            _body_params = patch_firewall_schedule_time_range_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/v2/firewall/schedule/time_range',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def patch_firewall_states_size_endpoint(
        self,
        patch_firewall_states_size_endpoint_request: Optional[PatchFirewallStatesSizeEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallStatesSizeEndpoint200Response:
        """patch_firewall_states_size_endpoint

        <h3>Description:</h3>Updates current Firewall States Size.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallStatesSize<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-states-size-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param patch_firewall_states_size_endpoint_request:
        :type patch_firewall_states_size_endpoint_request: PatchFirewallStatesSizeEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_states_size_endpoint_serialize(
            patch_firewall_states_size_endpoint_request=patch_firewall_states_size_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallStatesSizeEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def patch_firewall_states_size_endpoint_with_http_info(
        self,
        patch_firewall_states_size_endpoint_request: Optional[PatchFirewallStatesSizeEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallStatesSizeEndpoint200Response]:
        """patch_firewall_states_size_endpoint

        <h3>Description:</h3>Updates current Firewall States Size.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallStatesSize<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-states-size-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param patch_firewall_states_size_endpoint_request:
        :type patch_firewall_states_size_endpoint_request: PatchFirewallStatesSizeEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_states_size_endpoint_serialize(
            patch_firewall_states_size_endpoint_request=patch_firewall_states_size_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallStatesSizeEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def patch_firewall_states_size_endpoint_without_preload_content(
        self,
        patch_firewall_states_size_endpoint_request: Optional[PatchFirewallStatesSizeEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """patch_firewall_states_size_endpoint

        <h3>Description:</h3>Updates current Firewall States Size.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallStatesSize<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-states-size-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param patch_firewall_states_size_endpoint_request:
        :type patch_firewall_states_size_endpoint_request: PatchFirewallStatesSizeEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_states_size_endpoint_serialize(
            patch_firewall_states_size_endpoint_request=patch_firewall_states_size_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallStatesSizeEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _patch_firewall_states_size_endpoint_serialize(
        self,
        patch_firewall_states_size_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if patch_firewall_states_size_endpoint_request is not None:
            _body_params = patch_firewall_states_size_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/v2/firewall/states/size',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def patch_firewall_traffic_shaper_endpoint(
        self,
        patch_firewall_traffic_shaper_endpoint_request: Optional[PatchFirewallTrafficShaperEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallTrafficShaperEndpoint200Response:
        """patch_firewall_traffic_shaper_endpoint

        <h3>Description:</h3>Updates an existing Traffic Shaper.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaper<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_traffic_shaper_endpoint_request:
        :type patch_firewall_traffic_shaper_endpoint_request: PatchFirewallTrafficShaperEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_traffic_shaper_endpoint_serialize(
            patch_firewall_traffic_shaper_endpoint_request=patch_firewall_traffic_shaper_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def patch_firewall_traffic_shaper_endpoint_with_http_info(
        self,
        patch_firewall_traffic_shaper_endpoint_request: Optional[PatchFirewallTrafficShaperEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallTrafficShaperEndpoint200Response]:
        """patch_firewall_traffic_shaper_endpoint

        <h3>Description:</h3>Updates an existing Traffic Shaper.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaper<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_traffic_shaper_endpoint_request:
        :type patch_firewall_traffic_shaper_endpoint_request: PatchFirewallTrafficShaperEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_traffic_shaper_endpoint_serialize(
            patch_firewall_traffic_shaper_endpoint_request=patch_firewall_traffic_shaper_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def patch_firewall_traffic_shaper_endpoint_without_preload_content(
        self,
        patch_firewall_traffic_shaper_endpoint_request: Optional[PatchFirewallTrafficShaperEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """patch_firewall_traffic_shaper_endpoint

        <h3>Description:</h3>Updates an existing Traffic Shaper.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaper<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_traffic_shaper_endpoint_request:
        :type patch_firewall_traffic_shaper_endpoint_request: PatchFirewallTrafficShaperEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_traffic_shaper_endpoint_serialize(
            patch_firewall_traffic_shaper_endpoint_request=patch_firewall_traffic_shaper_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _patch_firewall_traffic_shaper_endpoint_serialize(
        self,
        patch_firewall_traffic_shaper_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if patch_firewall_traffic_shaper_endpoint_request is not None:
            _body_params = patch_firewall_traffic_shaper_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/v2/firewall/traffic_shaper',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def patch_firewall_traffic_shaper_limiter_bandwidth_endpoint(
        self,
        patch_firewall_traffic_shaper_limiter_bandwidth_endpoint_request: Optional[PatchFirewallTrafficShaperLimiterBandwidthEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallTrafficShaperLimiterBandwidthEndpoint200Response:
        """patch_firewall_traffic_shaper_limiter_bandwidth_endpoint

        <h3>Description:</h3>Updates an existing Traffic Shaper Limiter Bandwidth.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiterBandwidth<br>**Parent model**: TrafficShaperLimiter<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-bandwidth-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_traffic_shaper_limiter_bandwidth_endpoint_request:
        :type patch_firewall_traffic_shaper_limiter_bandwidth_endpoint_request: PatchFirewallTrafficShaperLimiterBandwidthEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_traffic_shaper_limiter_bandwidth_endpoint_serialize(
            patch_firewall_traffic_shaper_limiter_bandwidth_endpoint_request=patch_firewall_traffic_shaper_limiter_bandwidth_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterBandwidthEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def patch_firewall_traffic_shaper_limiter_bandwidth_endpoint_with_http_info(
        self,
        patch_firewall_traffic_shaper_limiter_bandwidth_endpoint_request: Optional[PatchFirewallTrafficShaperLimiterBandwidthEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallTrafficShaperLimiterBandwidthEndpoint200Response]:
        """patch_firewall_traffic_shaper_limiter_bandwidth_endpoint

        <h3>Description:</h3>Updates an existing Traffic Shaper Limiter Bandwidth.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiterBandwidth<br>**Parent model**: TrafficShaperLimiter<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-bandwidth-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_traffic_shaper_limiter_bandwidth_endpoint_request:
        :type patch_firewall_traffic_shaper_limiter_bandwidth_endpoint_request: PatchFirewallTrafficShaperLimiterBandwidthEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_traffic_shaper_limiter_bandwidth_endpoint_serialize(
            patch_firewall_traffic_shaper_limiter_bandwidth_endpoint_request=patch_firewall_traffic_shaper_limiter_bandwidth_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterBandwidthEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def patch_firewall_traffic_shaper_limiter_bandwidth_endpoint_without_preload_content(
        self,
        patch_firewall_traffic_shaper_limiter_bandwidth_endpoint_request: Optional[PatchFirewallTrafficShaperLimiterBandwidthEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """patch_firewall_traffic_shaper_limiter_bandwidth_endpoint

        <h3>Description:</h3>Updates an existing Traffic Shaper Limiter Bandwidth.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiterBandwidth<br>**Parent model**: TrafficShaperLimiter<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-bandwidth-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_traffic_shaper_limiter_bandwidth_endpoint_request:
        :type patch_firewall_traffic_shaper_limiter_bandwidth_endpoint_request: PatchFirewallTrafficShaperLimiterBandwidthEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_traffic_shaper_limiter_bandwidth_endpoint_serialize(
            patch_firewall_traffic_shaper_limiter_bandwidth_endpoint_request=patch_firewall_traffic_shaper_limiter_bandwidth_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterBandwidthEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _patch_firewall_traffic_shaper_limiter_bandwidth_endpoint_serialize(
        self,
        patch_firewall_traffic_shaper_limiter_bandwidth_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if patch_firewall_traffic_shaper_limiter_bandwidth_endpoint_request is not None:
            _body_params = patch_firewall_traffic_shaper_limiter_bandwidth_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/v2/firewall/traffic_shaper/limiter/bandwidth',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def patch_firewall_traffic_shaper_limiter_endpoint(
        self,
        patch_firewall_traffic_shaper_limiter_endpoint_request: Optional[PatchFirewallTrafficShaperLimiterEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallTrafficShaperLimiterEndpoint200Response:
        """patch_firewall_traffic_shaper_limiter_endpoint

        <h3>Description:</h3>Updates an existing Traffic Shaper Limiter.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiter<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_traffic_shaper_limiter_endpoint_request:
        :type patch_firewall_traffic_shaper_limiter_endpoint_request: PatchFirewallTrafficShaperLimiterEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_traffic_shaper_limiter_endpoint_serialize(
            patch_firewall_traffic_shaper_limiter_endpoint_request=patch_firewall_traffic_shaper_limiter_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def patch_firewall_traffic_shaper_limiter_endpoint_with_http_info(
        self,
        patch_firewall_traffic_shaper_limiter_endpoint_request: Optional[PatchFirewallTrafficShaperLimiterEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallTrafficShaperLimiterEndpoint200Response]:
        """patch_firewall_traffic_shaper_limiter_endpoint

        <h3>Description:</h3>Updates an existing Traffic Shaper Limiter.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiter<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_traffic_shaper_limiter_endpoint_request:
        :type patch_firewall_traffic_shaper_limiter_endpoint_request: PatchFirewallTrafficShaperLimiterEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_traffic_shaper_limiter_endpoint_serialize(
            patch_firewall_traffic_shaper_limiter_endpoint_request=patch_firewall_traffic_shaper_limiter_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def patch_firewall_traffic_shaper_limiter_endpoint_without_preload_content(
        self,
        patch_firewall_traffic_shaper_limiter_endpoint_request: Optional[PatchFirewallTrafficShaperLimiterEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """patch_firewall_traffic_shaper_limiter_endpoint

        <h3>Description:</h3>Updates an existing Traffic Shaper Limiter.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiter<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_traffic_shaper_limiter_endpoint_request:
        :type patch_firewall_traffic_shaper_limiter_endpoint_request: PatchFirewallTrafficShaperLimiterEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_traffic_shaper_limiter_endpoint_serialize(
            patch_firewall_traffic_shaper_limiter_endpoint_request=patch_firewall_traffic_shaper_limiter_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _patch_firewall_traffic_shaper_limiter_endpoint_serialize(
        self,
        patch_firewall_traffic_shaper_limiter_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if patch_firewall_traffic_shaper_limiter_endpoint_request is not None:
            _body_params = patch_firewall_traffic_shaper_limiter_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/v2/firewall/traffic_shaper/limiter',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def patch_firewall_traffic_shaper_limiter_queue_endpoint(
        self,
        patch_firewall_traffic_shaper_limiter_queue_endpoint_request: Optional[PatchFirewallTrafficShaperLimiterQueueEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallTrafficShaperLimiterQueueEndpoint200Response:
        """patch_firewall_traffic_shaper_limiter_queue_endpoint

        <h3>Description:</h3>Updates an existing Traffic Shaper Limiter Queue.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiterQueue<br>**Parent model**: TrafficShaperLimiter<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-queue-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_traffic_shaper_limiter_queue_endpoint_request:
        :type patch_firewall_traffic_shaper_limiter_queue_endpoint_request: PatchFirewallTrafficShaperLimiterQueueEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_traffic_shaper_limiter_queue_endpoint_serialize(
            patch_firewall_traffic_shaper_limiter_queue_endpoint_request=patch_firewall_traffic_shaper_limiter_queue_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterQueueEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def patch_firewall_traffic_shaper_limiter_queue_endpoint_with_http_info(
        self,
        patch_firewall_traffic_shaper_limiter_queue_endpoint_request: Optional[PatchFirewallTrafficShaperLimiterQueueEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallTrafficShaperLimiterQueueEndpoint200Response]:
        """patch_firewall_traffic_shaper_limiter_queue_endpoint

        <h3>Description:</h3>Updates an existing Traffic Shaper Limiter Queue.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiterQueue<br>**Parent model**: TrafficShaperLimiter<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-queue-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_traffic_shaper_limiter_queue_endpoint_request:
        :type patch_firewall_traffic_shaper_limiter_queue_endpoint_request: PatchFirewallTrafficShaperLimiterQueueEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_traffic_shaper_limiter_queue_endpoint_serialize(
            patch_firewall_traffic_shaper_limiter_queue_endpoint_request=patch_firewall_traffic_shaper_limiter_queue_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterQueueEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def patch_firewall_traffic_shaper_limiter_queue_endpoint_without_preload_content(
        self,
        patch_firewall_traffic_shaper_limiter_queue_endpoint_request: Optional[PatchFirewallTrafficShaperLimiterQueueEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """patch_firewall_traffic_shaper_limiter_queue_endpoint

        <h3>Description:</h3>Updates an existing Traffic Shaper Limiter Queue.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiterQueue<br>**Parent model**: TrafficShaperLimiter<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-queue-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_traffic_shaper_limiter_queue_endpoint_request:
        :type patch_firewall_traffic_shaper_limiter_queue_endpoint_request: PatchFirewallTrafficShaperLimiterQueueEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_traffic_shaper_limiter_queue_endpoint_serialize(
            patch_firewall_traffic_shaper_limiter_queue_endpoint_request=patch_firewall_traffic_shaper_limiter_queue_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterQueueEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _patch_firewall_traffic_shaper_limiter_queue_endpoint_serialize(
        self,
        patch_firewall_traffic_shaper_limiter_queue_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if patch_firewall_traffic_shaper_limiter_queue_endpoint_request is not None:
            _body_params = patch_firewall_traffic_shaper_limiter_queue_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/v2/firewall/traffic_shaper/limiter/queue',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def patch_firewall_traffic_shaper_queue_endpoint(
        self,
        patch_firewall_traffic_shaper_queue_endpoint_request: Optional[PatchFirewallTrafficShaperQueueEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallTrafficShaperQueueEndpoint200Response:
        """patch_firewall_traffic_shaper_queue_endpoint

        <h3>Description:</h3>Updates an existing Traffic Shaper Queue.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperQueue<br>**Parent model**: TrafficShaper<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-queue-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_traffic_shaper_queue_endpoint_request:
        :type patch_firewall_traffic_shaper_queue_endpoint_request: PatchFirewallTrafficShaperQueueEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_traffic_shaper_queue_endpoint_serialize(
            patch_firewall_traffic_shaper_queue_endpoint_request=patch_firewall_traffic_shaper_queue_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperQueueEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def patch_firewall_traffic_shaper_queue_endpoint_with_http_info(
        self,
        patch_firewall_traffic_shaper_queue_endpoint_request: Optional[PatchFirewallTrafficShaperQueueEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallTrafficShaperQueueEndpoint200Response]:
        """patch_firewall_traffic_shaper_queue_endpoint

        <h3>Description:</h3>Updates an existing Traffic Shaper Queue.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperQueue<br>**Parent model**: TrafficShaper<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-queue-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_traffic_shaper_queue_endpoint_request:
        :type patch_firewall_traffic_shaper_queue_endpoint_request: PatchFirewallTrafficShaperQueueEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_traffic_shaper_queue_endpoint_serialize(
            patch_firewall_traffic_shaper_queue_endpoint_request=patch_firewall_traffic_shaper_queue_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperQueueEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def patch_firewall_traffic_shaper_queue_endpoint_without_preload_content(
        self,
        patch_firewall_traffic_shaper_queue_endpoint_request: Optional[PatchFirewallTrafficShaperQueueEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """patch_firewall_traffic_shaper_queue_endpoint

        <h3>Description:</h3>Updates an existing Traffic Shaper Queue.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperQueue<br>**Parent model**: TrafficShaper<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-queue-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_traffic_shaper_queue_endpoint_request:
        :type patch_firewall_traffic_shaper_queue_endpoint_request: PatchFirewallTrafficShaperQueueEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_traffic_shaper_queue_endpoint_serialize(
            patch_firewall_traffic_shaper_queue_endpoint_request=patch_firewall_traffic_shaper_queue_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperQueueEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _patch_firewall_traffic_shaper_queue_endpoint_serialize(
        self,
        patch_firewall_traffic_shaper_queue_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if patch_firewall_traffic_shaper_queue_endpoint_request is not None:
            _body_params = patch_firewall_traffic_shaper_queue_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/v2/firewall/traffic_shaper/queue',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def patch_firewall_virtual_ip_endpoint(
        self,
        patch_firewall_virtual_ip_endpoint_request: Optional[PatchFirewallVirtualIPEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallVirtualIPEndpoint200Response:
        """patch_firewall_virtual_ip_endpoint

        <h3>Description:</h3>Updates an existing Virtual IP.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: VirtualIP<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-virtual-ip-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_virtual_ip_endpoint_request:
        :type patch_firewall_virtual_ip_endpoint_request: PatchFirewallVirtualIPEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_virtual_ip_endpoint_serialize(
            patch_firewall_virtual_ip_endpoint_request=patch_firewall_virtual_ip_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallVirtualIPEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def patch_firewall_virtual_ip_endpoint_with_http_info(
        self,
        patch_firewall_virtual_ip_endpoint_request: Optional[PatchFirewallVirtualIPEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallVirtualIPEndpoint200Response]:
        """patch_firewall_virtual_ip_endpoint

        <h3>Description:</h3>Updates an existing Virtual IP.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: VirtualIP<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-virtual-ip-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_virtual_ip_endpoint_request:
        :type patch_firewall_virtual_ip_endpoint_request: PatchFirewallVirtualIPEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_virtual_ip_endpoint_serialize(
            patch_firewall_virtual_ip_endpoint_request=patch_firewall_virtual_ip_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallVirtualIPEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def patch_firewall_virtual_ip_endpoint_without_preload_content(
        self,
        patch_firewall_virtual_ip_endpoint_request: Optional[PatchFirewallVirtualIPEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """patch_firewall_virtual_ip_endpoint

        <h3>Description:</h3>Updates an existing Virtual IP.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: VirtualIP<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-virtual-ip-patch ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param patch_firewall_virtual_ip_endpoint_request:
        :type patch_firewall_virtual_ip_endpoint_request: PatchFirewallVirtualIPEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._patch_firewall_virtual_ip_endpoint_serialize(
            patch_firewall_virtual_ip_endpoint_request=patch_firewall_virtual_ip_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallVirtualIPEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _patch_firewall_virtual_ip_endpoint_serialize(
        self,
        patch_firewall_virtual_ip_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if patch_firewall_virtual_ip_endpoint_request is not None:
            _body_params = patch_firewall_virtual_ip_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='PATCH',
            resource_path='/api/v2/firewall/virtual_ip',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_firewall_alias_endpoint(
        self,
        post_firewall_alias_endpoint_request: Optional[PostFirewallAliasEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallAliasEndpoint200Response:
        """post_firewall_alias_endpoint

        <h3>Description:</h3>Creates a new Firewall Alias.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallAlias<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-alias-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_alias_endpoint_request:
        :type post_firewall_alias_endpoint_request: PostFirewallAliasEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_alias_endpoint_serialize(
            post_firewall_alias_endpoint_request=post_firewall_alias_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallAliasEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_firewall_alias_endpoint_with_http_info(
        self,
        post_firewall_alias_endpoint_request: Optional[PostFirewallAliasEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallAliasEndpoint200Response]:
        """post_firewall_alias_endpoint

        <h3>Description:</h3>Creates a new Firewall Alias.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallAlias<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-alias-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_alias_endpoint_request:
        :type post_firewall_alias_endpoint_request: PostFirewallAliasEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_alias_endpoint_serialize(
            post_firewall_alias_endpoint_request=post_firewall_alias_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallAliasEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_firewall_alias_endpoint_without_preload_content(
        self,
        post_firewall_alias_endpoint_request: Optional[PostFirewallAliasEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """post_firewall_alias_endpoint

        <h3>Description:</h3>Creates a new Firewall Alias.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallAlias<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-alias-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_alias_endpoint_request:
        :type post_firewall_alias_endpoint_request: PostFirewallAliasEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_alias_endpoint_serialize(
            post_firewall_alias_endpoint_request=post_firewall_alias_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallAliasEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_firewall_alias_endpoint_serialize(
        self,
        post_firewall_alias_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if post_firewall_alias_endpoint_request is not None:
            _body_params = post_firewall_alias_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/firewall/alias',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_firewall_apply_endpoint(
        self,
        post_firewall_apply_endpoint_request: Optional[PostFirewallApplyEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallApplyEndpoint200Response:
        """post_firewall_apply_endpoint

        <h3>Description:</h3>Apply pending firewall changes.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallApply<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-apply-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Not Applicable<br>**Utilizes cache**: None

        :param post_firewall_apply_endpoint_request:
        :type post_firewall_apply_endpoint_request: PostFirewallApplyEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_apply_endpoint_serialize(
            post_firewall_apply_endpoint_request=post_firewall_apply_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallApplyEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_firewall_apply_endpoint_with_http_info(
        self,
        post_firewall_apply_endpoint_request: Optional[PostFirewallApplyEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallApplyEndpoint200Response]:
        """post_firewall_apply_endpoint

        <h3>Description:</h3>Apply pending firewall changes.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallApply<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-apply-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Not Applicable<br>**Utilizes cache**: None

        :param post_firewall_apply_endpoint_request:
        :type post_firewall_apply_endpoint_request: PostFirewallApplyEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_apply_endpoint_serialize(
            post_firewall_apply_endpoint_request=post_firewall_apply_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallApplyEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_firewall_apply_endpoint_without_preload_content(
        self,
        post_firewall_apply_endpoint_request: Optional[PostFirewallApplyEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """post_firewall_apply_endpoint

        <h3>Description:</h3>Apply pending firewall changes.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallApply<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-apply-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Not Applicable<br>**Utilizes cache**: None

        :param post_firewall_apply_endpoint_request:
        :type post_firewall_apply_endpoint_request: PostFirewallApplyEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_apply_endpoint_serialize(
            post_firewall_apply_endpoint_request=post_firewall_apply_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallApplyEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_firewall_apply_endpoint_serialize(
        self,
        post_firewall_apply_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if post_firewall_apply_endpoint_request is not None:
            _body_params = post_firewall_apply_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/firewall/apply',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_firewall_nat_one_to_one_mapping_endpoint(
        self,
        post_firewall_nat_one_to_one_mapping_endpoint_request: Optional[PostFirewallNATOneToOneMappingEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallNATOneToOneMappingEndpoint200Response:
        """post_firewall_nat_one_to_one_mapping_endpoint

        <h3>Description:</h3>Creates a new 1:1 NAT mapping.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OneToOneNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-one-to-one-mapping-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_nat_one_to_one_mapping_endpoint_request:
        :type post_firewall_nat_one_to_one_mapping_endpoint_request: PostFirewallNATOneToOneMappingEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_nat_one_to_one_mapping_endpoint_serialize(
            post_firewall_nat_one_to_one_mapping_endpoint_request=post_firewall_nat_one_to_one_mapping_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOneToOneMappingEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_firewall_nat_one_to_one_mapping_endpoint_with_http_info(
        self,
        post_firewall_nat_one_to_one_mapping_endpoint_request: Optional[PostFirewallNATOneToOneMappingEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallNATOneToOneMappingEndpoint200Response]:
        """post_firewall_nat_one_to_one_mapping_endpoint

        <h3>Description:</h3>Creates a new 1:1 NAT mapping.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OneToOneNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-one-to-one-mapping-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_nat_one_to_one_mapping_endpoint_request:
        :type post_firewall_nat_one_to_one_mapping_endpoint_request: PostFirewallNATOneToOneMappingEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_nat_one_to_one_mapping_endpoint_serialize(
            post_firewall_nat_one_to_one_mapping_endpoint_request=post_firewall_nat_one_to_one_mapping_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOneToOneMappingEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_firewall_nat_one_to_one_mapping_endpoint_without_preload_content(
        self,
        post_firewall_nat_one_to_one_mapping_endpoint_request: Optional[PostFirewallNATOneToOneMappingEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """post_firewall_nat_one_to_one_mapping_endpoint

        <h3>Description:</h3>Creates a new 1:1 NAT mapping.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OneToOneNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-one-to-one-mapping-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_nat_one_to_one_mapping_endpoint_request:
        :type post_firewall_nat_one_to_one_mapping_endpoint_request: PostFirewallNATOneToOneMappingEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_nat_one_to_one_mapping_endpoint_serialize(
            post_firewall_nat_one_to_one_mapping_endpoint_request=post_firewall_nat_one_to_one_mapping_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOneToOneMappingEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_firewall_nat_one_to_one_mapping_endpoint_serialize(
        self,
        post_firewall_nat_one_to_one_mapping_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if post_firewall_nat_one_to_one_mapping_endpoint_request is not None:
            _body_params = post_firewall_nat_one_to_one_mapping_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/firewall/nat/one_to_one/mapping',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_firewall_nat_outbound_mapping_endpoint(
        self,
        post_firewall_nat_outbound_mapping_endpoint_request: Optional[PostFirewallNATOutboundMappingEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallNATOutboundMappingEndpoint200Response:
        """post_firewall_nat_outbound_mapping_endpoint

        <h3>Description:</h3>Creates a new Outbound NAT Mapping.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OutboundNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-outbound-mapping-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_nat_outbound_mapping_endpoint_request:
        :type post_firewall_nat_outbound_mapping_endpoint_request: PostFirewallNATOutboundMappingEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_nat_outbound_mapping_endpoint_serialize(
            post_firewall_nat_outbound_mapping_endpoint_request=post_firewall_nat_outbound_mapping_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOutboundMappingEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_firewall_nat_outbound_mapping_endpoint_with_http_info(
        self,
        post_firewall_nat_outbound_mapping_endpoint_request: Optional[PostFirewallNATOutboundMappingEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallNATOutboundMappingEndpoint200Response]:
        """post_firewall_nat_outbound_mapping_endpoint

        <h3>Description:</h3>Creates a new Outbound NAT Mapping.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OutboundNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-outbound-mapping-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_nat_outbound_mapping_endpoint_request:
        :type post_firewall_nat_outbound_mapping_endpoint_request: PostFirewallNATOutboundMappingEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_nat_outbound_mapping_endpoint_serialize(
            post_firewall_nat_outbound_mapping_endpoint_request=post_firewall_nat_outbound_mapping_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOutboundMappingEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_firewall_nat_outbound_mapping_endpoint_without_preload_content(
        self,
        post_firewall_nat_outbound_mapping_endpoint_request: Optional[PostFirewallNATOutboundMappingEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """post_firewall_nat_outbound_mapping_endpoint

        <h3>Description:</h3>Creates a new Outbound NAT Mapping.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: OutboundNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-outbound-mapping-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_nat_outbound_mapping_endpoint_request:
        :type post_firewall_nat_outbound_mapping_endpoint_request: PostFirewallNATOutboundMappingEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_nat_outbound_mapping_endpoint_serialize(
            post_firewall_nat_outbound_mapping_endpoint_request=post_firewall_nat_outbound_mapping_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOutboundMappingEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_firewall_nat_outbound_mapping_endpoint_serialize(
        self,
        post_firewall_nat_outbound_mapping_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if post_firewall_nat_outbound_mapping_endpoint_request is not None:
            _body_params = post_firewall_nat_outbound_mapping_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/firewall/nat/outbound/mapping',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_firewall_nat_port_forward_endpoint(
        self,
        post_firewall_nat_port_forward_endpoint_request: Optional[PostFirewallNATPortForwardEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallNATPortForwardEndpoint200Response:
        """post_firewall_nat_port_forward_endpoint

        <h3>Description:</h3>Creates a new Port Forward.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: PortForward<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-port-forward-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_nat_port_forward_endpoint_request:
        :type post_firewall_nat_port_forward_endpoint_request: PostFirewallNATPortForwardEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_nat_port_forward_endpoint_serialize(
            post_firewall_nat_port_forward_endpoint_request=post_firewall_nat_port_forward_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATPortForwardEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_firewall_nat_port_forward_endpoint_with_http_info(
        self,
        post_firewall_nat_port_forward_endpoint_request: Optional[PostFirewallNATPortForwardEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallNATPortForwardEndpoint200Response]:
        """post_firewall_nat_port_forward_endpoint

        <h3>Description:</h3>Creates a new Port Forward.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: PortForward<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-port-forward-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_nat_port_forward_endpoint_request:
        :type post_firewall_nat_port_forward_endpoint_request: PostFirewallNATPortForwardEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_nat_port_forward_endpoint_serialize(
            post_firewall_nat_port_forward_endpoint_request=post_firewall_nat_port_forward_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATPortForwardEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_firewall_nat_port_forward_endpoint_without_preload_content(
        self,
        post_firewall_nat_port_forward_endpoint_request: Optional[PostFirewallNATPortForwardEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """post_firewall_nat_port_forward_endpoint

        <h3>Description:</h3>Creates a new Port Forward.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: PortForward<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-port-forward-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_nat_port_forward_endpoint_request:
        :type post_firewall_nat_port_forward_endpoint_request: PostFirewallNATPortForwardEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_nat_port_forward_endpoint_serialize(
            post_firewall_nat_port_forward_endpoint_request=post_firewall_nat_port_forward_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATPortForwardEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_firewall_nat_port_forward_endpoint_serialize(
        self,
        post_firewall_nat_port_forward_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if post_firewall_nat_port_forward_endpoint_request is not None:
            _body_params = post_firewall_nat_port_forward_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/firewall/nat/port_forward',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_firewall_rule_endpoint(
        self,
        post_firewall_rule_endpoint_request: Optional[PostFirewallRuleEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallRuleEndpoint200Response:
        """post_firewall_rule_endpoint

        <h3>Description:</h3>Creates a new Firewall Rule.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallRule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-rule-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_rule_endpoint_request:
        :type post_firewall_rule_endpoint_request: PostFirewallRuleEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_rule_endpoint_serialize(
            post_firewall_rule_endpoint_request=post_firewall_rule_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallRuleEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_firewall_rule_endpoint_with_http_info(
        self,
        post_firewall_rule_endpoint_request: Optional[PostFirewallRuleEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallRuleEndpoint200Response]:
        """post_firewall_rule_endpoint

        <h3>Description:</h3>Creates a new Firewall Rule.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallRule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-rule-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_rule_endpoint_request:
        :type post_firewall_rule_endpoint_request: PostFirewallRuleEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_rule_endpoint_serialize(
            post_firewall_rule_endpoint_request=post_firewall_rule_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallRuleEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_firewall_rule_endpoint_without_preload_content(
        self,
        post_firewall_rule_endpoint_request: Optional[PostFirewallRuleEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """post_firewall_rule_endpoint

        <h3>Description:</h3>Creates a new Firewall Rule.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallRule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-rule-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_rule_endpoint_request:
        :type post_firewall_rule_endpoint_request: PostFirewallRuleEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_rule_endpoint_serialize(
            post_firewall_rule_endpoint_request=post_firewall_rule_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallRuleEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_firewall_rule_endpoint_serialize(
        self,
        post_firewall_rule_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if post_firewall_rule_endpoint_request is not None:
            _body_params = post_firewall_rule_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/firewall/rule',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_firewall_schedule_endpoint(
        self,
        post_firewall_schedule_endpoint_request: Optional[PostFirewallScheduleEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallScheduleEndpoint200Response:
        """post_firewall_schedule_endpoint

        <h3>Description:</h3>Creates a new Firewall Schedule.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallSchedule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedule-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param post_firewall_schedule_endpoint_request:
        :type post_firewall_schedule_endpoint_request: PostFirewallScheduleEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_schedule_endpoint_serialize(
            post_firewall_schedule_endpoint_request=post_firewall_schedule_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallScheduleEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_firewall_schedule_endpoint_with_http_info(
        self,
        post_firewall_schedule_endpoint_request: Optional[PostFirewallScheduleEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallScheduleEndpoint200Response]:
        """post_firewall_schedule_endpoint

        <h3>Description:</h3>Creates a new Firewall Schedule.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallSchedule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedule-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param post_firewall_schedule_endpoint_request:
        :type post_firewall_schedule_endpoint_request: PostFirewallScheduleEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_schedule_endpoint_serialize(
            post_firewall_schedule_endpoint_request=post_firewall_schedule_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallScheduleEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_firewall_schedule_endpoint_without_preload_content(
        self,
        post_firewall_schedule_endpoint_request: Optional[PostFirewallScheduleEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """post_firewall_schedule_endpoint

        <h3>Description:</h3>Creates a new Firewall Schedule.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallSchedule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedule-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param post_firewall_schedule_endpoint_request:
        :type post_firewall_schedule_endpoint_request: PostFirewallScheduleEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_schedule_endpoint_serialize(
            post_firewall_schedule_endpoint_request=post_firewall_schedule_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallScheduleEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_firewall_schedule_endpoint_serialize(
        self,
        post_firewall_schedule_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if post_firewall_schedule_endpoint_request is not None:
            _body_params = post_firewall_schedule_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/firewall/schedule',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_firewall_schedule_time_range_endpoint(
        self,
        post_firewall_schedule_time_range_endpoint_request: Optional[PostFirewallScheduleTimeRangeEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallScheduleTimeRangeEndpoint200Response:
        """post_firewall_schedule_time_range_endpoint

        <h3>Description:</h3>Creates a new Firewall Schedule Time Range.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallScheduleTimeRange<br>**Parent model**: FirewallSchedule<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedule-time-range-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param post_firewall_schedule_time_range_endpoint_request:
        :type post_firewall_schedule_time_range_endpoint_request: PostFirewallScheduleTimeRangeEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_schedule_time_range_endpoint_serialize(
            post_firewall_schedule_time_range_endpoint_request=post_firewall_schedule_time_range_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallScheduleTimeRangeEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_firewall_schedule_time_range_endpoint_with_http_info(
        self,
        post_firewall_schedule_time_range_endpoint_request: Optional[PostFirewallScheduleTimeRangeEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallScheduleTimeRangeEndpoint200Response]:
        """post_firewall_schedule_time_range_endpoint

        <h3>Description:</h3>Creates a new Firewall Schedule Time Range.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallScheduleTimeRange<br>**Parent model**: FirewallSchedule<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedule-time-range-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param post_firewall_schedule_time_range_endpoint_request:
        :type post_firewall_schedule_time_range_endpoint_request: PostFirewallScheduleTimeRangeEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_schedule_time_range_endpoint_serialize(
            post_firewall_schedule_time_range_endpoint_request=post_firewall_schedule_time_range_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallScheduleTimeRangeEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_firewall_schedule_time_range_endpoint_without_preload_content(
        self,
        post_firewall_schedule_time_range_endpoint_request: Optional[PostFirewallScheduleTimeRangeEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """post_firewall_schedule_time_range_endpoint

        <h3>Description:</h3>Creates a new Firewall Schedule Time Range.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: FirewallScheduleTimeRange<br>**Parent model**: FirewallSchedule<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedule-time-range-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param post_firewall_schedule_time_range_endpoint_request:
        :type post_firewall_schedule_time_range_endpoint_request: PostFirewallScheduleTimeRangeEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_schedule_time_range_endpoint_serialize(
            post_firewall_schedule_time_range_endpoint_request=post_firewall_schedule_time_range_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallScheduleTimeRangeEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_firewall_schedule_time_range_endpoint_serialize(
        self,
        post_firewall_schedule_time_range_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if post_firewall_schedule_time_range_endpoint_request is not None:
            _body_params = post_firewall_schedule_time_range_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/firewall/schedule/time_range',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_firewall_traffic_shaper_endpoint(
        self,
        post_firewall_traffic_shaper_endpoint_request: Optional[PostFirewallTrafficShaperEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallTrafficShaperEndpoint200Response:
        """post_firewall_traffic_shaper_endpoint

        <h3>Description:</h3>Creates a new Traffic Shaper.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaper<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_traffic_shaper_endpoint_request:
        :type post_firewall_traffic_shaper_endpoint_request: PostFirewallTrafficShaperEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_traffic_shaper_endpoint_serialize(
            post_firewall_traffic_shaper_endpoint_request=post_firewall_traffic_shaper_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_firewall_traffic_shaper_endpoint_with_http_info(
        self,
        post_firewall_traffic_shaper_endpoint_request: Optional[PostFirewallTrafficShaperEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallTrafficShaperEndpoint200Response]:
        """post_firewall_traffic_shaper_endpoint

        <h3>Description:</h3>Creates a new Traffic Shaper.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaper<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_traffic_shaper_endpoint_request:
        :type post_firewall_traffic_shaper_endpoint_request: PostFirewallTrafficShaperEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_traffic_shaper_endpoint_serialize(
            post_firewall_traffic_shaper_endpoint_request=post_firewall_traffic_shaper_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_firewall_traffic_shaper_endpoint_without_preload_content(
        self,
        post_firewall_traffic_shaper_endpoint_request: Optional[PostFirewallTrafficShaperEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """post_firewall_traffic_shaper_endpoint

        <h3>Description:</h3>Creates a new Traffic Shaper.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaper<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_traffic_shaper_endpoint_request:
        :type post_firewall_traffic_shaper_endpoint_request: PostFirewallTrafficShaperEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_traffic_shaper_endpoint_serialize(
            post_firewall_traffic_shaper_endpoint_request=post_firewall_traffic_shaper_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_firewall_traffic_shaper_endpoint_serialize(
        self,
        post_firewall_traffic_shaper_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if post_firewall_traffic_shaper_endpoint_request is not None:
            _body_params = post_firewall_traffic_shaper_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/firewall/traffic_shaper',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_firewall_traffic_shaper_limiter_bandwidth_endpoint(
        self,
        post_firewall_traffic_shaper_limiter_bandwidth_endpoint_request: Optional[PostFirewallTrafficShaperLimiterBandwidthEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallTrafficShaperLimiterBandwidthEndpoint200Response:
        """post_firewall_traffic_shaper_limiter_bandwidth_endpoint

        <h3>Description:</h3>Creates a new Traffic Shaper Limiter Bandwidth.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiterBandwidth<br>**Parent model**: TrafficShaperLimiter<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-bandwidth-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_traffic_shaper_limiter_bandwidth_endpoint_request:
        :type post_firewall_traffic_shaper_limiter_bandwidth_endpoint_request: PostFirewallTrafficShaperLimiterBandwidthEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_traffic_shaper_limiter_bandwidth_endpoint_serialize(
            post_firewall_traffic_shaper_limiter_bandwidth_endpoint_request=post_firewall_traffic_shaper_limiter_bandwidth_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterBandwidthEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_firewall_traffic_shaper_limiter_bandwidth_endpoint_with_http_info(
        self,
        post_firewall_traffic_shaper_limiter_bandwidth_endpoint_request: Optional[PostFirewallTrafficShaperLimiterBandwidthEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallTrafficShaperLimiterBandwidthEndpoint200Response]:
        """post_firewall_traffic_shaper_limiter_bandwidth_endpoint

        <h3>Description:</h3>Creates a new Traffic Shaper Limiter Bandwidth.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiterBandwidth<br>**Parent model**: TrafficShaperLimiter<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-bandwidth-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_traffic_shaper_limiter_bandwidth_endpoint_request:
        :type post_firewall_traffic_shaper_limiter_bandwidth_endpoint_request: PostFirewallTrafficShaperLimiterBandwidthEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_traffic_shaper_limiter_bandwidth_endpoint_serialize(
            post_firewall_traffic_shaper_limiter_bandwidth_endpoint_request=post_firewall_traffic_shaper_limiter_bandwidth_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterBandwidthEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_firewall_traffic_shaper_limiter_bandwidth_endpoint_without_preload_content(
        self,
        post_firewall_traffic_shaper_limiter_bandwidth_endpoint_request: Optional[PostFirewallTrafficShaperLimiterBandwidthEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """post_firewall_traffic_shaper_limiter_bandwidth_endpoint

        <h3>Description:</h3>Creates a new Traffic Shaper Limiter Bandwidth.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiterBandwidth<br>**Parent model**: TrafficShaperLimiter<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-bandwidth-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_traffic_shaper_limiter_bandwidth_endpoint_request:
        :type post_firewall_traffic_shaper_limiter_bandwidth_endpoint_request: PostFirewallTrafficShaperLimiterBandwidthEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_traffic_shaper_limiter_bandwidth_endpoint_serialize(
            post_firewall_traffic_shaper_limiter_bandwidth_endpoint_request=post_firewall_traffic_shaper_limiter_bandwidth_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterBandwidthEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_firewall_traffic_shaper_limiter_bandwidth_endpoint_serialize(
        self,
        post_firewall_traffic_shaper_limiter_bandwidth_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if post_firewall_traffic_shaper_limiter_bandwidth_endpoint_request is not None:
            _body_params = post_firewall_traffic_shaper_limiter_bandwidth_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/firewall/traffic_shaper/limiter/bandwidth',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_firewall_traffic_shaper_limiter_endpoint(
        self,
        post_firewall_traffic_shaper_limiter_endpoint_request: Optional[PostFirewallTrafficShaperLimiterEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallTrafficShaperLimiterEndpoint200Response:
        """post_firewall_traffic_shaper_limiter_endpoint

        <h3>Description:</h3>Creates a new Traffic Shaper Limiter.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiter<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_traffic_shaper_limiter_endpoint_request:
        :type post_firewall_traffic_shaper_limiter_endpoint_request: PostFirewallTrafficShaperLimiterEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_traffic_shaper_limiter_endpoint_serialize(
            post_firewall_traffic_shaper_limiter_endpoint_request=post_firewall_traffic_shaper_limiter_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_firewall_traffic_shaper_limiter_endpoint_with_http_info(
        self,
        post_firewall_traffic_shaper_limiter_endpoint_request: Optional[PostFirewallTrafficShaperLimiterEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallTrafficShaperLimiterEndpoint200Response]:
        """post_firewall_traffic_shaper_limiter_endpoint

        <h3>Description:</h3>Creates a new Traffic Shaper Limiter.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiter<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_traffic_shaper_limiter_endpoint_request:
        :type post_firewall_traffic_shaper_limiter_endpoint_request: PostFirewallTrafficShaperLimiterEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_traffic_shaper_limiter_endpoint_serialize(
            post_firewall_traffic_shaper_limiter_endpoint_request=post_firewall_traffic_shaper_limiter_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_firewall_traffic_shaper_limiter_endpoint_without_preload_content(
        self,
        post_firewall_traffic_shaper_limiter_endpoint_request: Optional[PostFirewallTrafficShaperLimiterEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """post_firewall_traffic_shaper_limiter_endpoint

        <h3>Description:</h3>Creates a new Traffic Shaper Limiter.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiter<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_traffic_shaper_limiter_endpoint_request:
        :type post_firewall_traffic_shaper_limiter_endpoint_request: PostFirewallTrafficShaperLimiterEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_traffic_shaper_limiter_endpoint_serialize(
            post_firewall_traffic_shaper_limiter_endpoint_request=post_firewall_traffic_shaper_limiter_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_firewall_traffic_shaper_limiter_endpoint_serialize(
        self,
        post_firewall_traffic_shaper_limiter_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if post_firewall_traffic_shaper_limiter_endpoint_request is not None:
            _body_params = post_firewall_traffic_shaper_limiter_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/firewall/traffic_shaper/limiter',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_firewall_traffic_shaper_limiter_queue_endpoint(
        self,
        post_firewall_traffic_shaper_limiter_queue_endpoint_request: Optional[PostFirewallTrafficShaperLimiterQueueEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallTrafficShaperLimiterQueueEndpoint200Response:
        """post_firewall_traffic_shaper_limiter_queue_endpoint

        <h3>Description:</h3>Creates a new Traffic Shaper Limiter Queue.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiterQueue<br>**Parent model**: TrafficShaperLimiter<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-queue-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_traffic_shaper_limiter_queue_endpoint_request:
        :type post_firewall_traffic_shaper_limiter_queue_endpoint_request: PostFirewallTrafficShaperLimiterQueueEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_traffic_shaper_limiter_queue_endpoint_serialize(
            post_firewall_traffic_shaper_limiter_queue_endpoint_request=post_firewall_traffic_shaper_limiter_queue_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterQueueEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_firewall_traffic_shaper_limiter_queue_endpoint_with_http_info(
        self,
        post_firewall_traffic_shaper_limiter_queue_endpoint_request: Optional[PostFirewallTrafficShaperLimiterQueueEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallTrafficShaperLimiterQueueEndpoint200Response]:
        """post_firewall_traffic_shaper_limiter_queue_endpoint

        <h3>Description:</h3>Creates a new Traffic Shaper Limiter Queue.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiterQueue<br>**Parent model**: TrafficShaperLimiter<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-queue-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_traffic_shaper_limiter_queue_endpoint_request:
        :type post_firewall_traffic_shaper_limiter_queue_endpoint_request: PostFirewallTrafficShaperLimiterQueueEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_traffic_shaper_limiter_queue_endpoint_serialize(
            post_firewall_traffic_shaper_limiter_queue_endpoint_request=post_firewall_traffic_shaper_limiter_queue_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterQueueEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_firewall_traffic_shaper_limiter_queue_endpoint_without_preload_content(
        self,
        post_firewall_traffic_shaper_limiter_queue_endpoint_request: Optional[PostFirewallTrafficShaperLimiterQueueEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """post_firewall_traffic_shaper_limiter_queue_endpoint

        <h3>Description:</h3>Creates a new Traffic Shaper Limiter Queue.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperLimiterQueue<br>**Parent model**: TrafficShaperLimiter<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiter-queue-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_traffic_shaper_limiter_queue_endpoint_request:
        :type post_firewall_traffic_shaper_limiter_queue_endpoint_request: PostFirewallTrafficShaperLimiterQueueEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_traffic_shaper_limiter_queue_endpoint_serialize(
            post_firewall_traffic_shaper_limiter_queue_endpoint_request=post_firewall_traffic_shaper_limiter_queue_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimiterQueueEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_firewall_traffic_shaper_limiter_queue_endpoint_serialize(
        self,
        post_firewall_traffic_shaper_limiter_queue_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if post_firewall_traffic_shaper_limiter_queue_endpoint_request is not None:
            _body_params = post_firewall_traffic_shaper_limiter_queue_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/firewall/traffic_shaper/limiter/queue',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_firewall_traffic_shaper_queue_endpoint(
        self,
        post_firewall_traffic_shaper_queue_endpoint_request: Optional[PostFirewallTrafficShaperQueueEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallTrafficShaperQueueEndpoint200Response:
        """post_firewall_traffic_shaper_queue_endpoint

        <h3>Description:</h3>Creates a new Traffic Shaper Queue.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperQueue<br>**Parent model**: TrafficShaper<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-queue-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_traffic_shaper_queue_endpoint_request:
        :type post_firewall_traffic_shaper_queue_endpoint_request: PostFirewallTrafficShaperQueueEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_traffic_shaper_queue_endpoint_serialize(
            post_firewall_traffic_shaper_queue_endpoint_request=post_firewall_traffic_shaper_queue_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperQueueEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_firewall_traffic_shaper_queue_endpoint_with_http_info(
        self,
        post_firewall_traffic_shaper_queue_endpoint_request: Optional[PostFirewallTrafficShaperQueueEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallTrafficShaperQueueEndpoint200Response]:
        """post_firewall_traffic_shaper_queue_endpoint

        <h3>Description:</h3>Creates a new Traffic Shaper Queue.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperQueue<br>**Parent model**: TrafficShaper<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-queue-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_traffic_shaper_queue_endpoint_request:
        :type post_firewall_traffic_shaper_queue_endpoint_request: PostFirewallTrafficShaperQueueEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_traffic_shaper_queue_endpoint_serialize(
            post_firewall_traffic_shaper_queue_endpoint_request=post_firewall_traffic_shaper_queue_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperQueueEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_firewall_traffic_shaper_queue_endpoint_without_preload_content(
        self,
        post_firewall_traffic_shaper_queue_endpoint_request: Optional[PostFirewallTrafficShaperQueueEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """post_firewall_traffic_shaper_queue_endpoint

        <h3>Description:</h3>Creates a new Traffic Shaper Queue.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: TrafficShaperQueue<br>**Parent model**: TrafficShaper<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-queue-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_traffic_shaper_queue_endpoint_request:
        :type post_firewall_traffic_shaper_queue_endpoint_request: PostFirewallTrafficShaperQueueEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_traffic_shaper_queue_endpoint_serialize(
            post_firewall_traffic_shaper_queue_endpoint_request=post_firewall_traffic_shaper_queue_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperQueueEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_firewall_traffic_shaper_queue_endpoint_serialize(
        self,
        post_firewall_traffic_shaper_queue_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if post_firewall_traffic_shaper_queue_endpoint_request is not None:
            _body_params = post_firewall_traffic_shaper_queue_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/firewall/traffic_shaper/queue',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_firewall_virtual_ip_apply_endpoint(
        self,
        post_firewall_virtual_ip_apply_endpoint_request: Optional[PostFirewallVirtualIPApplyEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallVirtualIPApplyEndpoint200Response:
        """post_firewall_virtual_ip_apply_endpoint

        <h3>Description:</h3>Apply pending virtual IP changes.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: VirtualIPApply<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-virtual-ip-apply-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Not Applicable<br>**Utilizes cache**: None

        :param post_firewall_virtual_ip_apply_endpoint_request:
        :type post_firewall_virtual_ip_apply_endpoint_request: PostFirewallVirtualIPApplyEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_virtual_ip_apply_endpoint_serialize(
            post_firewall_virtual_ip_apply_endpoint_request=post_firewall_virtual_ip_apply_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallVirtualIPApplyEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_firewall_virtual_ip_apply_endpoint_with_http_info(
        self,
        post_firewall_virtual_ip_apply_endpoint_request: Optional[PostFirewallVirtualIPApplyEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallVirtualIPApplyEndpoint200Response]:
        """post_firewall_virtual_ip_apply_endpoint

        <h3>Description:</h3>Apply pending virtual IP changes.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: VirtualIPApply<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-virtual-ip-apply-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Not Applicable<br>**Utilizes cache**: None

        :param post_firewall_virtual_ip_apply_endpoint_request:
        :type post_firewall_virtual_ip_apply_endpoint_request: PostFirewallVirtualIPApplyEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_virtual_ip_apply_endpoint_serialize(
            post_firewall_virtual_ip_apply_endpoint_request=post_firewall_virtual_ip_apply_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallVirtualIPApplyEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_firewall_virtual_ip_apply_endpoint_without_preload_content(
        self,
        post_firewall_virtual_ip_apply_endpoint_request: Optional[PostFirewallVirtualIPApplyEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """post_firewall_virtual_ip_apply_endpoint

        <h3>Description:</h3>Apply pending virtual IP changes.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: VirtualIPApply<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-virtual-ip-apply-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Not Applicable<br>**Utilizes cache**: None

        :param post_firewall_virtual_ip_apply_endpoint_request:
        :type post_firewall_virtual_ip_apply_endpoint_request: PostFirewallVirtualIPApplyEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_virtual_ip_apply_endpoint_serialize(
            post_firewall_virtual_ip_apply_endpoint_request=post_firewall_virtual_ip_apply_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallVirtualIPApplyEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_firewall_virtual_ip_apply_endpoint_serialize(
        self,
        post_firewall_virtual_ip_apply_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if post_firewall_virtual_ip_apply_endpoint_request is not None:
            _body_params = post_firewall_virtual_ip_apply_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/firewall/virtual_ip/apply',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_firewall_virtual_ip_endpoint(
        self,
        post_firewall_virtual_ip_endpoint_request: Optional[PostFirewallVirtualIPEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallVirtualIPEndpoint200Response:
        """post_firewall_virtual_ip_endpoint

        <h3>Description:</h3>Creates a new Virtual IP.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: VirtualIP<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-virtual-ip-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_virtual_ip_endpoint_request:
        :type post_firewall_virtual_ip_endpoint_request: PostFirewallVirtualIPEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_virtual_ip_endpoint_serialize(
            post_firewall_virtual_ip_endpoint_request=post_firewall_virtual_ip_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallVirtualIPEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_firewall_virtual_ip_endpoint_with_http_info(
        self,
        post_firewall_virtual_ip_endpoint_request: Optional[PostFirewallVirtualIPEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallVirtualIPEndpoint200Response]:
        """post_firewall_virtual_ip_endpoint

        <h3>Description:</h3>Creates a new Virtual IP.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: VirtualIP<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-virtual-ip-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_virtual_ip_endpoint_request:
        :type post_firewall_virtual_ip_endpoint_request: PostFirewallVirtualIPEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_virtual_ip_endpoint_serialize(
            post_firewall_virtual_ip_endpoint_request=post_firewall_virtual_ip_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallVirtualIPEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_firewall_virtual_ip_endpoint_without_preload_content(
        self,
        post_firewall_virtual_ip_endpoint_request: Optional[PostFirewallVirtualIPEndpointRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """post_firewall_virtual_ip_endpoint

        <h3>Description:</h3>Creates a new Virtual IP.<br><h3>Details:</h3>**Endpoint type**: Singular<br>**Associated model**: VirtualIP<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-virtual-ip-post ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_virtual_ip_endpoint_request:
        :type post_firewall_virtual_ip_endpoint_request: PostFirewallVirtualIPEndpointRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_firewall_virtual_ip_endpoint_serialize(
            post_firewall_virtual_ip_endpoint_request=post_firewall_virtual_ip_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallVirtualIPEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_firewall_virtual_ip_endpoint_serialize(
        self,
        post_firewall_virtual_ip_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if post_firewall_virtual_ip_endpoint_request is not None:
            _body_params = post_firewall_virtual_ip_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v2/firewall/virtual_ip',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def put_firewall_aliases_endpoint(
        self,
        post_firewall_alias_endpoint_request: Optional[List[PostFirewallAliasEndpointRequest]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallAliasesEndpoint200Response:
        """put_firewall_aliases_endpoint

        <h3>Description:</h3>Replaces all existing Firewall Aliases.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallAlias<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-aliases-put ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_alias_endpoint_request:
        :type post_firewall_alias_endpoint_request: List[PostFirewallAliasEndpointRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_firewall_aliases_endpoint_serialize(
            post_firewall_alias_endpoint_request=post_firewall_alias_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallAliasesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def put_firewall_aliases_endpoint_with_http_info(
        self,
        post_firewall_alias_endpoint_request: Optional[List[PostFirewallAliasEndpointRequest]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallAliasesEndpoint200Response]:
        """put_firewall_aliases_endpoint

        <h3>Description:</h3>Replaces all existing Firewall Aliases.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallAlias<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-aliases-put ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_alias_endpoint_request:
        :type post_firewall_alias_endpoint_request: List[PostFirewallAliasEndpointRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_firewall_aliases_endpoint_serialize(
            post_firewall_alias_endpoint_request=post_firewall_alias_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallAliasesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def put_firewall_aliases_endpoint_without_preload_content(
        self,
        post_firewall_alias_endpoint_request: Optional[List[PostFirewallAliasEndpointRequest]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """put_firewall_aliases_endpoint

        <h3>Description:</h3>Replaces all existing Firewall Aliases.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallAlias<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-aliases-put ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_alias_endpoint_request:
        :type post_firewall_alias_endpoint_request: List[PostFirewallAliasEndpointRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_firewall_aliases_endpoint_serialize(
            post_firewall_alias_endpoint_request=post_firewall_alias_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallAliasesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _put_firewall_aliases_endpoint_serialize(
        self,
        post_firewall_alias_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'PostFirewallAliasEndpointRequest': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if post_firewall_alias_endpoint_request is not None:
            _body_params = post_firewall_alias_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/v2/firewall/aliases',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def put_firewall_nat_one_to_one_mappings_endpoint(
        self,
        post_firewall_nat_one_to_one_mapping_endpoint_request: Optional[List[PostFirewallNATOneToOneMappingEndpointRequest]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallNATOneToOneMappingsEndpoint200Response:
        """put_firewall_nat_one_to_one_mappings_endpoint

        <h3>Description:</h3>Replaces all existing 1:1 NAT mappings.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: OneToOneNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-one-to-one-mappings-put ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_nat_one_to_one_mapping_endpoint_request:
        :type post_firewall_nat_one_to_one_mapping_endpoint_request: List[PostFirewallNATOneToOneMappingEndpointRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_firewall_nat_one_to_one_mappings_endpoint_serialize(
            post_firewall_nat_one_to_one_mapping_endpoint_request=post_firewall_nat_one_to_one_mapping_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOneToOneMappingsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def put_firewall_nat_one_to_one_mappings_endpoint_with_http_info(
        self,
        post_firewall_nat_one_to_one_mapping_endpoint_request: Optional[List[PostFirewallNATOneToOneMappingEndpointRequest]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallNATOneToOneMappingsEndpoint200Response]:
        """put_firewall_nat_one_to_one_mappings_endpoint

        <h3>Description:</h3>Replaces all existing 1:1 NAT mappings.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: OneToOneNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-one-to-one-mappings-put ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_nat_one_to_one_mapping_endpoint_request:
        :type post_firewall_nat_one_to_one_mapping_endpoint_request: List[PostFirewallNATOneToOneMappingEndpointRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_firewall_nat_one_to_one_mappings_endpoint_serialize(
            post_firewall_nat_one_to_one_mapping_endpoint_request=post_firewall_nat_one_to_one_mapping_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOneToOneMappingsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def put_firewall_nat_one_to_one_mappings_endpoint_without_preload_content(
        self,
        post_firewall_nat_one_to_one_mapping_endpoint_request: Optional[List[PostFirewallNATOneToOneMappingEndpointRequest]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """put_firewall_nat_one_to_one_mappings_endpoint

        <h3>Description:</h3>Replaces all existing 1:1 NAT mappings.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: OneToOneNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-one-to-one-mappings-put ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_nat_one_to_one_mapping_endpoint_request:
        :type post_firewall_nat_one_to_one_mapping_endpoint_request: List[PostFirewallNATOneToOneMappingEndpointRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_firewall_nat_one_to_one_mappings_endpoint_serialize(
            post_firewall_nat_one_to_one_mapping_endpoint_request=post_firewall_nat_one_to_one_mapping_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOneToOneMappingsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _put_firewall_nat_one_to_one_mappings_endpoint_serialize(
        self,
        post_firewall_nat_one_to_one_mapping_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'PostFirewallNATOneToOneMappingEndpointRequest': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if post_firewall_nat_one_to_one_mapping_endpoint_request is not None:
            _body_params = post_firewall_nat_one_to_one_mapping_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/v2/firewall/nat/one_to_one/mappings',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def put_firewall_nat_outbound_mappings_endpoint(
        self,
        post_firewall_nat_outbound_mapping_endpoint_request: Optional[List[PostFirewallNATOutboundMappingEndpointRequest]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallNATOutboundMappingsEndpoint200Response:
        """put_firewall_nat_outbound_mappings_endpoint

        <h3>Description:</h3>Replaces all existing Outbound NAT Mappings.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: OutboundNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-outbound-mappings-put ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_nat_outbound_mapping_endpoint_request:
        :type post_firewall_nat_outbound_mapping_endpoint_request: List[PostFirewallNATOutboundMappingEndpointRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_firewall_nat_outbound_mappings_endpoint_serialize(
            post_firewall_nat_outbound_mapping_endpoint_request=post_firewall_nat_outbound_mapping_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOutboundMappingsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def put_firewall_nat_outbound_mappings_endpoint_with_http_info(
        self,
        post_firewall_nat_outbound_mapping_endpoint_request: Optional[List[PostFirewallNATOutboundMappingEndpointRequest]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallNATOutboundMappingsEndpoint200Response]:
        """put_firewall_nat_outbound_mappings_endpoint

        <h3>Description:</h3>Replaces all existing Outbound NAT Mappings.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: OutboundNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-outbound-mappings-put ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_nat_outbound_mapping_endpoint_request:
        :type post_firewall_nat_outbound_mapping_endpoint_request: List[PostFirewallNATOutboundMappingEndpointRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_firewall_nat_outbound_mappings_endpoint_serialize(
            post_firewall_nat_outbound_mapping_endpoint_request=post_firewall_nat_outbound_mapping_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOutboundMappingsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def put_firewall_nat_outbound_mappings_endpoint_without_preload_content(
        self,
        post_firewall_nat_outbound_mapping_endpoint_request: Optional[List[PostFirewallNATOutboundMappingEndpointRequest]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """put_firewall_nat_outbound_mappings_endpoint

        <h3>Description:</h3>Replaces all existing Outbound NAT Mappings.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: OutboundNATMapping<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-outbound-mappings-put ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_nat_outbound_mapping_endpoint_request:
        :type post_firewall_nat_outbound_mapping_endpoint_request: List[PostFirewallNATOutboundMappingEndpointRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_firewall_nat_outbound_mappings_endpoint_serialize(
            post_firewall_nat_outbound_mapping_endpoint_request=post_firewall_nat_outbound_mapping_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATOutboundMappingsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _put_firewall_nat_outbound_mappings_endpoint_serialize(
        self,
        post_firewall_nat_outbound_mapping_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'PostFirewallNATOutboundMappingEndpointRequest': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if post_firewall_nat_outbound_mapping_endpoint_request is not None:
            _body_params = post_firewall_nat_outbound_mapping_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/v2/firewall/nat/outbound/mappings',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def put_firewall_nat_port_forwards_endpoint(
        self,
        post_firewall_nat_port_forward_endpoint_request: Optional[List[PostFirewallNATPortForwardEndpointRequest]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallNATPortForwardsEndpoint200Response:
        """put_firewall_nat_port_forwards_endpoint

        <h3>Description:</h3>Replaces all existing Port Forwards.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: PortForward<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-port-forwards-put ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_nat_port_forward_endpoint_request:
        :type post_firewall_nat_port_forward_endpoint_request: List[PostFirewallNATPortForwardEndpointRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_firewall_nat_port_forwards_endpoint_serialize(
            post_firewall_nat_port_forward_endpoint_request=post_firewall_nat_port_forward_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATPortForwardsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def put_firewall_nat_port_forwards_endpoint_with_http_info(
        self,
        post_firewall_nat_port_forward_endpoint_request: Optional[List[PostFirewallNATPortForwardEndpointRequest]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallNATPortForwardsEndpoint200Response]:
        """put_firewall_nat_port_forwards_endpoint

        <h3>Description:</h3>Replaces all existing Port Forwards.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: PortForward<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-port-forwards-put ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_nat_port_forward_endpoint_request:
        :type post_firewall_nat_port_forward_endpoint_request: List[PostFirewallNATPortForwardEndpointRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_firewall_nat_port_forwards_endpoint_serialize(
            post_firewall_nat_port_forward_endpoint_request=post_firewall_nat_port_forward_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATPortForwardsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def put_firewall_nat_port_forwards_endpoint_without_preload_content(
        self,
        post_firewall_nat_port_forward_endpoint_request: Optional[List[PostFirewallNATPortForwardEndpointRequest]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """put_firewall_nat_port_forwards_endpoint

        <h3>Description:</h3>Replaces all existing Port Forwards.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: PortForward<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-nat-port-forwards-put ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_nat_port_forward_endpoint_request:
        :type post_firewall_nat_port_forward_endpoint_request: List[PostFirewallNATPortForwardEndpointRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_firewall_nat_port_forwards_endpoint_serialize(
            post_firewall_nat_port_forward_endpoint_request=post_firewall_nat_port_forward_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallNATPortForwardsEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _put_firewall_nat_port_forwards_endpoint_serialize(
        self,
        post_firewall_nat_port_forward_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'PostFirewallNATPortForwardEndpointRequest': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if post_firewall_nat_port_forward_endpoint_request is not None:
            _body_params = post_firewall_nat_port_forward_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/v2/firewall/nat/port_forwards',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def put_firewall_rules_endpoint(
        self,
        post_firewall_rule_endpoint_request: Optional[List[PostFirewallRuleEndpointRequest]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallRulesEndpoint200Response:
        """put_firewall_rules_endpoint

        <h3>Description:</h3>Replaces all existing Firewall Rules.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallRule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-rules-put ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_rule_endpoint_request:
        :type post_firewall_rule_endpoint_request: List[PostFirewallRuleEndpointRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_firewall_rules_endpoint_serialize(
            post_firewall_rule_endpoint_request=post_firewall_rule_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallRulesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def put_firewall_rules_endpoint_with_http_info(
        self,
        post_firewall_rule_endpoint_request: Optional[List[PostFirewallRuleEndpointRequest]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallRulesEndpoint200Response]:
        """put_firewall_rules_endpoint

        <h3>Description:</h3>Replaces all existing Firewall Rules.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallRule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-rules-put ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_rule_endpoint_request:
        :type post_firewall_rule_endpoint_request: List[PostFirewallRuleEndpointRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_firewall_rules_endpoint_serialize(
            post_firewall_rule_endpoint_request=post_firewall_rule_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallRulesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def put_firewall_rules_endpoint_without_preload_content(
        self,
        post_firewall_rule_endpoint_request: Optional[List[PostFirewallRuleEndpointRequest]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """put_firewall_rules_endpoint

        <h3>Description:</h3>Replaces all existing Firewall Rules.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallRule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-rules-put ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_rule_endpoint_request:
        :type post_firewall_rule_endpoint_request: List[PostFirewallRuleEndpointRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_firewall_rules_endpoint_serialize(
            post_firewall_rule_endpoint_request=post_firewall_rule_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallRulesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _put_firewall_rules_endpoint_serialize(
        self,
        post_firewall_rule_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'PostFirewallRuleEndpointRequest': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if post_firewall_rule_endpoint_request is not None:
            _body_params = post_firewall_rule_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/v2/firewall/rules',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def put_firewall_schedules_endpoint(
        self,
        post_firewall_schedule_endpoint_request: Optional[List[PostFirewallScheduleEndpointRequest]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallSchedulesEndpoint200Response:
        """put_firewall_schedules_endpoint

        <h3>Description:</h3>Replaces all existing Firewall Schedules.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallSchedule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedules-put ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param post_firewall_schedule_endpoint_request:
        :type post_firewall_schedule_endpoint_request: List[PostFirewallScheduleEndpointRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_firewall_schedules_endpoint_serialize(
            post_firewall_schedule_endpoint_request=post_firewall_schedule_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallSchedulesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def put_firewall_schedules_endpoint_with_http_info(
        self,
        post_firewall_schedule_endpoint_request: Optional[List[PostFirewallScheduleEndpointRequest]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallSchedulesEndpoint200Response]:
        """put_firewall_schedules_endpoint

        <h3>Description:</h3>Replaces all existing Firewall Schedules.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallSchedule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedules-put ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param post_firewall_schedule_endpoint_request:
        :type post_firewall_schedule_endpoint_request: List[PostFirewallScheduleEndpointRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_firewall_schedules_endpoint_serialize(
            post_firewall_schedule_endpoint_request=post_firewall_schedule_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallSchedulesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def put_firewall_schedules_endpoint_without_preload_content(
        self,
        post_firewall_schedule_endpoint_request: Optional[List[PostFirewallScheduleEndpointRequest]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """put_firewall_schedules_endpoint

        <h3>Description:</h3>Replaces all existing Firewall Schedules.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: FirewallSchedule<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-schedules-put ]<br>**Required packages**: [ None ]<br>**Applies immediately**: Yes<br>**Utilizes cache**: None

        :param post_firewall_schedule_endpoint_request:
        :type post_firewall_schedule_endpoint_request: List[PostFirewallScheduleEndpointRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_firewall_schedules_endpoint_serialize(
            post_firewall_schedule_endpoint_request=post_firewall_schedule_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallSchedulesEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _put_firewall_schedules_endpoint_serialize(
        self,
        post_firewall_schedule_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'PostFirewallScheduleEndpointRequest': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if post_firewall_schedule_endpoint_request is not None:
            _body_params = post_firewall_schedule_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/v2/firewall/schedules',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def put_firewall_traffic_shaper_limiters_endpoint(
        self,
        post_firewall_traffic_shaper_limiter_endpoint_request: Optional[List[PostFirewallTrafficShaperLimiterEndpointRequest]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallTrafficShaperLimitersEndpoint200Response:
        """put_firewall_traffic_shaper_limiters_endpoint

        <h3>Description:</h3>Replaces all existing Traffic Shaper Limiters.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: TrafficShaperLimiter<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiters-put ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_traffic_shaper_limiter_endpoint_request:
        :type post_firewall_traffic_shaper_limiter_endpoint_request: List[PostFirewallTrafficShaperLimiterEndpointRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_firewall_traffic_shaper_limiters_endpoint_serialize(
            post_firewall_traffic_shaper_limiter_endpoint_request=post_firewall_traffic_shaper_limiter_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimitersEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def put_firewall_traffic_shaper_limiters_endpoint_with_http_info(
        self,
        post_firewall_traffic_shaper_limiter_endpoint_request: Optional[List[PostFirewallTrafficShaperLimiterEndpointRequest]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallTrafficShaperLimitersEndpoint200Response]:
        """put_firewall_traffic_shaper_limiters_endpoint

        <h3>Description:</h3>Replaces all existing Traffic Shaper Limiters.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: TrafficShaperLimiter<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiters-put ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_traffic_shaper_limiter_endpoint_request:
        :type post_firewall_traffic_shaper_limiter_endpoint_request: List[PostFirewallTrafficShaperLimiterEndpointRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_firewall_traffic_shaper_limiters_endpoint_serialize(
            post_firewall_traffic_shaper_limiter_endpoint_request=post_firewall_traffic_shaper_limiter_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimitersEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def put_firewall_traffic_shaper_limiters_endpoint_without_preload_content(
        self,
        post_firewall_traffic_shaper_limiter_endpoint_request: Optional[List[PostFirewallTrafficShaperLimiterEndpointRequest]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """put_firewall_traffic_shaper_limiters_endpoint

        <h3>Description:</h3>Replaces all existing Traffic Shaper Limiters.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: TrafficShaperLimiter<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shaper-limiters-put ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_traffic_shaper_limiter_endpoint_request:
        :type post_firewall_traffic_shaper_limiter_endpoint_request: List[PostFirewallTrafficShaperLimiterEndpointRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_firewall_traffic_shaper_limiters_endpoint_serialize(
            post_firewall_traffic_shaper_limiter_endpoint_request=post_firewall_traffic_shaper_limiter_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShaperLimitersEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _put_firewall_traffic_shaper_limiters_endpoint_serialize(
        self,
        post_firewall_traffic_shaper_limiter_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'PostFirewallTrafficShaperLimiterEndpointRequest': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if post_firewall_traffic_shaper_limiter_endpoint_request is not None:
            _body_params = post_firewall_traffic_shaper_limiter_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/v2/firewall/traffic_shaper/limiters',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def put_firewall_traffic_shapers_endpoint(
        self,
        post_firewall_traffic_shaper_endpoint_request: Optional[List[PostFirewallTrafficShaperEndpointRequest]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFirewallTrafficShapersEndpoint200Response:
        """put_firewall_traffic_shapers_endpoint

        <h3>Description:</h3>Replaces all existing Traffic Shapers.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: TrafficShaper<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shapers-put ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_traffic_shaper_endpoint_request:
        :type post_firewall_traffic_shaper_endpoint_request: List[PostFirewallTrafficShaperEndpointRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_firewall_traffic_shapers_endpoint_serialize(
            post_firewall_traffic_shaper_endpoint_request=post_firewall_traffic_shaper_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShapersEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def put_firewall_traffic_shapers_endpoint_with_http_info(
        self,
        post_firewall_traffic_shaper_endpoint_request: Optional[List[PostFirewallTrafficShaperEndpointRequest]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFirewallTrafficShapersEndpoint200Response]:
        """put_firewall_traffic_shapers_endpoint

        <h3>Description:</h3>Replaces all existing Traffic Shapers.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: TrafficShaper<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shapers-put ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_traffic_shaper_endpoint_request:
        :type post_firewall_traffic_shaper_endpoint_request: List[PostFirewallTrafficShaperEndpointRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_firewall_traffic_shapers_endpoint_serialize(
            post_firewall_traffic_shaper_endpoint_request=post_firewall_traffic_shaper_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShapersEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def put_firewall_traffic_shapers_endpoint_without_preload_content(
        self,
        post_firewall_traffic_shaper_endpoint_request: Optional[List[PostFirewallTrafficShaperEndpointRequest]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """put_firewall_traffic_shapers_endpoint

        <h3>Description:</h3>Replaces all existing Traffic Shapers.<br><h3>Details:</h3>**Endpoint type**: Plural<br>**Associated model**: TrafficShaper<br>**Parent model**: None<br>**Requires authentication**: Yes<br>**Supported authentication modes:** [ BasicAuth, JWTAuth, KeyAuth ]<br>**Allowed privileges**: [ page-all, api-v2-firewall-traffic-shapers-put ]<br>**Required packages**: [ None ]<br>**Applies immediately**: No<br>**Utilizes cache**: None

        :param post_firewall_traffic_shaper_endpoint_request:
        :type post_firewall_traffic_shaper_endpoint_request: List[PostFirewallTrafficShaperEndpointRequest]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._put_firewall_traffic_shapers_endpoint_serialize(
            post_firewall_traffic_shaper_endpoint_request=post_firewall_traffic_shaper_endpoint_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '401': "PostAuthJWTEndpoint401Response",
            '409': "PostAuthJWTEndpoint409Response",
            '424': "PostAuthJWTEndpoint424Response",
            '403': "PostAuthJWTEndpoint403Response",
            '200': "GetFirewallTrafficShapersEndpoint200Response",
            '415': "PostAuthJWTEndpoint415Response",
            '405': "PostAuthJWTEndpoint405Response",
            '406': "PostAuthJWTEndpoint406Response",
            '404': "PostAuthJWTEndpoint404Response",
            '500': "PostAuthJWTEndpoint500Response",
            '503': "PostAuthJWTEndpoint503Response",
            '422': "PostAuthJWTEndpoint422Response",
            '400': "PostAuthJWTEndpoint400Response",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _put_firewall_traffic_shapers_endpoint_serialize(
        self,
        post_firewall_traffic_shaper_endpoint_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'PostFirewallTrafficShaperEndpointRequest': '',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if post_firewall_traffic_shaper_endpoint_request is not None:
            _body_params = post_firewall_traffic_shaper_endpoint_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'KeyAuth', 
            'BasicAuth', 
            'JWTAuth'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/v2/firewall/traffic_shapers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


