# coding: utf-8

"""
    pfSense REST API Documentation

    ### Getting Started<br>- [Authentication and Authorization](https://pfrest.org/AUTHENTICATION_AND_AUTHORIZATION/)<br>- [Working with Object IDs](https://pfrest.org/WORKING_WITH_OBJECT_IDS/)<br>- [Queries, Filters, and Sorting](https://pfrest.org/QUERIES_FILTERS_AND_SORTING/)<br>- [Common Control Parameters](https://pfrest.org/COMMON_CONTROL_PARAMETERS/)<br>- [Working with HATEOAS](https://pfrest.org/WORKING_WITH_HATEOAS/)<br>

    The version of the OpenAPI document: v2.4.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from pfsense_api_client.models.i_psec_phase2_encryption_algorithm_option_inner import IPsecPhase2EncryptionAlgorithmOptionInner
from typing import Optional, Set
from typing_extensions import Self

class PatchVPNIPsecPhase2EndpointRequest(BaseModel):
    """
    PatchVPNIPsecPhase2EndpointRequest
    """ # noqa: E501
    uniqid: Optional[StrictStr] = Field(default='67ed081abfaf0', description="A unique ID used to identify this IPsec phase2 entry internally. This value is automatically set by the system and cannot be changed.<br>")
    reqid: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=1, description="A unique ID used to identify this IPsec phase2 entry internally. This value is automatically set by the system and cannot be changed.<br>")
    ikeid: Optional[StrictInt] = Field(default=None, description="The `ikeid` of the parent IPsec phase 1 entry this IPsec phase 2 entry belongs to.<br>")
    descr: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="A description for this IPsec phase 2 entry.<br>")
    disabled: Optional[StrictBool] = Field(default=None, description="Disables this IPsec phase 2 entry.<br>")
    mode: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The IPsec phase 2 mode this entry will use.<br>")
    localid_type: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The local ID type to use for this phase 2 entry. Valid value options are: an existing interface, `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be equal to `'transport'`<br>")
    localid_address: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The local network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `localid_type` must be one of [ address, network ]<br>")
    localid_netbits: Optional[Annotated[int, Field(le=128, strict=True, ge=0)]] = Field(default=None, description="The subnet bits of the `localid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `localid_type` must be equal to `'network'`<br>")
    natlocalid_type: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The NAT/BINAT translation type for this IPsec phase 2 entry. Leave as `null` if NAT/BINAT is not needed. Valid value options are: an existing interface, `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be one of [ transport, vti ]<br>")
    natlocalid_address: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The NAT/BINAT local network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `natlocalid_type` must be one of [ address, network ]<br>")
    natlocalid_netbits: Optional[Annotated[int, Field(le=128, strict=True, ge=0)]] = Field(default=None, description="The subnet bits of the `natlocalid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `natlocalid_type` must be equal to `'network'`<br>")
    remoteid_type: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The remote ID type to use for this phase 2 entry. Valid value options are: `address`, `network`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br><br>This field is only available when the following conditions are met:<br>- `mode` must not be equal to `'transport'`<br>")
    remoteid_address: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The remote network IP component of this IPsec security association.<br><br>This field is only available when the following conditions are met:<br>- `remoteid_type` must be one of [ address, network ]<br>")
    remoteid_netbits: Optional[Annotated[int, Field(le=128, strict=True, ge=0)]] = Field(default=None, description="The subnet bits of the `remoteid_address` network.<br><br>This field is only available when the following conditions are met:<br>- `remoteid_type` must be equal to `'network'`<br>")
    protocol: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='esp', description="the IPsec phase 2 proposal protocol for this entry. Encapsulating Security Payload (`esp`) performs encryption and authentication, Authentication Header (`ah`) is authentication only.<br>")
    encryption_algorithm_option: Optional[Annotated[List[IPsecPhase2EncryptionAlgorithmOptionInner], Field(min_length=1, max_length=65535)]] = Field(default=None, description="The encryption algorithms to be used by this phase 2 entry.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be equal to `'esp'`<br>")
    hash_algorithm_option: Optional[Annotated[List[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]], Field(min_length=1, max_length=128)]] = Field(default=None, description="The hashing algorithms used by this IPsec phase 2 entry. Note: Hash is ignored with GCM algorithms. SHA1 provides weak security and should be avoided.<br>")
    pfsgroup: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=14, description="The PFS key group this IPsec phase 2 entry should use. Note: Groups 1, 2, 5, 22, 23, and 24 provide weak security and should be avoided.<br>")
    rekey_time: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=3240, description="The amount of time (in seconds) before an IKE SA establishes new keys.<br>")
    rand_time: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=360, description="A random value up to this amount will be subtracted from the `rekey_time` and `reauth_time` to avoid simultaneous renegotiation.<br>")
    lifetime: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=3600, description="The hard IKE SA lifetime (in seconds) after which the IKE SA will be expired.<br>")
    pinghost: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The IP address to send an ICMP echo request to inside the tunnel. Can trigger initiation of a tunnel mode P2, but does not trigger initiation of a VTI mode P2.<br>")
    keepalive: Optional[StrictBool] = Field(default=None, description="Enables or disables checking this P2 and initiating if disconnected; does not send traffic inside the tunnel. This check ignores the P1 option 'Child SA Start Action' and works for both VTI and tunnel mode P2s. For IKEv2 without split connections, this only needs to be enabled on one P2.<br>")
    id: StrictInt = Field(description="The ID of the object or resource to interact with.")
    __properties: ClassVar[List[str]] = ["uniqid", "reqid", "ikeid", "descr", "disabled", "mode", "localid_type", "localid_address", "localid_netbits", "natlocalid_type", "natlocalid_address", "natlocalid_netbits", "remoteid_type", "remoteid_address", "remoteid_netbits", "protocol", "encryption_algorithm_option", "hash_algorithm_option", "pfsgroup", "rekey_time", "rand_time", "lifetime", "pinghost", "keepalive", "id"]

    @field_validator('mode')
    def mode_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['tunnel', 'tunnel6', 'transport', 'vti']):
            raise ValueError("must be one of enum values ('tunnel', 'tunnel6', 'transport', 'vti')")
        return value

    @field_validator('protocol')
    def protocol_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['esp', 'ah']):
            raise ValueError("must be one of enum values ('esp', 'ah')")
        return value

    @field_validator('hash_algorithm_option')
    def hash_algorithm_option_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['hmac_sha1', 'hmac_sha256', 'hmac_sha384', 'hmac_sha512', 'aesxcbc']):
                raise ValueError("each list item must be one of ('hmac_sha1', 'hmac_sha256', 'hmac_sha384', 'hmac_sha512', 'aesxcbc')")
        return value

    @field_validator('pfsgroup')
    def pfsgroup_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set([0, 1, 2, 5, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32]):
            raise ValueError("must be one of enum values (0, 1, 2, 5, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32)")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PatchVPNIPsecPhase2EndpointRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "uniqid",
            "reqid",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in encryption_algorithm_option (list)
        _items = []
        if self.encryption_algorithm_option:
            for _item_encryption_algorithm_option in self.encryption_algorithm_option:
                if _item_encryption_algorithm_option:
                    _items.append(_item_encryption_algorithm_option.to_dict())
            _dict['encryption_algorithm_option'] = _items
        # set to None if uniqid (nullable) is None
        # and model_fields_set contains the field
        if self.uniqid is None and "uniqid" in self.model_fields_set:
            _dict['uniqid'] = None

        # set to None if reqid (nullable) is None
        # and model_fields_set contains the field
        if self.reqid is None and "reqid" in self.model_fields_set:
            _dict['reqid'] = None

        # set to None if natlocalid_type (nullable) is None
        # and model_fields_set contains the field
        if self.natlocalid_type is None and "natlocalid_type" in self.model_fields_set:
            _dict['natlocalid_type'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PatchVPNIPsecPhase2EndpointRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "uniqid": obj.get("uniqid") if obj.get("uniqid") is not None else '67ed081abfaf0',
            "reqid": obj.get("reqid") if obj.get("reqid") is not None else 1,
            "ikeid": obj.get("ikeid"),
            "descr": obj.get("descr"),
            "disabled": obj.get("disabled"),
            "mode": obj.get("mode"),
            "localid_type": obj.get("localid_type"),
            "localid_address": obj.get("localid_address"),
            "localid_netbits": obj.get("localid_netbits"),
            "natlocalid_type": obj.get("natlocalid_type"),
            "natlocalid_address": obj.get("natlocalid_address"),
            "natlocalid_netbits": obj.get("natlocalid_netbits"),
            "remoteid_type": obj.get("remoteid_type"),
            "remoteid_address": obj.get("remoteid_address"),
            "remoteid_netbits": obj.get("remoteid_netbits"),
            "protocol": obj.get("protocol") if obj.get("protocol") is not None else 'esp',
            "encryption_algorithm_option": [IPsecPhase2EncryptionAlgorithmOptionInner.from_dict(_item) for _item in obj["encryption_algorithm_option"]] if obj.get("encryption_algorithm_option") is not None else None,
            "hash_algorithm_option": obj.get("hash_algorithm_option"),
            "pfsgroup": obj.get("pfsgroup") if obj.get("pfsgroup") is not None else 14,
            "rekey_time": obj.get("rekey_time") if obj.get("rekey_time") is not None else 3240,
            "rand_time": obj.get("rand_time") if obj.get("rand_time") is not None else 360,
            "lifetime": obj.get("lifetime") if obj.get("lifetime") is not None else 3600,
            "pinghost": obj.get("pinghost"),
            "keepalive": obj.get("keepalive"),
            "id": obj.get("id")
        })
        return _obj


