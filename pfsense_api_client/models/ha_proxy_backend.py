# coding: utf-8

"""
    pfSense REST API Documentation

    ### Getting Started<br>- [Authentication and Authorization](https://pfrest.org/AUTHENTICATION_AND_AUTHORIZATION/)<br>- [Working with Object IDs](https://pfrest.org/WORKING_WITH_OBJECT_IDS/)<br>- [Queries, Filters, and Sorting](https://pfrest.org/QUERIES_FILTERS_AND_SORTING/)<br>- [Common Control Parameters](https://pfrest.org/COMMON_CONTROL_PARAMETERS/)<br>- [Working with HATEOAS](https://pfrest.org/WORKING_WITH_HATEOAS/)<br>

    The version of the OpenAPI document: v2.4.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from pfsense_api_client.models.ha_proxy_backend_acls_inner import HAProxyBackendAclsInner
from pfsense_api_client.models.ha_proxy_backend_actions_inner import HAProxyBackendActionsInner
from pfsense_api_client.models.ha_proxy_backend_errorfiles_inner import HAProxyBackendErrorfilesInner
from pfsense_api_client.models.ha_proxy_backend_servers_inner import HAProxyBackendServersInner
from typing import Optional, Set
from typing_extensions import Self

class HAProxyBackend(BaseModel):
    """
    HAProxyBackend
    """ # noqa: E501
    name: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The unique name for this backend.<br>")
    servers: Optional[Annotated[List[HAProxyBackendServersInner], Field(min_length=0, max_length=65535)]] = Field(default=None, description="The pool of servers this backend will use.<br>")
    balance: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The load balancing option to use for servers assigned to this backend.<br>")
    balance_urilen: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=None, description="The number of URI characters the algorithm should consider when hashing.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>")
    balance_uridepth: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=None, description="The maximum directory depth to be used to compute the hash. One level is counted for each slash in the request.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>")
    balance_uriwhole: Optional[StrictBool] = Field(default=None, description="Enables or disables allowing the use of whole URIs, including URL parameters.<br><br>This field is only available when the following conditions are met:<br>- `balance` must be equal to `'uri'`<br>")
    acls: Optional[Annotated[List[HAProxyBackendAclsInner], Field(min_length=0, max_length=65535)]] = Field(default=None, description="The ACLs to apply to this backend.<br>")
    actions: Optional[Annotated[List[HAProxyBackendActionsInner], Field(min_length=0, max_length=65535)]] = Field(default=None, description="The actions to apply to this backend.<br>")
    connection_timeout: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=30000, description="The amount of time (in milliseconds) to wait before giving up on connections.<br>")
    server_timeout: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=30000, description="The amount of time (in milliseconds) to wait for data transferred to or from the server.<br>")
    retries: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=None, description="The number of retry attempts to allow after a connection failure to the server.<br>")
    check_type: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='none', description="The health check method to use when checking the health of backend servers.<br>")
    checkinter: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=None, description="The interval (in milliseconds) in which health checks will be performed.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must not be equal to `'none'`<br>")
    log_health_checks: Optional[StrictBool] = Field(default=None, description="Enables or disables logging changes to the health check status<br><br>This field is only available when the following conditions are met:<br>- `check_type` must not be equal to `'none'`<br>")
    httpcheck_method: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='OPTIONS', description="The HTTP method to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>")
    monitor_uri: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='/', description="The URL to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>")
    monitor_httpversion: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='HTTP/1.0', description="The HTTP version to use for HTTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be equal to `'HTTP'`<br>")
    monitor_username: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The username to use for MySQL or PostgreSQL health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be one of [ MySQL, PostgreSQL ]<br>")
    monitor_domain: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The domain to use for SMTP or ESMTP health checks.<br><br>This field is only available when the following conditions are met:<br>- `check_type` must be one of [ SMTP, ESMTP ]<br>")
    agent_checks: Optional[StrictBool] = Field(default=None, description="Enables or disables using a TCP connection to read an ASCII string of the form.<br>")
    agent_port: Optional[StrictStr] = Field(default=None, description=" Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `agent_checks` must be equal to `true`<br>")
    agent_inter: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=2000, description="The interval (in milliseconds) between agent checks.<br><br>This field is only available when the following conditions are met:<br>- `agent_checks` must be equal to `true`<br>")
    persist_cookie_enabled: Optional[StrictBool] = Field(default=None, description="Enables or disables cookie based persistence.<br>")
    persist_cookie_name: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The string name to track in Set-Cookie and Cookie HTTP headers.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>")
    persist_cookie_mode: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='passive', description="The mode HAProxy uses to insert/prefix/replace or examine cookie and set-cookie headers.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>")
    persist_cookie_cachable: Optional[StrictBool] = Field(default=None, description="Enables or disables allowing shared caches to cache the server response.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>")
    persist_cookie_postonly: Optional[StrictBool] = Field(default=None, description="Enables or disables only inserting cookies on POST requests.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>")
    persist_cookie_httponly: Optional[StrictBool] = Field(default=None, description="Enables or disables preventing the use of cookies with non-HTTP components.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>")
    persist_cookie_secure: Optional[StrictBool] = Field(default=None, description="Enables or disables prevention of cookie usage over non-secure channels.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>")
    haproxy_cookie_maxidle: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=None, description="The max-idle time to allow. This option only applies to insert mode cookies.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>")
    haproxy_cookie_maxlife: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=None, description="The max-life time to allow. This option only applies to insert mode cookies.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>")
    haproxy_cookie_domains: Optional[Annotated[List[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]], Field(min_length=0, max_length=128)]] = Field(default=None, description="The domains to set the cookies for.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>")
    haproxy_cookie_dynamic_cookie_key: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The dynamic cookie secret key. This is will be used to generate dynamic cookies for this backend.<br><br>This field is only available when the following conditions are met:<br>- `persist_cookie_enabled` must be equal to `true`<br>")
    persist_sticky_type: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='none', description="The sticky table mode to use for this backend. These options are used to make sure subsequent requests from a single client go to the same backend.<br>")
    persist_stick_expire: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The maximum duration of an entry in the stick-table since it was last created, refreshed or matched.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must not be equal to `'none'`<br>")
    persist_stick_tablesize: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The maximum number of entries allowed in the table. This value directly impacts memory usage.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must not be equal to `'none'`<br>")
    persist_stick_cookiename: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The cookie name to use for stick table.<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must be one of [ stick_cookie_value, stick_rdp_cookie ]<br>")
    persist_stick_length: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=None, description="The maximum number of characters allowed in a string type stick table<br><br>This field is only available when the following conditions are met:<br>- `persist_sticky_type` must be one of [ stick_cookie_value, stick_rdp_cookie ]<br>")
    email_level: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The maximum log level to send emails for. Leave empty to disable sending email alerts. If left empty, the value set in the global settings will be used.<br>")
    email_to: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The email address to send emails to. If left empty, the value set in the global settings will be used.<br>")
    stats_enabled: Optional[StrictBool] = Field(default=None, description="Enables or disables the HAProxy statistics page for this backend.<br>")
    stats_uri: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The statistics URL for this backend.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>")
    stats_scope: Optional[Annotated[List[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]], Field(min_length=0, max_length=128)]] = Field(default=None, description="The frontends and backends stats to be shown, leave empty to show all.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>")
    stats_realm: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The realm that is shown when authentication is requested by HAProxy.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>")
    stats_username: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The stats page username<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>")
    stats_password: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The stats page password.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>")
    stats_admin: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The admin to make use of the options disable/enable/softstop/softstart/killsessions from the stats page.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>")
    stats_node: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The short name displayed in stats and helps differentiate which server in the cluster is actually serving clients.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>")
    stats_desc: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The verbose description for this node.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>")
    stats_refresh: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=10, description="The interval (in seconds) in which the stats page is refreshed.<br><br>This field is only available when the following conditions are met:<br>- `stats_enabled` must be equal to `true`<br>")
    strict_transport_security: Optional[Annotated[int, Field(le=1000000000, strict=True, ge=1)]] = Field(default=None, description="The HSTS validity period for this backend. Leave empty to disable HSTS.<br>")
    errorfiles: Optional[Annotated[List[HAProxyBackendErrorfilesInner], Field(min_length=0, max_length=65535)]] = Field(default=None, description="The HAProxy error file mappings to use for this backend.<br>")
    cookie_attribute_secure: Optional[StrictBool] = Field(default=None, description="Enables or disables assigning the secure attributes on cookies for this backend.<br>")
    advanced: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The per server pass thru to apply to each server line.<br>")
    advanced_backend: Optional[StrictStr] = Field(default=None, description="The backend pass thru to apply to the backend section.<br>")
    transparent_clientip: Optional[StrictBool] = Field(default=None, description="Enables or disables using the client-IP to connect to backend servers.<br>")
    transparent_interface: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The interface that will connect to the backend server.<br><br>This field is only available when the following conditions are met:<br>- `transparent_clientip` must be equal to `true`<br>")
    __properties: ClassVar[List[str]] = ["name", "servers", "balance", "balance_urilen", "balance_uridepth", "balance_uriwhole", "acls", "actions", "connection_timeout", "server_timeout", "retries", "check_type", "checkinter", "log_health_checks", "httpcheck_method", "monitor_uri", "monitor_httpversion", "monitor_username", "monitor_domain", "agent_checks", "agent_port", "agent_inter", "persist_cookie_enabled", "persist_cookie_name", "persist_cookie_mode", "persist_cookie_cachable", "persist_cookie_postonly", "persist_cookie_httponly", "persist_cookie_secure", "haproxy_cookie_maxidle", "haproxy_cookie_maxlife", "haproxy_cookie_domains", "haproxy_cookie_dynamic_cookie_key", "persist_sticky_type", "persist_stick_expire", "persist_stick_tablesize", "persist_stick_cookiename", "persist_stick_length", "email_level", "email_to", "stats_enabled", "stats_uri", "stats_scope", "stats_realm", "stats_username", "stats_password", "stats_admin", "stats_node", "stats_desc", "stats_refresh", "strict_transport_security", "errorfiles", "cookie_attribute_secure", "advanced", "advanced_backend", "transparent_clientip", "transparent_interface"]

    @field_validator('balance')
    def balance_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['', 'roundrobin', 'static-rr', 'leastconn', 'source', 'uri']):
            raise ValueError("must be one of enum values ('', 'roundrobin', 'static-rr', 'leastconn', 'source', 'uri')")
        return value

    @field_validator('check_type')
    def check_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['none', 'Basic', 'HTTP', 'LDAP', 'MySQL', 'PostgreSQL', 'Redis', 'SMTP', 'ESMTP', 'SSL']):
            raise ValueError("must be one of enum values ('none', 'Basic', 'HTTP', 'LDAP', 'MySQL', 'PostgreSQL', 'Redis', 'SMTP', 'ESMTP', 'SSL')")
        return value

    @field_validator('httpcheck_method')
    def httpcheck_method_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['OPTIONS', 'HEAD', 'GET', 'POST', 'PUT', 'DELETE', 'TRACE']):
            raise ValueError("must be one of enum values ('OPTIONS', 'HEAD', 'GET', 'POST', 'PUT', 'DELETE', 'TRACE')")
        return value

    @field_validator('persist_cookie_mode')
    def persist_cookie_mode_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['passive', 'passive-silent', 'reset', 'set', 'set-silent', 'insert-only', 'insert-only-silent', 'session-prefix', 'passive-session-prefix']):
            raise ValueError("must be one of enum values ('passive', 'passive-silent', 'reset', 'set', 'set-silent', 'insert-only', 'insert-only-silent', 'session-prefix', 'passive-session-prefix')")
        return value

    @field_validator('persist_sticky_type')
    def persist_sticky_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['none', 'stick_sslsessionid', 'stick_sourceipv4', 'stick_sourceipv6', 'stick_cookie_value', 'stick_rdp_cookie']):
            raise ValueError("must be one of enum values ('none', 'stick_sslsessionid', 'stick_sourceipv4', 'stick_sourceipv6', 'stick_cookie_value', 'stick_rdp_cookie')")
        return value

    @field_validator('email_level')
    def email_level_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['', 'dontlog', 'emerg', 'alert', 'crit', 'err', 'warning', 'notice', 'info', 'debug']):
            raise ValueError("must be one of enum values ('', 'dontlog', 'emerg', 'alert', 'crit', 'err', 'warning', 'notice', 'info', 'debug')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of HAProxyBackend from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in servers (list)
        _items = []
        if self.servers:
            for _item_servers in self.servers:
                if _item_servers:
                    _items.append(_item_servers.to_dict())
            _dict['servers'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in acls (list)
        _items = []
        if self.acls:
            for _item_acls in self.acls:
                if _item_acls:
                    _items.append(_item_acls.to_dict())
            _dict['acls'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in actions (list)
        _items = []
        if self.actions:
            for _item_actions in self.actions:
                if _item_actions:
                    _items.append(_item_actions.to_dict())
            _dict['actions'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in errorfiles (list)
        _items = []
        if self.errorfiles:
            for _item_errorfiles in self.errorfiles:
                if _item_errorfiles:
                    _items.append(_item_errorfiles.to_dict())
            _dict['errorfiles'] = _items
        # set to None if balance_urilen (nullable) is None
        # and model_fields_set contains the field
        if self.balance_urilen is None and "balance_urilen" in self.model_fields_set:
            _dict['balance_urilen'] = None

        # set to None if balance_uridepth (nullable) is None
        # and model_fields_set contains the field
        if self.balance_uridepth is None and "balance_uridepth" in self.model_fields_set:
            _dict['balance_uridepth'] = None

        # set to None if connection_timeout (nullable) is None
        # and model_fields_set contains the field
        if self.connection_timeout is None and "connection_timeout" in self.model_fields_set:
            _dict['connection_timeout'] = None

        # set to None if server_timeout (nullable) is None
        # and model_fields_set contains the field
        if self.server_timeout is None and "server_timeout" in self.model_fields_set:
            _dict['server_timeout'] = None

        # set to None if retries (nullable) is None
        # and model_fields_set contains the field
        if self.retries is None and "retries" in self.model_fields_set:
            _dict['retries'] = None

        # set to None if checkinter (nullable) is None
        # and model_fields_set contains the field
        if self.checkinter is None and "checkinter" in self.model_fields_set:
            _dict['checkinter'] = None

        # set to None if agent_inter (nullable) is None
        # and model_fields_set contains the field
        if self.agent_inter is None and "agent_inter" in self.model_fields_set:
            _dict['agent_inter'] = None

        # set to None if haproxy_cookie_maxidle (nullable) is None
        # and model_fields_set contains the field
        if self.haproxy_cookie_maxidle is None and "haproxy_cookie_maxidle" in self.model_fields_set:
            _dict['haproxy_cookie_maxidle'] = None

        # set to None if haproxy_cookie_maxlife (nullable) is None
        # and model_fields_set contains the field
        if self.haproxy_cookie_maxlife is None and "haproxy_cookie_maxlife" in self.model_fields_set:
            _dict['haproxy_cookie_maxlife'] = None

        # set to None if persist_stick_length (nullable) is None
        # and model_fields_set contains the field
        if self.persist_stick_length is None and "persist_stick_length" in self.model_fields_set:
            _dict['persist_stick_length'] = None

        # set to None if strict_transport_security (nullable) is None
        # and model_fields_set contains the field
        if self.strict_transport_security is None and "strict_transport_security" in self.model_fields_set:
            _dict['strict_transport_security'] = None

        # set to None if transparent_interface (nullable) is None
        # and model_fields_set contains the field
        if self.transparent_interface is None and "transparent_interface" in self.model_fields_set:
            _dict['transparent_interface'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of HAProxyBackend from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "name": obj.get("name"),
            "servers": [HAProxyBackendServersInner.from_dict(_item) for _item in obj["servers"]] if obj.get("servers") is not None else None,
            "balance": obj.get("balance"),
            "balance_urilen": obj.get("balance_urilen"),
            "balance_uridepth": obj.get("balance_uridepth"),
            "balance_uriwhole": obj.get("balance_uriwhole"),
            "acls": [HAProxyBackendAclsInner.from_dict(_item) for _item in obj["acls"]] if obj.get("acls") is not None else None,
            "actions": [HAProxyBackendActionsInner.from_dict(_item) for _item in obj["actions"]] if obj.get("actions") is not None else None,
            "connection_timeout": obj.get("connection_timeout") if obj.get("connection_timeout") is not None else 30000,
            "server_timeout": obj.get("server_timeout") if obj.get("server_timeout") is not None else 30000,
            "retries": obj.get("retries"),
            "check_type": obj.get("check_type") if obj.get("check_type") is not None else 'none',
            "checkinter": obj.get("checkinter"),
            "log_health_checks": obj.get("log_health_checks"),
            "httpcheck_method": obj.get("httpcheck_method") if obj.get("httpcheck_method") is not None else 'OPTIONS',
            "monitor_uri": obj.get("monitor_uri") if obj.get("monitor_uri") is not None else '/',
            "monitor_httpversion": obj.get("monitor_httpversion") if obj.get("monitor_httpversion") is not None else 'HTTP/1.0',
            "monitor_username": obj.get("monitor_username"),
            "monitor_domain": obj.get("monitor_domain"),
            "agent_checks": obj.get("agent_checks"),
            "agent_port": obj.get("agent_port"),
            "agent_inter": obj.get("agent_inter") if obj.get("agent_inter") is not None else 2000,
            "persist_cookie_enabled": obj.get("persist_cookie_enabled"),
            "persist_cookie_name": obj.get("persist_cookie_name"),
            "persist_cookie_mode": obj.get("persist_cookie_mode") if obj.get("persist_cookie_mode") is not None else 'passive',
            "persist_cookie_cachable": obj.get("persist_cookie_cachable"),
            "persist_cookie_postonly": obj.get("persist_cookie_postonly"),
            "persist_cookie_httponly": obj.get("persist_cookie_httponly"),
            "persist_cookie_secure": obj.get("persist_cookie_secure"),
            "haproxy_cookie_maxidle": obj.get("haproxy_cookie_maxidle"),
            "haproxy_cookie_maxlife": obj.get("haproxy_cookie_maxlife"),
            "haproxy_cookie_domains": obj.get("haproxy_cookie_domains"),
            "haproxy_cookie_dynamic_cookie_key": obj.get("haproxy_cookie_dynamic_cookie_key"),
            "persist_sticky_type": obj.get("persist_sticky_type") if obj.get("persist_sticky_type") is not None else 'none',
            "persist_stick_expire": obj.get("persist_stick_expire"),
            "persist_stick_tablesize": obj.get("persist_stick_tablesize"),
            "persist_stick_cookiename": obj.get("persist_stick_cookiename"),
            "persist_stick_length": obj.get("persist_stick_length"),
            "email_level": obj.get("email_level"),
            "email_to": obj.get("email_to"),
            "stats_enabled": obj.get("stats_enabled"),
            "stats_uri": obj.get("stats_uri"),
            "stats_scope": obj.get("stats_scope"),
            "stats_realm": obj.get("stats_realm"),
            "stats_username": obj.get("stats_username"),
            "stats_password": obj.get("stats_password"),
            "stats_admin": obj.get("stats_admin"),
            "stats_node": obj.get("stats_node"),
            "stats_desc": obj.get("stats_desc"),
            "stats_refresh": obj.get("stats_refresh") if obj.get("stats_refresh") is not None else 10,
            "strict_transport_security": obj.get("strict_transport_security"),
            "errorfiles": [HAProxyBackendErrorfilesInner.from_dict(_item) for _item in obj["errorfiles"]] if obj.get("errorfiles") is not None else None,
            "cookie_attribute_secure": obj.get("cookie_attribute_secure"),
            "advanced": obj.get("advanced"),
            "advanced_backend": obj.get("advanced_backend"),
            "transparent_clientip": obj.get("transparent_clientip"),
            "transparent_interface": obj.get("transparent_interface")
        })
        return _obj


