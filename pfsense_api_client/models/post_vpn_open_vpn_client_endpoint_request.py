# coding: utf-8

"""
    pfSense REST API Documentation

    ### Getting Started<br>- [Authentication and Authorization](https://pfrest.org/AUTHENTICATION_AND_AUTHORIZATION/)<br>- [Working with Object IDs](https://pfrest.org/WORKING_WITH_OBJECT_IDS/)<br>- [Queries, Filters, and Sorting](https://pfrest.org/QUERIES_FILTERS_AND_SORTING/)<br>- [Common Control Parameters](https://pfrest.org/COMMON_CONTROL_PARAMETERS/)<br>- [Working with HATEOAS](https://pfrest.org/WORKING_WITH_HATEOAS/)<br>

    The version of the OpenAPI document: v2.4.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class PostVPNOpenVPNClientEndpointRequest(BaseModel):
    """
    PostVPNOpenVPNClientEndpointRequest
    """ # noqa: E501
    vpnid: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=None, description="The unique ID for this OpenVPN client. This value is assigned by the system and cannot be changed.<br>")
    vpnif: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The VPN interface name for this OpenVPN client. This value is assigned by the system and cannot be changed.<br>")
    description: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The description for this OpenVPN client.<br>")
    disable: Optional[StrictBool] = Field(default=None, description="Disables this OpenVPN client.<br>")
    mode: Annotated[str, Field(min_length=0, strict=True, max_length=1024)] = Field(description="The OpenVPN client mode.<br>")
    dev_mode: Annotated[str, Field(min_length=0, strict=True, max_length=1024)] = Field(description="The carrier mode for this OpenVPN client. `tun` mode carries IPv4 and IPv6 (layer 3) and is the most common and compatible mode across all platforms. `tap` mode is capable of carrying 802.3 (layer 2).<br>")
    protocol: Annotated[str, Field(min_length=0, strict=True, max_length=1024)] = Field(description="The protocol used by this OpenVPN client.<br>")
    interface: Annotated[str, Field(min_length=0, strict=True, max_length=1024)] = Field(description="The interface used by the firewall to originate this OpenVPN client connection.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must not be one of [ UDP, TCP ]<br>")
    server_addr: Annotated[str, Field(min_length=0, strict=True, max_length=1024)] = Field(description="The IP address or hostname of the OpenVPN server this client will connect to.<br>")
    server_port: StrictStr = Field(description="The port used by the server to receive client connections. Valid options are: a TCP/UDP port number<br>")
    local_port: Optional[StrictStr] = Field(default=None, description="The port binding used by OpenVPN for client connections. Valid options are: a TCP/UDP port number<br>")
    proxy_addr: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The address for an HTTP Proxy this client can use to connect to a remote server.<br>")
    proxy_port: Optional[StrictStr] = Field(default=None, description="The port used by the HTTP Proxy. Valid options are: a TCP/UDP port number<br>")
    proxy_authtype: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='none', description="The type of authentication used by the proxy server.<br>")
    proxy_user: Annotated[str, Field(min_length=0, strict=True, max_length=1024)] = Field(description="The username to use for authentication to the remote proxy.<br><br>This field is only available when the following conditions are met:<br>- `proxy_authtype` must not be equal to `'none'`<br>")
    proxy_passwd: Annotated[str, Field(min_length=0, strict=True, max_length=1024)] = Field(description="The username to use for authentication to the remote proxy.<br><br>This field is only available when the following conditions are met:<br>- `proxy_authtype` must not be equal to `'none'`<br>")
    auth_user: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The username used to authenticate with the OpenVPN server.<br>")
    auth_pass: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The password used to authenticate with the OpenVPN server.<br><br>This field is only available when the following conditions are met:<br>- `auth_user` must not be equal to `NULL`<br>")
    auth_retry_none: Optional[StrictBool] = Field(default=None, description="Disables retrying authentication if an authentication failed error is received from the server<br>")
    tls: Optional[StrictStr] = Field(default=None, description="The TLS key this OpenVPN client will use to sign control channel packets with an HMAC signature for authentication when establishing the tunnel.<br>")
    tls_type: Annotated[str, Field(min_length=0, strict=True, max_length=1024)] = Field(description="The TLS key usage type. In `auth` mode, the TLS key is used only as HMAC authentication for the control channel, protecting the peers from unauthorized connections. The `crypt` mode encrypts the control channel communication in addition to providing authentication, providing more privacy and traffic control channel obfuscation.<br><br>This field is only available when the following conditions are met:<br>- `tls` must not be equal to `NULL`<br>")
    tlsauth_keydir: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='default', description="The TLS key direction. This must be set to complementary values on the client and client. For example, if the client is set to 0, the client must be set to 1. Both may be set to omit the direction, in which case the TLS Key will be used bidirectionally.<br><br>This field is only available when the following conditions are met:<br>- `tls` must not be equal to `NULL`<br>")
    caref: StrictStr = Field(description="The `refid` of the CA object to assume as the peer CA.<br>")
    certref: Optional[StrictStr] = Field(default=None, description="The `refid` of the certificate object to assume as the OpenVPN client certificate.<br>")
    data_ciphers: Annotated[List[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]], Field(min_length=1, max_length=128)] = Field(description="The encryption algorithms/ciphers allowed by this OpenVPN client.<br>")
    data_ciphers_fallback: Annotated[str, Field(min_length=0, strict=True, max_length=1024)] = Field(description="The fallback encryption algorithm/cipher used for data channel packets when communicating with clients that do not support data encryption algorithm negotiation (e.g. Shared Key).<br>")
    digest: Annotated[str, Field(min_length=0, strict=True, max_length=1024)] = Field(description="The algorithm used to authenticate data channel packets, and control channel packets if a TLS Key is present.<br>")
    remote_cert_tls: Optional[StrictBool] = Field(default=True, description="Enables or disables requiring hosts to have a client certificate to connect.<br>")
    tunnel_network: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The IPv4 virtual network used for private communications between this client and client hosts.<br>")
    tunnel_networkv6: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The IPv6 virtual network used for private communications between this client and client hosts.<br>")
    remote_network: Optional[Annotated[List[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]], Field(min_length=0, max_length=128)]] = Field(default=None, description="IPv4 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>")
    remote_networkv6: Optional[Annotated[List[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]], Field(min_length=0, max_length=128)]] = Field(default=None, description="IPv6 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.<br>")
    use_shaper: Optional[Annotated[int, Field(le=100000000, strict=True, ge=100)]] = Field(default=None, description="Maximum outgoing bandwidth (in bytes per second) for this tunnel. Use `null` no limit.<br>")
    allow_compression: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='no', description="The compression mode allowed by this OpenVPN client. Compression can potentially increase throughput but may allow an attacker to extract secrets if they can control compressed plaintext traversing the VPN (e.g. HTTP)<br>")
    passtos: Optional[StrictBool] = Field(default=None, description="Enables or disables setting the TOS IP header value of tunnel packets to match the encapsulated packet value.<br>")
    route_no_pull: Optional[StrictBool] = Field(default=None, description="Enables or disables the servers ability to add routes to the client's routing table.<br>")
    route_no_exec: Optional[StrictBool] = Field(default=None, description="Enables or disables adding/removing routes automatically.<br>")
    dns_add: Optional[StrictBool] = Field(default=None, description="Enables or disables using the DNS server(s) provided by the OpenVPN server.<br>")
    topology: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='subnet', description="The method used to supply a virtual adapter IP address to clients when using TUN mode on IPv4.<br><br>This field is only available when the following conditions are met:<br>- `dev_mode` must be equal to `'tun'`<br>")
    inactive_seconds: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=300, description="The amount of time (in seconds) until a client connection is closed for inactivity.<br>")
    ping_method: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='keepalive', description="The method used to define ping configuration.<br>")
    keepalive_interval: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=10, description="The keepalive interval parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>")
    keepalive_timeout: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=60, description="The keepalive timeout parameter.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'keepalive'`<br>")
    ping_seconds: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=10, description="The number of seconds to accept no packets before sending a ping to the remote peer over the TCP/UDP control channel.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>")
    ping_action: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='ping_restart', description="The action to take after a ping to the remote peer times-out.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>")
    ping_action_seconds: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=60, description="The number of seconds that must elapse before the ping is considered a timeout and the configured `ping_action` is performed.<br><br>This field is only available when the following conditions are met:<br>- `ping_method` must be equal to `'ping'`<br>")
    custom_options: Optional[Annotated[List[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]], Field(min_length=0, max_length=128)]] = Field(default=None, description="Additional options to add to the OpenVPN client configuration.<br>")
    udp_fast_io: Optional[StrictBool] = Field(default=None, description="Enables or disables fast I/O operations with UDP writes to tun/tap (Experimental).<br>")
    exit_notify: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='none', description="The number of times this client will attempt to send an exit notifications.<br>")
    sndrcvbuf: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=None, description="The send and receive buffer size for OpenVPN. Set to null to use the system default.<br>")
    create_gw: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='both', description="The gateway type(s) that will be created when a virtual interface is assigned to this OpenVPN server<br>")
    verbosity_level: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=1, description="The OpenVPN logging verbosity level.<br>")
    __properties: ClassVar[List[str]] = ["vpnid", "vpnif", "description", "disable", "mode", "dev_mode", "protocol", "interface", "server_addr", "server_port", "local_port", "proxy_addr", "proxy_port", "proxy_authtype", "proxy_user", "proxy_passwd", "auth_user", "auth_pass", "auth_retry_none", "tls", "tls_type", "tlsauth_keydir", "caref", "certref", "data_ciphers", "data_ciphers_fallback", "digest", "remote_cert_tls", "tunnel_network", "tunnel_networkv6", "remote_network", "remote_networkv6", "use_shaper", "allow_compression", "passtos", "route_no_pull", "route_no_exec", "dns_add", "topology", "inactive_seconds", "ping_method", "keepalive_interval", "keepalive_timeout", "ping_seconds", "ping_action", "ping_action_seconds", "custom_options", "udp_fast_io", "exit_notify", "sndrcvbuf", "create_gw", "verbosity_level"]

    @field_validator('mode')
    def mode_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['p2p_tls']):
            raise ValueError("must be one of enum values ('p2p_tls')")
        return value

    @field_validator('dev_mode')
    def dev_mode_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['tun', 'tap']):
            raise ValueError("must be one of enum values ('tun', 'tap')")
        return value

    @field_validator('protocol')
    def protocol_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['UDP4', 'UDP6', 'UDP', 'TCP4', 'TCP6', 'TCP']):
            raise ValueError("must be one of enum values ('UDP4', 'UDP6', 'UDP', 'TCP4', 'TCP6', 'TCP')")
        return value

    @field_validator('proxy_authtype')
    def proxy_authtype_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['none', 'basic', 'ntlm']):
            raise ValueError("must be one of enum values ('none', 'basic', 'ntlm')")
        return value

    @field_validator('tls_type')
    def tls_type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['auth', 'crypt']):
            raise ValueError("must be one of enum values ('auth', 'crypt')")
        return value

    @field_validator('tlsauth_keydir')
    def tlsauth_keydir_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['default', '0', '1', '2']):
            raise ValueError("must be one of enum values ('default', '0', '1', '2')")
        return value

    @field_validator('allow_compression')
    def allow_compression_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['no', 'yes', 'asym']):
            raise ValueError("must be one of enum values ('no', 'yes', 'asym')")
        return value

    @field_validator('topology')
    def topology_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['subnet', 'net30']):
            raise ValueError("must be one of enum values ('subnet', 'net30')")
        return value

    @field_validator('ping_method')
    def ping_method_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['keepalive', 'ping']):
            raise ValueError("must be one of enum values ('keepalive', 'ping')")
        return value

    @field_validator('ping_action')
    def ping_action_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['ping_restart', 'ping_exit']):
            raise ValueError("must be one of enum values ('ping_restart', 'ping_exit')")
        return value

    @field_validator('exit_notify')
    def exit_notify_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['1', '2', '3', '4', '5', 'none']):
            raise ValueError("must be one of enum values ('1', '2', '3', '4', '5', 'none')")
        return value

    @field_validator('sndrcvbuf')
    def sndrcvbuf_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set([65536, 131072, 262144, 524288, 1048576, 2097152]):
            raise ValueError("must be one of enum values (65536, 131072, 262144, 524288, 1048576, 2097152)")
        return value

    @field_validator('create_gw')
    def create_gw_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['both', 'v4only', 'v6only']):
            raise ValueError("must be one of enum values ('both', 'v4only', 'v6only')")
        return value

    @field_validator('verbosity_level')
    def verbosity_level_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]):
            raise ValueError("must be one of enum values (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PostVPNOpenVPNClientEndpointRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "vpnid",
            "vpnif",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if vpnid (nullable) is None
        # and model_fields_set contains the field
        if self.vpnid is None and "vpnid" in self.model_fields_set:
            _dict['vpnid'] = None

        # set to None if vpnif (nullable) is None
        # and model_fields_set contains the field
        if self.vpnif is None and "vpnif" in self.model_fields_set:
            _dict['vpnif'] = None

        # set to None if local_port (nullable) is None
        # and model_fields_set contains the field
        if self.local_port is None and "local_port" in self.model_fields_set:
            _dict['local_port'] = None

        # set to None if proxy_addr (nullable) is None
        # and model_fields_set contains the field
        if self.proxy_addr is None and "proxy_addr" in self.model_fields_set:
            _dict['proxy_addr'] = None

        # set to None if proxy_port (nullable) is None
        # and model_fields_set contains the field
        if self.proxy_port is None and "proxy_port" in self.model_fields_set:
            _dict['proxy_port'] = None

        # set to None if auth_user (nullable) is None
        # and model_fields_set contains the field
        if self.auth_user is None and "auth_user" in self.model_fields_set:
            _dict['auth_user'] = None

        # set to None if auth_pass (nullable) is None
        # and model_fields_set contains the field
        if self.auth_pass is None and "auth_pass" in self.model_fields_set:
            _dict['auth_pass'] = None

        # set to None if tls (nullable) is None
        # and model_fields_set contains the field
        if self.tls is None and "tls" in self.model_fields_set:
            _dict['tls'] = None

        # set to None if certref (nullable) is None
        # and model_fields_set contains the field
        if self.certref is None and "certref" in self.model_fields_set:
            _dict['certref'] = None

        # set to None if use_shaper (nullable) is None
        # and model_fields_set contains the field
        if self.use_shaper is None and "use_shaper" in self.model_fields_set:
            _dict['use_shaper'] = None

        # set to None if sndrcvbuf (nullable) is None
        # and model_fields_set contains the field
        if self.sndrcvbuf is None and "sndrcvbuf" in self.model_fields_set:
            _dict['sndrcvbuf'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PostVPNOpenVPNClientEndpointRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "vpnid": obj.get("vpnid"),
            "vpnif": obj.get("vpnif"),
            "description": obj.get("description"),
            "disable": obj.get("disable"),
            "mode": obj.get("mode"),
            "dev_mode": obj.get("dev_mode"),
            "protocol": obj.get("protocol"),
            "interface": obj.get("interface"),
            "server_addr": obj.get("server_addr"),
            "server_port": obj.get("server_port"),
            "local_port": obj.get("local_port"),
            "proxy_addr": obj.get("proxy_addr"),
            "proxy_port": obj.get("proxy_port"),
            "proxy_authtype": obj.get("proxy_authtype") if obj.get("proxy_authtype") is not None else 'none',
            "proxy_user": obj.get("proxy_user"),
            "proxy_passwd": obj.get("proxy_passwd"),
            "auth_user": obj.get("auth_user"),
            "auth_pass": obj.get("auth_pass"),
            "auth_retry_none": obj.get("auth_retry_none"),
            "tls": obj.get("tls"),
            "tls_type": obj.get("tls_type"),
            "tlsauth_keydir": obj.get("tlsauth_keydir") if obj.get("tlsauth_keydir") is not None else 'default',
            "caref": obj.get("caref"),
            "certref": obj.get("certref"),
            "data_ciphers": obj.get("data_ciphers"),
            "data_ciphers_fallback": obj.get("data_ciphers_fallback"),
            "digest": obj.get("digest"),
            "remote_cert_tls": obj.get("remote_cert_tls") if obj.get("remote_cert_tls") is not None else True,
            "tunnel_network": obj.get("tunnel_network"),
            "tunnel_networkv6": obj.get("tunnel_networkv6"),
            "remote_network": obj.get("remote_network"),
            "remote_networkv6": obj.get("remote_networkv6"),
            "use_shaper": obj.get("use_shaper"),
            "allow_compression": obj.get("allow_compression") if obj.get("allow_compression") is not None else 'no',
            "passtos": obj.get("passtos"),
            "route_no_pull": obj.get("route_no_pull"),
            "route_no_exec": obj.get("route_no_exec"),
            "dns_add": obj.get("dns_add"),
            "topology": obj.get("topology") if obj.get("topology") is not None else 'subnet',
            "inactive_seconds": obj.get("inactive_seconds") if obj.get("inactive_seconds") is not None else 300,
            "ping_method": obj.get("ping_method") if obj.get("ping_method") is not None else 'keepalive',
            "keepalive_interval": obj.get("keepalive_interval") if obj.get("keepalive_interval") is not None else 10,
            "keepalive_timeout": obj.get("keepalive_timeout") if obj.get("keepalive_timeout") is not None else 60,
            "ping_seconds": obj.get("ping_seconds") if obj.get("ping_seconds") is not None else 10,
            "ping_action": obj.get("ping_action") if obj.get("ping_action") is not None else 'ping_restart',
            "ping_action_seconds": obj.get("ping_action_seconds") if obj.get("ping_action_seconds") is not None else 60,
            "custom_options": obj.get("custom_options"),
            "udp_fast_io": obj.get("udp_fast_io"),
            "exit_notify": obj.get("exit_notify") if obj.get("exit_notify") is not None else 'none',
            "sndrcvbuf": obj.get("sndrcvbuf"),
            "create_gw": obj.get("create_gw") if obj.get("create_gw") is not None else 'both',
            "verbosity_level": obj.get("verbosity_level") if obj.get("verbosity_level") is not None else 1
        })
        return _obj


