# coding: utf-8

"""
    pfSense REST API Documentation

    ### Getting Started<br>- [Authentication and Authorization](https://pfrest.org/AUTHENTICATION_AND_AUTHORIZATION/)<br>- [Working with Object IDs](https://pfrest.org/WORKING_WITH_OBJECT_IDS/)<br>- [Queries, Filters, and Sorting](https://pfrest.org/QUERIES_FILTERS_AND_SORTING/)<br>- [Common Control Parameters](https://pfrest.org/COMMON_CONTROL_PARAMETERS/)<br>- [Working with HATEOAS](https://pfrest.org/WORKING_WITH_HATEOAS/)<br>

    The version of the OpenAPI document: v2.4.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from pfsense_api_client.models.post_services_ha_proxy_settings_dns_resolver_endpoint_request import PostServicesHAProxySettingsDNSResolverEndpointRequest
from pfsense_api_client.models.post_services_ha_proxy_settings_email_mailer_endpoint_request import PostServicesHAProxySettingsEmailMailerEndpointRequest
from typing import Optional, Set
from typing_extensions import Self

class PatchServicesHAProxySettingsEndpointRequest(BaseModel):
    """
    PatchServicesHAProxySettingsEndpointRequest
    """ # noqa: E501
    enable: Optional[StrictBool] = Field(default=None, description="Enables or disable HAProxy on the system.<br>")
    maxconn: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=None, description="The maximum per-process number of concurrent connections<br>")
    nbthread: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=1, description="The number of threads to start per process. This setting is experimental.<br>")
    terminate_on_reload: Optional[StrictBool] = Field(default=None, description="Enables or disables an immediate stop of old process on reload. (closes existing connections)<br>")
    hard_stop_after: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='15m', description="The maximum time allowed to perform a clean soft-stop. This can be represented as different time values such as 30s, 15m, 3h or 1d.<br>")
    carpdev: Optional[StrictStr] = Field(default=None, description="The CARP interface IP to monitor. HAProxy will only run on the firewall whose interface is MASTER.<br>")
    localstatsport: Optional[StrictStr] = Field(default=None, description="The internal port to be used for the stats tab. Set to null to disable local stats. Valid options are: a TCP/UDP port number<br>")
    localstats_refreshtime: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=None, description="The internal (in seconds) in which local stats will be refreshed.<br>")
    localstats_sticktable_refreshtime: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=None, description="The internal (in seconds) in which the sticktable stats will be refreshed.<br>")
    remotesyslog: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The IP address or hostname of the remote syslog server to send logs to. Use `/var/run/log` to to log to the local pfSense system log.<br>")
    logfacility: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='syslog', description="The logging facility to log to.<br>")
    loglevel: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='warning', description="The log level to begin logging events. Only events of this level or higher will be logged.<br>")
    log_send_hostname: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The hostname field to include in the syslog header. Leave empty to use the system hostname.<br>")
    dns_resolvers: Optional[Annotated[List[PostServicesHAProxySettingsDNSResolverEndpointRequest], Field(min_length=0, max_length=65535)]] = Field(default=None, description="The DNS resolvers HAProxy will use for DNS queries.<br>")
    resolver_retries: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=3, description="The number of queries to send to resolve a server name before giving up.<br>")
    resolver_timeoutretry: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='1s', description="The time between two DNS queries, when no response have been received.<br>")
    resolver_holdvalid: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='1s', description="The interval between two successive name resolution when the last answer was valid.<br>")
    email_mailers: Optional[Annotated[List[PostServicesHAProxySettingsEmailMailerEndpointRequest], Field(min_length=0, max_length=65535)]] = Field(default=None, description="The email servers HAProxy will use to send SMTP alerts.<br>")
    email_level: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The maximum log level to send emails for. Leave empty to disable sending email alerts.<br>")
    email_myhostname: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The hostname to use as the origin of the email.<br>")
    email_from: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The email address to be used as the sender of the emails.<br>")
    email_to: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The email address to send emails to.<br>")
    sslcompatibilitymode: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='auto', description="The SSL/TLS compatibility mode which determines the cipher suites and TLS versions supported.<br>")
    ssldefaultdhparam: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=1024)]] = Field(default=1024, description="The maximum size of the Diffie-Hellman parameters used for generating the ephemeral/temporary Diffie-Hellman key in case of DHE key exchange<br>")
    advanced: Optional[StrictStr] = Field(default=None, description="Additional HAProxy options to include in the global settings area.<br>")
    enablesync: Optional[StrictBool] = Field(default=None, description="Enables or disables including HAProxy configurations in HA sync if configured.<br>")
    __properties: ClassVar[List[str]] = ["enable", "maxconn", "nbthread", "terminate_on_reload", "hard_stop_after", "carpdev", "localstatsport", "localstats_refreshtime", "localstats_sticktable_refreshtime", "remotesyslog", "logfacility", "loglevel", "log_send_hostname", "dns_resolvers", "resolver_retries", "resolver_timeoutretry", "resolver_holdvalid", "email_mailers", "email_level", "email_myhostname", "email_from", "email_to", "sslcompatibilitymode", "ssldefaultdhparam", "advanced", "enablesync"]

    @field_validator('logfacility')
    def logfacility_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['kern', 'user', 'mail', 'daemon', 'auth', 'syslog', 'lpr', 'news', 'uucp', 'cron', 'auth2', 'ftp', 'ntp', 'audit', 'cron2', 'local0', 'local1', 'local2', 'local3', 'local4', 'local5', 'local6', 'local7']):
            raise ValueError("must be one of enum values ('kern', 'user', 'mail', 'daemon', 'auth', 'syslog', 'lpr', 'news', 'uucp', 'cron', 'auth2', 'ftp', 'ntp', 'audit', 'cron2', 'local0', 'local1', 'local2', 'local3', 'local4', 'local5', 'local6', 'local7')")
        return value

    @field_validator('loglevel')
    def loglevel_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['emerg', 'alert', 'crit', 'err', 'warning', 'notice', 'info', 'debug']):
            raise ValueError("must be one of enum values ('emerg', 'alert', 'crit', 'err', 'warning', 'notice', 'info', 'debug')")
        return value

    @field_validator('email_level')
    def email_level_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['', 'emerg', 'alert', 'crit', 'err', 'warning', 'notice', 'info', 'debug']):
            raise ValueError("must be one of enum values ('', 'emerg', 'alert', 'crit', 'err', 'warning', 'notice', 'info', 'debug')")
        return value

    @field_validator('sslcompatibilitymode')
    def sslcompatibilitymode_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['auto', 'modern', 'intermediate', 'old']):
            raise ValueError("must be one of enum values ('auto', 'modern', 'intermediate', 'old')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PatchServicesHAProxySettingsEndpointRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in dns_resolvers (list)
        _items = []
        if self.dns_resolvers:
            for _item_dns_resolvers in self.dns_resolvers:
                if _item_dns_resolvers:
                    _items.append(_item_dns_resolvers.to_dict())
            _dict['dns_resolvers'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in email_mailers (list)
        _items = []
        if self.email_mailers:
            for _item_email_mailers in self.email_mailers:
                if _item_email_mailers:
                    _items.append(_item_email_mailers.to_dict())
            _dict['email_mailers'] = _items
        # set to None if maxconn (nullable) is None
        # and model_fields_set contains the field
        if self.maxconn is None and "maxconn" in self.model_fields_set:
            _dict['maxconn'] = None

        # set to None if carpdev (nullable) is None
        # and model_fields_set contains the field
        if self.carpdev is None and "carpdev" in self.model_fields_set:
            _dict['carpdev'] = None

        # set to None if localstatsport (nullable) is None
        # and model_fields_set contains the field
        if self.localstatsport is None and "localstatsport" in self.model_fields_set:
            _dict['localstatsport'] = None

        # set to None if localstats_refreshtime (nullable) is None
        # and model_fields_set contains the field
        if self.localstats_refreshtime is None and "localstats_refreshtime" in self.model_fields_set:
            _dict['localstats_refreshtime'] = None

        # set to None if localstats_sticktable_refreshtime (nullable) is None
        # and model_fields_set contains the field
        if self.localstats_sticktable_refreshtime is None and "localstats_sticktable_refreshtime" in self.model_fields_set:
            _dict['localstats_sticktable_refreshtime'] = None

        # set to None if remotesyslog (nullable) is None
        # and model_fields_set contains the field
        if self.remotesyslog is None and "remotesyslog" in self.model_fields_set:
            _dict['remotesyslog'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PatchServicesHAProxySettingsEndpointRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "enable": obj.get("enable"),
            "maxconn": obj.get("maxconn"),
            "nbthread": obj.get("nbthread") if obj.get("nbthread") is not None else 1,
            "terminate_on_reload": obj.get("terminate_on_reload"),
            "hard_stop_after": obj.get("hard_stop_after") if obj.get("hard_stop_after") is not None else '15m',
            "carpdev": obj.get("carpdev"),
            "localstatsport": obj.get("localstatsport"),
            "localstats_refreshtime": obj.get("localstats_refreshtime"),
            "localstats_sticktable_refreshtime": obj.get("localstats_sticktable_refreshtime"),
            "remotesyslog": obj.get("remotesyslog"),
            "logfacility": obj.get("logfacility") if obj.get("logfacility") is not None else 'syslog',
            "loglevel": obj.get("loglevel") if obj.get("loglevel") is not None else 'warning',
            "log_send_hostname": obj.get("log_send_hostname"),
            "dns_resolvers": [PostServicesHAProxySettingsDNSResolverEndpointRequest.from_dict(_item) for _item in obj["dns_resolvers"]] if obj.get("dns_resolvers") is not None else None,
            "resolver_retries": obj.get("resolver_retries") if obj.get("resolver_retries") is not None else 3,
            "resolver_timeoutretry": obj.get("resolver_timeoutretry") if obj.get("resolver_timeoutretry") is not None else '1s',
            "resolver_holdvalid": obj.get("resolver_holdvalid") if obj.get("resolver_holdvalid") is not None else '1s',
            "email_mailers": [PostServicesHAProxySettingsEmailMailerEndpointRequest.from_dict(_item) for _item in obj["email_mailers"]] if obj.get("email_mailers") is not None else None,
            "email_level": obj.get("email_level"),
            "email_myhostname": obj.get("email_myhostname"),
            "email_from": obj.get("email_from"),
            "email_to": obj.get("email_to"),
            "sslcompatibilitymode": obj.get("sslcompatibilitymode") if obj.get("sslcompatibilitymode") is not None else 'auto',
            "ssldefaultdhparam": obj.get("ssldefaultdhparam") if obj.get("ssldefaultdhparam") is not None else 1024,
            "advanced": obj.get("advanced"),
            "enablesync": obj.get("enablesync")
        })
        return _obj


