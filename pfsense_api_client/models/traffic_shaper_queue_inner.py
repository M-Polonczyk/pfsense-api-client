# coding: utf-8

"""
    pfSense REST API Documentation

    ### Getting Started<br>- [Authentication and Authorization](https://pfrest.org/AUTHENTICATION_AND_AUTHORIZATION/)<br>- [Working with Object IDs](https://pfrest.org/WORKING_WITH_OBJECT_IDS/)<br>- [Queries, Filters, and Sorting](https://pfrest.org/QUERIES_FILTERS_AND_SORTING/)<br>- [Common Control Parameters](https://pfrest.org/COMMON_CONTROL_PARAMETERS/)<br>- [Working with HATEOAS](https://pfrest.org/WORKING_WITH_HATEOAS/)<br>

    The version of the OpenAPI document: v2.4.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class TrafficShaperQueueInner(BaseModel):
    """
    TrafficShaperQueueInner
    """ # noqa: E501
    interface: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The parent interface this traffic shaper queue a child of. This value is automatically determined by the queue's parent and cannot be manually set or changed.<br>")
    enabled: Optional[StrictBool] = Field(default=None, description="Enables or disables the traffic shaper queue.<br>")
    name: Annotated[str, Field(min_length=0, strict=True, max_length=15)] = Field(description="The name to assign this traffic shaper queue.<br>")
    priority: Optional[Annotated[int, Field(le=15, strict=True, ge=0)]] = Field(default=1, description="The priority level for this traffic shaper queue.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, PRIQ ]<br>")
    qlimit: Annotated[int, Field(le=99999999999999, strict=True, ge=1)] = Field(description="The number of packets that can be held in a queue waiting to be transmitted by the shaper.<br>")
    description: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="A description for this traffic shaper queue.<br>")
    default: Optional[StrictBool] = Field(default=None, description="Mark this traffic shaper queue as the default queue.<br>")
    red: Optional[StrictBool] = Field(default=None, description="Use the 'Random Early Detection' scheduler option for this traffic shaper queue.<br>")
    rio: Optional[StrictBool] = Field(default=None, description="Use the 'Random Early Detection In and Out' scheduler option for this traffic shaper queue.<br>")
    ecn: Optional[StrictBool] = Field(default=None, description="Use the 'Explicit Congestion Notification' scheduler option for this traffic shaper queue.<br>")
    codel: Optional[StrictBool] = Field(default=None, description="Use the 'Codel Active Queue' scheduler option for this traffic shaper queue.<br>")
    bandwidthtype: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='Mb', description="The scale type of the `bandwidth` field's value.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, HFSC ]<br>")
    bandwidth: Annotated[int, Field(le=99999999999999, strict=True, ge=1)] = Field(description="The total bandwidth amount allowed by this traffic shaper.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be one of [ FAIRQ, CBQ, HFSC ]<br>")
    buckets: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=None, description="<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'FAIRQ'`<br>")
    hogs: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=None, description="The bandwidth limit per host.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'FAIRQ'`<br>")
    borrow: Optional[StrictBool] = Field(default=None, description="Allow this queue to borrow from other queues when available.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'CBQ'`<br>")
    upperlimit: Optional[StrictBool] = Field(default=None, description="Allow setting the maximum bandwidth allowed for the queue. Will force hard bandwidth limiting.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>")
    upperlimit_m1: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The burst-able bandwidth limit for this traffic shaper queue.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>")
    upperlimit_d: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=1)]] = Field(default=None, description="The duration (in milliseconds) that the burst-able bandwidth limit (`upperlimit_m1` is in effect.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>")
    upperlimit_m2: Annotated[str, Field(min_length=0, strict=True, max_length=1024)] = Field(description="The normal bandwidth limit for this traffic shaper queue. If `upperlimit_m1` is not defined, this limit will always be in effect. If `upperlimit_m1` is defined, this limit will take effect after the `upperlimit_d` duration has expired.<br><br>This field is only available when the following conditions are met:<br>- `upperlimit` must be equal to `true`<br>")
    realtime: Optional[StrictBool] = Field(default=None, description="Allow setting the guaranteed bandwidth minimum allotted to the queue.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>")
    realtime_m1: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The guaranteed minimum bandwidth limit for this traffic shaper queue during real time.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>")
    realtime_d: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=1)]] = Field(default=None, description="The duration (in milliseconds) that the guaranteed bandwidth limit (`realtime_m1`) is in effect.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>")
    realtime_m2: Annotated[str, Field(min_length=0, strict=True, max_length=1024)] = Field(description="The maximum bandwidth this traffic shaper queue is allowed to use. Note: This value should not exceed 30% of parent queue's maximum bandwidth.<br><br>This field is only available when the following conditions are met:<br>- `realtime` must be equal to `true`<br>")
    linkshare: Optional[StrictBool] = Field(default=None, description="Allow sharing bandwidth from this queue for other queues as long as the real time values have been satisfied.<br><br>This field is only available when the following conditions are met:<br>- Parent field `scheduler` must be equal to `'HFSC'`<br>")
    linkshare_m1: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The initial bandwidth limit for this traffic shaper queue when link sharing.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>")
    linkshare_d: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=1)]] = Field(default=None, description="The duration (in milliseconds) that the initial bandwidth limit (`linkshare_m1`) is in effect.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>")
    linkshare_m2: Annotated[str, Field(min_length=0, strict=True, max_length=1024)] = Field(description="The maximum bandwidth this traffic shaper queue is allowed to use. Note: This behaves exactly the same as the `bandwidth` field. If this field is set, it will override whatever value is current assigned to the `bandwidth` field.<br><br>This field is only available when the following conditions are met:<br>- `linkshare` must be equal to `true`<br>")
    __properties: ClassVar[List[str]] = ["interface", "enabled", "name", "priority", "qlimit", "description", "default", "red", "rio", "ecn", "codel", "bandwidthtype", "bandwidth", "buckets", "hogs", "borrow", "upperlimit", "upperlimit_m1", "upperlimit_d", "upperlimit_m2", "realtime", "realtime_m1", "realtime_d", "realtime_m2", "linkshare", "linkshare_m1", "linkshare_d", "linkshare_m2"]

    @field_validator('bandwidthtype')
    def bandwidthtype_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['%', 'b', 'Kb', 'Mb', 'Gb']):
            raise ValueError("must be one of enum values ('%', 'b', 'Kb', 'Mb', 'Gb')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of TrafficShaperQueueInner from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "interface",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if interface (nullable) is None
        # and model_fields_set contains the field
        if self.interface is None and "interface" in self.model_fields_set:
            _dict['interface'] = None

        # set to None if buckets (nullable) is None
        # and model_fields_set contains the field
        if self.buckets is None and "buckets" in self.model_fields_set:
            _dict['buckets'] = None

        # set to None if hogs (nullable) is None
        # and model_fields_set contains the field
        if self.hogs is None and "hogs" in self.model_fields_set:
            _dict['hogs'] = None

        # set to None if upperlimit_m1 (nullable) is None
        # and model_fields_set contains the field
        if self.upperlimit_m1 is None and "upperlimit_m1" in self.model_fields_set:
            _dict['upperlimit_m1'] = None

        # set to None if upperlimit_d (nullable) is None
        # and model_fields_set contains the field
        if self.upperlimit_d is None and "upperlimit_d" in self.model_fields_set:
            _dict['upperlimit_d'] = None

        # set to None if realtime_m1 (nullable) is None
        # and model_fields_set contains the field
        if self.realtime_m1 is None and "realtime_m1" in self.model_fields_set:
            _dict['realtime_m1'] = None

        # set to None if realtime_d (nullable) is None
        # and model_fields_set contains the field
        if self.realtime_d is None and "realtime_d" in self.model_fields_set:
            _dict['realtime_d'] = None

        # set to None if linkshare_m1 (nullable) is None
        # and model_fields_set contains the field
        if self.linkshare_m1 is None and "linkshare_m1" in self.model_fields_set:
            _dict['linkshare_m1'] = None

        # set to None if linkshare_d (nullable) is None
        # and model_fields_set contains the field
        if self.linkshare_d is None and "linkshare_d" in self.model_fields_set:
            _dict['linkshare_d'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of TrafficShaperQueueInner from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "interface": obj.get("interface"),
            "enabled": obj.get("enabled"),
            "name": obj.get("name"),
            "priority": obj.get("priority") if obj.get("priority") is not None else 1,
            "qlimit": obj.get("qlimit"),
            "description": obj.get("description"),
            "default": obj.get("default"),
            "red": obj.get("red"),
            "rio": obj.get("rio"),
            "ecn": obj.get("ecn"),
            "codel": obj.get("codel"),
            "bandwidthtype": obj.get("bandwidthtype") if obj.get("bandwidthtype") is not None else 'Mb',
            "bandwidth": obj.get("bandwidth"),
            "buckets": obj.get("buckets"),
            "hogs": obj.get("hogs"),
            "borrow": obj.get("borrow"),
            "upperlimit": obj.get("upperlimit"),
            "upperlimit_m1": obj.get("upperlimit_m1"),
            "upperlimit_d": obj.get("upperlimit_d"),
            "upperlimit_m2": obj.get("upperlimit_m2"),
            "realtime": obj.get("realtime"),
            "realtime_m1": obj.get("realtime_m1"),
            "realtime_d": obj.get("realtime_d"),
            "realtime_m2": obj.get("realtime_m2"),
            "linkshare": obj.get("linkshare"),
            "linkshare_m1": obj.get("linkshare_m1"),
            "linkshare_d": obj.get("linkshare_d"),
            "linkshare_m2": obj.get("linkshare_m2")
        })
        return _obj


