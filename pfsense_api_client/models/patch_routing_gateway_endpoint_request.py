# coding: utf-8

"""
    pfSense REST API Documentation

    ### Getting Started<br>- [Authentication and Authorization](https://pfrest.org/AUTHENTICATION_AND_AUTHORIZATION/)<br>- [Working with Object IDs](https://pfrest.org/WORKING_WITH_OBJECT_IDS/)<br>- [Queries, Filters, and Sorting](https://pfrest.org/QUERIES_FILTERS_AND_SORTING/)<br>- [Common Control Parameters](https://pfrest.org/COMMON_CONTROL_PARAMETERS/)<br>- [Working with HATEOAS](https://pfrest.org/WORKING_WITH_HATEOAS/)<br>

    The version of the OpenAPI document: v2.4.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class PatchRoutingGatewayEndpointRequest(BaseModel):
    """
    PatchRoutingGatewayEndpointRequest
    """ # noqa: E501
    name: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=31)]] = Field(default=None, description="Sets a name for the gateway.<br>")
    descr: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="Sets a descriptions for the gateway.<br>")
    disabled: Optional[StrictBool] = Field(default=None, description="Disable this gateway.<br>")
    ipprotocol: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="Sets the Internet Protocol version this gateway uses.<br>")
    interface: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="Sets the interface this gateway will apply to.<br>")
    gateway: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="Sets the IP address of the remote gateway.<br>")
    monitor_disable: Optional[StrictBool] = Field(default=None, description="Disable gateway monitoring for this gateway.<br>")
    monitor: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="Sets a different IP address to use when monitoring this gateway. This is typically only                 necessary if the gateway IP does not accept ICMP probes.<br><br>This field is only available when the following conditions are met:<br>- `monitor_disable` must be equal to `false`<br>")
    action_disable: Optional[StrictBool] = Field(default=None, description="Disable actions from taking place when gateway events occur. The gateway will always be                 considered up.<br>")
    force_down: Optional[StrictBool] = Field(default=None, description="Always consider this gateway to be up.<br>")
    dpinger_dont_add_static_route: Optional[StrictBool] = Field(default=None, description="Prevents gateway monitoring from adding a static route for this gateway's monitor IP.<br>")
    gw_down_kill_states: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="Controls the state killing behavior when this specific gateway goes down. Killing states for specific down gateways only affects states created by policy routing rules and reply-to. Has no effect if gateway monitoring or its action are disabled or if the gateway is forced down. May not have any effect on dynamic gateways during a link loss event.<br>")
    nonlocalgateway: Optional[StrictBool] = Field(default=True, description="Allows or disallows gateway IPs that are not a part of the parent interface's subnet(s).<br>")
    weight: Optional[Annotated[int, Field(le=30, strict=True, ge=1)]] = Field(default=1, description="Sets the weight for this gateway when used in a Gateway Group.<br>")
    data_payload: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=1)]] = Field(default=1, description="Sets the data payload to send in ICMP packets to gateway monitor IP.<br>")
    latencylow: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=1)]] = Field(default=200, description="Sets the threshold to consider latency as low.<br>")
    latencyhigh: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=2)]] = Field(default=500, description="Sets the threshold to consider latency as high. This value must be greater than `latencylow`.<br>")
    losslow: Optional[Annotated[int, Field(le=99, strict=True, ge=1)]] = Field(default=10, description="Sets the threshold to consider packet loss as low.<br>")
    losshigh: Optional[Annotated[int, Field(le=100, strict=True, ge=2)]] = Field(default=20, description="Sets the threshold to consider packet loss as high. This value must be greater than `losslow`.<br>")
    interval: Optional[Annotated[int, Field(le=3600000, strict=True, ge=1)]] = Field(default=500, description="Sets how often ICMP probes will be sent in milliseconds.<br>")
    loss_interval: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=1)]] = Field(default=2000, description="Sets the time interval in milliseconds before packets are treated as lost.<br>")
    time_period: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=1)]] = Field(default=60000, description="Sets the time period in milliseconds over which results are averaged.<br>")
    alert_interval: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=1)]] = Field(default=1000, description="Sets the time interval in milliseconds between checking for an alert conditions.<br>")
    id: StrictInt = Field(description="The ID of the object or resource to interact with.")
    __properties: ClassVar[List[str]] = ["name", "descr", "disabled", "ipprotocol", "interface", "gateway", "monitor_disable", "monitor", "action_disable", "force_down", "dpinger_dont_add_static_route", "gw_down_kill_states", "nonlocalgateway", "weight", "data_payload", "latencylow", "latencyhigh", "losslow", "losshigh", "interval", "loss_interval", "time_period", "alert_interval", "id"]

    @field_validator('ipprotocol')
    def ipprotocol_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['inet', 'inet6']):
            raise ValueError("must be one of enum values ('inet', 'inet6')")
        return value

    @field_validator('gw_down_kill_states')
    def gw_down_kill_states_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['', 'none', 'down']):
            raise ValueError("must be one of enum values ('', 'none', 'down')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PatchRoutingGatewayEndpointRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if monitor (nullable) is None
        # and model_fields_set contains the field
        if self.monitor is None and "monitor" in self.model_fields_set:
            _dict['monitor'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PatchRoutingGatewayEndpointRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "name": obj.get("name"),
            "descr": obj.get("descr"),
            "disabled": obj.get("disabled"),
            "ipprotocol": obj.get("ipprotocol"),
            "interface": obj.get("interface"),
            "gateway": obj.get("gateway"),
            "monitor_disable": obj.get("monitor_disable"),
            "monitor": obj.get("monitor"),
            "action_disable": obj.get("action_disable"),
            "force_down": obj.get("force_down"),
            "dpinger_dont_add_static_route": obj.get("dpinger_dont_add_static_route"),
            "gw_down_kill_states": obj.get("gw_down_kill_states"),
            "nonlocalgateway": obj.get("nonlocalgateway") if obj.get("nonlocalgateway") is not None else True,
            "weight": obj.get("weight") if obj.get("weight") is not None else 1,
            "data_payload": obj.get("data_payload") if obj.get("data_payload") is not None else 1,
            "latencylow": obj.get("latencylow") if obj.get("latencylow") is not None else 200,
            "latencyhigh": obj.get("latencyhigh") if obj.get("latencyhigh") is not None else 500,
            "losslow": obj.get("losslow") if obj.get("losslow") is not None else 10,
            "losshigh": obj.get("losshigh") if obj.get("losshigh") is not None else 20,
            "interval": obj.get("interval") if obj.get("interval") is not None else 500,
            "loss_interval": obj.get("loss_interval") if obj.get("loss_interval") is not None else 2000,
            "time_period": obj.get("time_period") if obj.get("time_period") is not None else 60000,
            "alert_interval": obj.get("alert_interval") if obj.get("alert_interval") is not None else 1000,
            "id": obj.get("id")
        })
        return _obj


