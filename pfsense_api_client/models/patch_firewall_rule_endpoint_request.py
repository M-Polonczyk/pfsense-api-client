# coding: utf-8

"""
    pfSense REST API Documentation

    ### Getting Started<br>- [Authentication and Authorization](https://pfrest.org/AUTHENTICATION_AND_AUTHORIZATION/)<br>- [Working with Object IDs](https://pfrest.org/WORKING_WITH_OBJECT_IDS/)<br>- [Queries, Filters, and Sorting](https://pfrest.org/QUERIES_FILTERS_AND_SORTING/)<br>- [Common Control Parameters](https://pfrest.org/COMMON_CONTROL_PARAMETERS/)<br>- [Working with HATEOAS](https://pfrest.org/WORKING_WITH_HATEOAS/)<br>

    The version of the OpenAPI document: v2.4.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class PatchFirewallRuleEndpointRequest(BaseModel):
    """
    PatchFirewallRuleEndpointRequest
    """ # noqa: E501
    type: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The action to take against traffic that matches this rule.<br>")
    interface: Optional[Annotated[List[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]], Field(min_length=0, max_length=128)]] = Field(default=None, description="The interface where packets must originate to match this rule.<br>")
    ipprotocol: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The IP version(s) this rule applies to.<br>")
    protocol: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The IP/transport protocol this rule should match.<br>")
    icmptype: Optional[Annotated[List[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]], Field(min_length=0, max_length=128)]] = Field(default=None, description="Th ICMP subtypes this rule applies to. This field is only applicable when `ipprotocol` is `inet` and `protocol` is `icmp`.<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be equal to `'icmp'`<br>")
    source: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The source address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>")
    source_port: Optional[StrictStr] = Field(default=None, description="The source port this rule applies to. Set to `null` to allow any source port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>")
    destination: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The destination address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip`  modifier can be appended to the value to use the interface's IP address instead of its entire subnet.<br>")
    destination_port: Optional[StrictStr] = Field(default=None, description="The destination port this rule applies to. Set to `null` to allow any destination port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias<br><br>This field is only available when the following conditions are met:<br>- `protocol` must be one of [ tcp, udp, tcp/udp ]<br>")
    descr: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="A description detailing the purpose or justification of this firewall rule.<br>")
    disabled: Optional[StrictBool] = Field(default=None, description="Enable or disable this firewall rule.<br>")
    log: Optional[StrictBool] = Field(default=None, description="Enable or disable logging of traffic that matches this rule.<br>")
    tag: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="A packet matching this rule can be marked and this mark used to match on other NAT/filter rules. It is called <br>")
    statetype: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='keep state', description="The state mechanism to use for this firewall rule.<br>")
    tcp_flags_any: Optional[StrictBool] = Field(default=None, description="Allow any TCP flags.<br>")
    tcp_flags_out_of: Optional[Annotated[List[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]], Field(min_length=0, max_length=128)]] = Field(default=None, description="The TCP flags that can be set for this rule to match.<br><br>This field is only available when the following conditions are met:<br>- `tcp_flags_any` must be equal to `false`<br>")
    tcp_flags_set: Optional[Annotated[List[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]], Field(min_length=0, max_length=128)]] = Field(default=None, description="The TCP flags that must be set for this rule to match.<br><br>This field is only available when the following conditions are met:<br>- `tcp_flags_any` must be equal to `false`<br>")
    gateway: Optional[StrictStr] = Field(default=None, description="The gateway traffic matching this rule will be routed to. Set to `null` to use default.<br>")
    sched: Optional[StrictStr] = Field(default=None, description="The name of an existing firewall schedule to assign to this firewall rule.<br>")
    dnpipe: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The name of the traffic shaper limiter pipe or queue to use for incoming traffic.<br>")
    pdnpipe: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The name of the traffic shaper limiter pipe or queue to use for outgoing traffic.<br>")
    defaultqueue: Optional[StrictStr] = Field(default=None, description="The name of the traffic shaper queue to assume as the default queue for traffic matching this rule.<br>")
    ackqueue: Optional[StrictStr] = Field(default=None, description="The name of the traffic shaper queue to assume as the ACK queue for ACK traffic matching this rule.<br>")
    floating: Optional[StrictBool] = Field(default=None, description="Mark this rule as a floating firewall rule.<br>")
    quick: Optional[StrictBool] = Field(default=None, description="Apply this action to traffic that matches this rule immediately. This field only applies to floating firewall rules.<br><br>This field is only available when the following conditions are met:<br>- `floating` must be equal to `true`<br>")
    direction: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='any', description="The direction of traffic this firewall rule applies to. This field only applies to floating firewall rules.<br><br>This field is only available when the following conditions are met:<br>- `floating` must be equal to `true`<br>")
    tracker: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=None, description="The internal tracking ID for this firewall rule.<br>")
    associated_rule_id: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The internal rule ID for the NAT rule associated with this rule.<br>")
    created_time: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=None, description="The unix timestamp of when this firewall rule was original created.<br>")
    created_by: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='@unknown IP (API)', description="The username and IP of the user who originally created this firewall rule.<br>")
    updated_time: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=None, description="The unix timestamp of when this firewall rule was original created.<br>")
    updated_by: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='@unknown IP (API)', description="The username and IP of the user who last updated this firewall rule.<br>")
    id: StrictInt = Field(description="The ID of the object or resource to interact with.")
    __properties: ClassVar[List[str]] = ["type", "interface", "ipprotocol", "protocol", "icmptype", "source", "source_port", "destination", "destination_port", "descr", "disabled", "log", "tag", "statetype", "tcp_flags_any", "tcp_flags_out_of", "tcp_flags_set", "gateway", "sched", "dnpipe", "pdnpipe", "defaultqueue", "ackqueue", "floating", "quick", "direction", "tracker", "associated_rule_id", "created_time", "created_by", "updated_time", "updated_by", "id"]

    @field_validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['pass', 'block', 'reject']):
            raise ValueError("must be one of enum values ('pass', 'block', 'reject')")
        return value

    @field_validator('ipprotocol')
    def ipprotocol_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['inet', 'inet6', 'inet46']):
            raise ValueError("must be one of enum values ('inet', 'inet6', 'inet46')")
        return value

    @field_validator('protocol')
    def protocol_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['tcp', 'udp', 'tcp/udp', 'icmp', 'esp', 'ah', 'gre', 'ipv6', 'igmp', 'pim', 'ospf', 'carp', 'pfsync']):
            raise ValueError("must be one of enum values ('tcp', 'udp', 'tcp/udp', 'icmp', 'esp', 'ah', 'gre', 'ipv6', 'igmp', 'pim', 'ospf', 'carp', 'pfsync')")
        return value

    @field_validator('icmptype')
    def icmptype_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['any', 'althost', 'dataconv', 'echorep', 'echoreq', 'inforep', 'inforeq', 'ipv6-here', 'ipv6-where', 'maskrep', 'maskreq', 'mobredir', 'mobregrep', 'mobregreq', 'paramprob', 'photuris', 'redir', 'routeradv', 'routersol', 'skip', 'squench', 'timerep', 'timereq', 'timex', 'trace', 'unreach']):
                raise ValueError("each list item must be one of ('any', 'althost', 'dataconv', 'echorep', 'echoreq', 'inforep', 'inforeq', 'ipv6-here', 'ipv6-where', 'maskrep', 'maskreq', 'mobredir', 'mobregrep', 'mobregreq', 'paramprob', 'photuris', 'redir', 'routeradv', 'routersol', 'skip', 'squench', 'timerep', 'timereq', 'timex', 'trace', 'unreach')")
        return value

    @field_validator('statetype')
    def statetype_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['keep state', 'sloppy state', 'synproxy state', 'none']):
            raise ValueError("must be one of enum values ('keep state', 'sloppy state', 'synproxy state', 'none')")
        return value

    @field_validator('tcp_flags_out_of')
    def tcp_flags_out_of_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['fin', 'syn', 'rst', 'psh', 'ack', 'urg', 'ece', 'cwr']):
                raise ValueError("each list item must be one of ('fin', 'syn', 'rst', 'psh', 'ack', 'urg', 'ece', 'cwr')")
        return value

    @field_validator('tcp_flags_set')
    def tcp_flags_set_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['fin', 'syn', 'rst', 'psh', 'ack', 'urg', 'ece', 'cwr']):
                raise ValueError("each list item must be one of ('fin', 'syn', 'rst', 'psh', 'ack', 'urg', 'ece', 'cwr')")
        return value

    @field_validator('direction')
    def direction_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['any', 'in', 'out']):
            raise ValueError("must be one of enum values ('any', 'in', 'out')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PatchFirewallRuleEndpointRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "tracker",
            "associated_rule_id",
            "created_time",
            "created_by",
            "updated_time",
            "updated_by",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if protocol (nullable) is None
        # and model_fields_set contains the field
        if self.protocol is None and "protocol" in self.model_fields_set:
            _dict['protocol'] = None

        # set to None if source_port (nullable) is None
        # and model_fields_set contains the field
        if self.source_port is None and "source_port" in self.model_fields_set:
            _dict['source_port'] = None

        # set to None if destination_port (nullable) is None
        # and model_fields_set contains the field
        if self.destination_port is None and "destination_port" in self.model_fields_set:
            _dict['destination_port'] = None

        # set to None if tcp_flags_out_of (nullable) is None
        # and model_fields_set contains the field
        if self.tcp_flags_out_of is None and "tcp_flags_out_of" in self.model_fields_set:
            _dict['tcp_flags_out_of'] = None

        # set to None if tcp_flags_set (nullable) is None
        # and model_fields_set contains the field
        if self.tcp_flags_set is None and "tcp_flags_set" in self.model_fields_set:
            _dict['tcp_flags_set'] = None

        # set to None if gateway (nullable) is None
        # and model_fields_set contains the field
        if self.gateway is None and "gateway" in self.model_fields_set:
            _dict['gateway'] = None

        # set to None if sched (nullable) is None
        # and model_fields_set contains the field
        if self.sched is None and "sched" in self.model_fields_set:
            _dict['sched'] = None

        # set to None if dnpipe (nullable) is None
        # and model_fields_set contains the field
        if self.dnpipe is None and "dnpipe" in self.model_fields_set:
            _dict['dnpipe'] = None

        # set to None if pdnpipe (nullable) is None
        # and model_fields_set contains the field
        if self.pdnpipe is None and "pdnpipe" in self.model_fields_set:
            _dict['pdnpipe'] = None

        # set to None if defaultqueue (nullable) is None
        # and model_fields_set contains the field
        if self.defaultqueue is None and "defaultqueue" in self.model_fields_set:
            _dict['defaultqueue'] = None

        # set to None if ackqueue (nullable) is None
        # and model_fields_set contains the field
        if self.ackqueue is None and "ackqueue" in self.model_fields_set:
            _dict['ackqueue'] = None

        # set to None if tracker (nullable) is None
        # and model_fields_set contains the field
        if self.tracker is None and "tracker" in self.model_fields_set:
            _dict['tracker'] = None

        # set to None if associated_rule_id (nullable) is None
        # and model_fields_set contains the field
        if self.associated_rule_id is None and "associated_rule_id" in self.model_fields_set:
            _dict['associated_rule_id'] = None

        # set to None if created_time (nullable) is None
        # and model_fields_set contains the field
        if self.created_time is None and "created_time" in self.model_fields_set:
            _dict['created_time'] = None

        # set to None if created_by (nullable) is None
        # and model_fields_set contains the field
        if self.created_by is None and "created_by" in self.model_fields_set:
            _dict['created_by'] = None

        # set to None if updated_time (nullable) is None
        # and model_fields_set contains the field
        if self.updated_time is None and "updated_time" in self.model_fields_set:
            _dict['updated_time'] = None

        # set to None if updated_by (nullable) is None
        # and model_fields_set contains the field
        if self.updated_by is None and "updated_by" in self.model_fields_set:
            _dict['updated_by'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PatchFirewallRuleEndpointRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "type": obj.get("type"),
            "interface": obj.get("interface"),
            "ipprotocol": obj.get("ipprotocol"),
            "protocol": obj.get("protocol"),
            "icmptype": obj.get("icmptype"),
            "source": obj.get("source"),
            "source_port": obj.get("source_port"),
            "destination": obj.get("destination"),
            "destination_port": obj.get("destination_port"),
            "descr": obj.get("descr"),
            "disabled": obj.get("disabled"),
            "log": obj.get("log"),
            "tag": obj.get("tag"),
            "statetype": obj.get("statetype") if obj.get("statetype") is not None else 'keep state',
            "tcp_flags_any": obj.get("tcp_flags_any"),
            "tcp_flags_out_of": obj.get("tcp_flags_out_of"),
            "tcp_flags_set": obj.get("tcp_flags_set"),
            "gateway": obj.get("gateway"),
            "sched": obj.get("sched"),
            "dnpipe": obj.get("dnpipe"),
            "pdnpipe": obj.get("pdnpipe"),
            "defaultqueue": obj.get("defaultqueue"),
            "ackqueue": obj.get("ackqueue"),
            "floating": obj.get("floating"),
            "quick": obj.get("quick"),
            "direction": obj.get("direction") if obj.get("direction") is not None else 'any',
            "tracker": obj.get("tracker"),
            "associated_rule_id": obj.get("associated_rule_id"),
            "created_time": obj.get("created_time"),
            "created_by": obj.get("created_by") if obj.get("created_by") is not None else '@unknown IP (API)',
            "updated_time": obj.get("updated_time"),
            "updated_by": obj.get("updated_by") if obj.get("updated_by") is not None else '@unknown IP (API)',
            "id": obj.get("id")
        })
        return _obj


