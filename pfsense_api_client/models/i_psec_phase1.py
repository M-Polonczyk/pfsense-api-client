# coding: utf-8

"""
    pfSense REST API Documentation

    ### Getting Started<br>- [Authentication and Authorization](https://pfrest.org/AUTHENTICATION_AND_AUTHORIZATION/)<br>- [Working with Object IDs](https://pfrest.org/WORKING_WITH_OBJECT_IDS/)<br>- [Queries, Filters, and Sorting](https://pfrest.org/QUERIES_FILTERS_AND_SORTING/)<br>- [Common Control Parameters](https://pfrest.org/COMMON_CONTROL_PARAMETERS/)<br>- [Working with HATEOAS](https://pfrest.org/WORKING_WITH_HATEOAS/)<br>

    The version of the OpenAPI document: v2.4.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from pfsense_api_client.models.i_psec_phase1_encryption_inner import IPsecPhase1EncryptionInner
from typing import Optional, Set
from typing_extensions import Self

class IPsecPhase1(BaseModel):
    """
    IPsecPhase1
    """ # noqa: E501
    ikeid: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=1, description="The unique IKE ID for this phase 1 entry. This value is dynamically set and cannot be set or changed by users.<br>")
    descr: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="A description for this IPsec phase 1 entry.<br>")
    disabled: Optional[StrictBool] = Field(default=None, description="Disables this IPsec phase 1 entry.<br>")
    iketype: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The IKE protocol version this phase 1 entry will use.<br>")
    mode: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The IKEv1 negotiation mode this phase 1 entry will use.<br><br>This field is only available when the following conditions are met:<br>- `iketype` must be one of [ ikev1, auto ]<br>")
    protocol: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The IP version this phase 1 entry will use.<br>")
    interface: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The interface for the local endpoint of this phase 1 entry. This should be an interface that is reachable by the remote peer.<br>")
    remote_gateway: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The IP address or hostname of the remote gateway.<br>")
    authentication_method: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The IPsec authentication method this tunnel will use.<br>")
    myid_type: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The identifier type used by the local end of the tunnel.<br>")
    myid_data: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The identifier value used by the local end of the tunnel. This must be a value that corresponds with the current `myid_type` value.<br><br>This field is only available when the following conditions are met:<br>- `myid_type` must not be equal to `'myaddress'`<br>")
    peerid_type: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The identifier type used by the remote end of the tunnel.<br>")
    peerid_data: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The identifier value used by the remote end of the tunnel. This must be a value that corresponds with the current `peerid_type` value.<br><br>This field is only available when the following conditions are met:<br>- `peerid_type` must not be one of [ any, peeraddress ]<br>")
    pre_shared_key: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The Pre-Shared Key (PSK) value. This key must match on both peers and should be long and random to protect the tunnel and its contents. A weak Pre-Shared Key can lead to a tunnel compromise.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'pre_shared_key'`<br>")
    certref: Optional[StrictStr] = Field(default=None, description="The certificate which identifies this system. The certificate must have at least one non-wildcard SAN.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'cert'`<br>")
    caref: Optional[StrictStr] = Field(default=None, description="The certificate authority to use when validating the peer certificate.<br><br>This field is only available when the following conditions are met:<br>- `authentication_method` must be equal to `'cert'`<br>")
    rekey_time: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=25920, description="The amount of time (in seconds) before an child SA establishes new keys.<br>")
    reauth_time: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=None, description="The amount of time (in seconds) before an child SA is torn down and recreated from scratch, including authentication.<br>")
    rand_time: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=2880, description="A random value up to this amount will be subtracted from the `rekey_time` to avoid simultaneous renegotiation.<br>")
    lifetime: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=28800, description="The hard child SA lifetime (in seconds) after which the child SA will be expired.<br>")
    startaction: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The option used to force specific initiation/responder behavior for child SA (P2) entries.<br>")
    closeaction: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The option used to control the behavior when the remote peer unexpectedly closes a child SA (P2)<br>")
    nat_traversal: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='on', description="The option used to enable the use of NAT-T (i.e. the encapsulation of ESP in UDP packets) if needed, which can help with clients that are behind restrictive firewalls.<br>")
    gw_duplicates: Optional[StrictBool] = Field(default=None, description="Enables or disables the allowance of multiple phase 1 configurations with the same remote gateway endpoint.<br>")
    mobike: Optional[StrictBool] = Field(default=None, description="Enables or disables the use of MOBIKE for this tunnel.<br>")
    splitconn: Optional[StrictBool] = Field(default=None, description="Enables or disables the use split connection entries with multiple phase 2 configurations. Required for remote endpoints that support only a single traffic selector per child SA.<br>")
    prfselect_enable: Optional[StrictBool] = Field(default=None, description="Enables or disables manual Pseudo-Random Function (PRF) selection.<br>")
    ikeport: Optional[StrictStr] = Field(default='500', description="The UDP port for IKE on the remote gateway. Valid options are: a TCP/UDP port number<br>")
    nattport: Optional[StrictStr] = Field(default='4500', description="The UDP port for NAT-T on the remote gateway. Valid options are: a TCP/UDP port number<br>")
    dpd_delay: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=10, description="The delay (in seconds) between sending peer acknowledgement messages.<br>")
    dpd_maxfail: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=5, description="The number of consecutive failures allowed before disconnecting.<br>")
    encryption: Optional[Annotated[List[IPsecPhase1EncryptionInner], Field(min_length=1, max_length=65535)]] = Field(default=None, description="The encryption algorithms supported by this P1 encryption.<br>")
    __properties: ClassVar[List[str]] = ["ikeid", "descr", "disabled", "iketype", "mode", "protocol", "interface", "remote_gateway", "authentication_method", "myid_type", "myid_data", "peerid_type", "peerid_data", "pre_shared_key", "certref", "caref", "rekey_time", "reauth_time", "rand_time", "lifetime", "startaction", "closeaction", "nat_traversal", "gw_duplicates", "mobike", "splitconn", "prfselect_enable", "ikeport", "nattport", "dpd_delay", "dpd_maxfail", "encryption"]

    @field_validator('iketype')
    def iketype_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['ikev1', 'ikev2', 'auto']):
            raise ValueError("must be one of enum values ('ikev1', 'ikev2', 'auto')")
        return value

    @field_validator('mode')
    def mode_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['main', 'aggressive']):
            raise ValueError("must be one of enum values ('main', 'aggressive')")
        return value

    @field_validator('protocol')
    def protocol_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['inet', 'inet6', 'both']):
            raise ValueError("must be one of enum values ('inet', 'inet6', 'both')")
        return value

    @field_validator('authentication_method')
    def authentication_method_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['pre_shared_key', 'cert']):
            raise ValueError("must be one of enum values ('pre_shared_key', 'cert')")
        return value

    @field_validator('myid_type')
    def myid_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['myaddress', 'address', 'fqdn', 'user_fqdn', 'asn1dn', 'keyid tag', 'dyn_dns', 'auto']):
            raise ValueError("must be one of enum values ('myaddress', 'address', 'fqdn', 'user_fqdn', 'asn1dn', 'keyid tag', 'dyn_dns', 'auto')")
        return value

    @field_validator('peerid_type')
    def peerid_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['any', 'peeraddress', 'address', 'fqdn', 'user_fqdn', 'asn1dn', 'keyid tag', 'dyn_dns', 'auto']):
            raise ValueError("must be one of enum values ('any', 'peeraddress', 'address', 'fqdn', 'user_fqdn', 'asn1dn', 'keyid tag', 'dyn_dns', 'auto')")
        return value

    @field_validator('startaction')
    def startaction_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['', 'none', 'start', 'trap']):
            raise ValueError("must be one of enum values ('', 'none', 'start', 'trap')")
        return value

    @field_validator('closeaction')
    def closeaction_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['', 'none', 'start', 'trap']):
            raise ValueError("must be one of enum values ('', 'none', 'start', 'trap')")
        return value

    @field_validator('nat_traversal')
    def nat_traversal_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['on', 'force']):
            raise ValueError("must be one of enum values ('on', 'force')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of IPsecPhase1 from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "ikeid",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in encryption (list)
        _items = []
        if self.encryption:
            for _item_encryption in self.encryption:
                if _item_encryption:
                    _items.append(_item_encryption.to_dict())
            _dict['encryption'] = _items
        # set to None if ikeid (nullable) is None
        # and model_fields_set contains the field
        if self.ikeid is None and "ikeid" in self.model_fields_set:
            _dict['ikeid'] = None

        # set to None if dpd_delay (nullable) is None
        # and model_fields_set contains the field
        if self.dpd_delay is None and "dpd_delay" in self.model_fields_set:
            _dict['dpd_delay'] = None

        # set to None if dpd_maxfail (nullable) is None
        # and model_fields_set contains the field
        if self.dpd_maxfail is None and "dpd_maxfail" in self.model_fields_set:
            _dict['dpd_maxfail'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of IPsecPhase1 from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "ikeid": obj.get("ikeid") if obj.get("ikeid") is not None else 1,
            "descr": obj.get("descr"),
            "disabled": obj.get("disabled"),
            "iketype": obj.get("iketype"),
            "mode": obj.get("mode"),
            "protocol": obj.get("protocol"),
            "interface": obj.get("interface"),
            "remote_gateway": obj.get("remote_gateway"),
            "authentication_method": obj.get("authentication_method"),
            "myid_type": obj.get("myid_type"),
            "myid_data": obj.get("myid_data"),
            "peerid_type": obj.get("peerid_type"),
            "peerid_data": obj.get("peerid_data"),
            "pre_shared_key": obj.get("pre_shared_key"),
            "certref": obj.get("certref"),
            "caref": obj.get("caref"),
            "rekey_time": obj.get("rekey_time") if obj.get("rekey_time") is not None else 25920,
            "reauth_time": obj.get("reauth_time"),
            "rand_time": obj.get("rand_time") if obj.get("rand_time") is not None else 2880,
            "lifetime": obj.get("lifetime") if obj.get("lifetime") is not None else 28800,
            "startaction": obj.get("startaction"),
            "closeaction": obj.get("closeaction"),
            "nat_traversal": obj.get("nat_traversal") if obj.get("nat_traversal") is not None else 'on',
            "gw_duplicates": obj.get("gw_duplicates"),
            "mobike": obj.get("mobike"),
            "splitconn": obj.get("splitconn"),
            "prfselect_enable": obj.get("prfselect_enable"),
            "ikeport": obj.get("ikeport") if obj.get("ikeport") is not None else '500',
            "nattport": obj.get("nattport") if obj.get("nattport") is not None else '4500',
            "dpd_delay": obj.get("dpd_delay") if obj.get("dpd_delay") is not None else 10,
            "dpd_maxfail": obj.get("dpd_maxfail") if obj.get("dpd_maxfail") is not None else 5,
            "encryption": [IPsecPhase1EncryptionInner.from_dict(_item) for _item in obj["encryption"]] if obj.get("encryption") is not None else None
        })
        return _obj


