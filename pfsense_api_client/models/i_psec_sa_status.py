# coding: utf-8

"""
    pfSense REST API Documentation

    ### Getting Started<br>- [Authentication and Authorization](https://pfrest.org/AUTHENTICATION_AND_AUTHORIZATION/)<br>- [Working with Object IDs](https://pfrest.org/WORKING_WITH_OBJECT_IDS/)<br>- [Queries, Filters, and Sorting](https://pfrest.org/QUERIES_FILTERS_AND_SORTING/)<br>- [Common Control Parameters](https://pfrest.org/COMMON_CONTROL_PARAMETERS/)<br>- [Working with HATEOAS](https://pfrest.org/WORKING_WITH_HATEOAS/)<br>

    The version of the OpenAPI document: v2.4.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from pfsense_api_client.models.i_psec_sa_status_child_sas_inner import IPsecSAStatusChildSasInner
from typing import Optional, Set
from typing_extensions import Self

class IPsecSAStatus(BaseModel):
    """
    IPsecSAStatus
    """ # noqa: E501
    con_id: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The connection ID of the tunnel.<br>")
    uniqueid: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=None, description="The unique ID of the tunnel.<br>")
    version: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=None, description="The IKE version used by the tunnel.<br>")
    state: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The current state of the tunnel.<br>")
    local_host: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The local host for the tunnel.<br>")
    local_port: Optional[StrictStr] = Field(default=None, description="The local port for the tunnel. Valid options are: a TCP/UDP port number<br>")
    local_id: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The local ID for the tunnel.<br>")
    remote_host: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The remote host for the tunnel.<br>")
    remote_port: Optional[StrictStr] = Field(default=None, description="The remote port for the tunnel. Valid options are: a TCP/UDP port number<br>")
    remote_id: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The remote ID for the tunnel.<br>")
    initiator_spi: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The initiator SPI for the tunnel.<br>")
    responder_spi: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The responder SPI for the tunnel.<br>")
    nat_remote: Optional[StrictBool] = Field(default=None, description="Whether the remote host is behind NAT.<br>")
    nat_any: Optional[StrictBool] = Field(default=None, description="Whether the remote host is behind any NAT.<br>")
    encr_alg: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The encryption algorithm used by the tunnel.<br>")
    encr_keysize: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=None, description="The encryption key size used by the tunnel.<br>")
    integ_alg: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The integrity algorithm used by the tunnel.<br>")
    prf_alg: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The pseudo-random function algorithm used by the tunnel.<br>")
    dh_group: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The Diffie-Hellman group used by the tunnel.<br>")
    established: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=None, description="The amount of time the tunnel has been established.<br>")
    rekey_time: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=None, description="The amount of time until the tunnel rekeys.<br>")
    child_sas: Optional[Annotated[List[IPsecSAStatusChildSasInner], Field(min_length=0, max_length=65535)]] = Field(default=None, description="The child SAs of the tunnel.<br>")
    __properties: ClassVar[List[str]] = ["con_id", "uniqueid", "version", "state", "local_host", "local_port", "local_id", "remote_host", "remote_port", "remote_id", "initiator_spi", "responder_spi", "nat_remote", "nat_any", "encr_alg", "encr_keysize", "integ_alg", "prf_alg", "dh_group", "established", "rekey_time", "child_sas"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of IPsecSAStatus from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "con_id",
            "uniqueid",
            "version",
            "state",
            "local_host",
            "local_port",
            "local_id",
            "remote_host",
            "remote_port",
            "remote_id",
            "initiator_spi",
            "responder_spi",
            "nat_remote",
            "nat_any",
            "encr_alg",
            "encr_keysize",
            "integ_alg",
            "prf_alg",
            "dh_group",
            "established",
            "rekey_time",
            "child_sas",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in child_sas (list)
        _items = []
        if self.child_sas:
            for _item_child_sas in self.child_sas:
                if _item_child_sas:
                    _items.append(_item_child_sas.to_dict())
            _dict['child_sas'] = _items
        # set to None if con_id (nullable) is None
        # and model_fields_set contains the field
        if self.con_id is None and "con_id" in self.model_fields_set:
            _dict['con_id'] = None

        # set to None if uniqueid (nullable) is None
        # and model_fields_set contains the field
        if self.uniqueid is None and "uniqueid" in self.model_fields_set:
            _dict['uniqueid'] = None

        # set to None if version (nullable) is None
        # and model_fields_set contains the field
        if self.version is None and "version" in self.model_fields_set:
            _dict['version'] = None

        # set to None if state (nullable) is None
        # and model_fields_set contains the field
        if self.state is None and "state" in self.model_fields_set:
            _dict['state'] = None

        # set to None if local_host (nullable) is None
        # and model_fields_set contains the field
        if self.local_host is None and "local_host" in self.model_fields_set:
            _dict['local_host'] = None

        # set to None if local_port (nullable) is None
        # and model_fields_set contains the field
        if self.local_port is None and "local_port" in self.model_fields_set:
            _dict['local_port'] = None

        # set to None if local_id (nullable) is None
        # and model_fields_set contains the field
        if self.local_id is None and "local_id" in self.model_fields_set:
            _dict['local_id'] = None

        # set to None if remote_host (nullable) is None
        # and model_fields_set contains the field
        if self.remote_host is None and "remote_host" in self.model_fields_set:
            _dict['remote_host'] = None

        # set to None if remote_port (nullable) is None
        # and model_fields_set contains the field
        if self.remote_port is None and "remote_port" in self.model_fields_set:
            _dict['remote_port'] = None

        # set to None if remote_id (nullable) is None
        # and model_fields_set contains the field
        if self.remote_id is None and "remote_id" in self.model_fields_set:
            _dict['remote_id'] = None

        # set to None if initiator_spi (nullable) is None
        # and model_fields_set contains the field
        if self.initiator_spi is None and "initiator_spi" in self.model_fields_set:
            _dict['initiator_spi'] = None

        # set to None if responder_spi (nullable) is None
        # and model_fields_set contains the field
        if self.responder_spi is None and "responder_spi" in self.model_fields_set:
            _dict['responder_spi'] = None

        # set to None if nat_remote (nullable) is None
        # and model_fields_set contains the field
        if self.nat_remote is None and "nat_remote" in self.model_fields_set:
            _dict['nat_remote'] = None

        # set to None if nat_any (nullable) is None
        # and model_fields_set contains the field
        if self.nat_any is None and "nat_any" in self.model_fields_set:
            _dict['nat_any'] = None

        # set to None if encr_alg (nullable) is None
        # and model_fields_set contains the field
        if self.encr_alg is None and "encr_alg" in self.model_fields_set:
            _dict['encr_alg'] = None

        # set to None if encr_keysize (nullable) is None
        # and model_fields_set contains the field
        if self.encr_keysize is None and "encr_keysize" in self.model_fields_set:
            _dict['encr_keysize'] = None

        # set to None if integ_alg (nullable) is None
        # and model_fields_set contains the field
        if self.integ_alg is None and "integ_alg" in self.model_fields_set:
            _dict['integ_alg'] = None

        # set to None if prf_alg (nullable) is None
        # and model_fields_set contains the field
        if self.prf_alg is None and "prf_alg" in self.model_fields_set:
            _dict['prf_alg'] = None

        # set to None if dh_group (nullable) is None
        # and model_fields_set contains the field
        if self.dh_group is None and "dh_group" in self.model_fields_set:
            _dict['dh_group'] = None

        # set to None if established (nullable) is None
        # and model_fields_set contains the field
        if self.established is None and "established" in self.model_fields_set:
            _dict['established'] = None

        # set to None if rekey_time (nullable) is None
        # and model_fields_set contains the field
        if self.rekey_time is None and "rekey_time" in self.model_fields_set:
            _dict['rekey_time'] = None

        # set to None if child_sas (nullable) is None
        # and model_fields_set contains the field
        if self.child_sas is None and "child_sas" in self.model_fields_set:
            _dict['child_sas'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of IPsecSAStatus from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "con_id": obj.get("con_id"),
            "uniqueid": obj.get("uniqueid"),
            "version": obj.get("version"),
            "state": obj.get("state"),
            "local_host": obj.get("local_host"),
            "local_port": obj.get("local_port"),
            "local_id": obj.get("local_id"),
            "remote_host": obj.get("remote_host"),
            "remote_port": obj.get("remote_port"),
            "remote_id": obj.get("remote_id"),
            "initiator_spi": obj.get("initiator_spi"),
            "responder_spi": obj.get("responder_spi"),
            "nat_remote": obj.get("nat_remote"),
            "nat_any": obj.get("nat_any"),
            "encr_alg": obj.get("encr_alg"),
            "encr_keysize": obj.get("encr_keysize"),
            "integ_alg": obj.get("integ_alg"),
            "prf_alg": obj.get("prf_alg"),
            "dh_group": obj.get("dh_group"),
            "established": obj.get("established"),
            "rekey_time": obj.get("rekey_time"),
            "child_sas": [IPsecSAStatusChildSasInner.from_dict(_item) for _item in obj["child_sas"]] if obj.get("child_sas") is not None else None
        })
        return _obj


