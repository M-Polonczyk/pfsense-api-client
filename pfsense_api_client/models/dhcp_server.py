# coding: utf-8

"""
    pfSense REST API Documentation

    ### Getting Started<br>- [Authentication and Authorization](https://pfrest.org/AUTHENTICATION_AND_AUTHORIZATION/)<br>- [Working with Object IDs](https://pfrest.org/WORKING_WITH_OBJECT_IDS/)<br>- [Queries, Filters, and Sorting](https://pfrest.org/QUERIES_FILTERS_AND_SORTING/)<br>- [Common Control Parameters](https://pfrest.org/COMMON_CONTROL_PARAMETERS/)<br>- [Working with HATEOAS](https://pfrest.org/WORKING_WITH_HATEOAS/)<br>

    The version of the OpenAPI document: v2.4.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from pfsense_api_client.models.dhcp_server_numberoptions_inner import DHCPServerNumberoptionsInner
from pfsense_api_client.models.dhcp_server_pool_inner import DHCPServerPoolInner
from pfsense_api_client.models.dhcp_server_staticmap_inner import DHCPServerStaticmapInner
from typing import Optional, Set
from typing_extensions import Self

class DHCPServer(BaseModel):
    """
    DHCPServer
    """ # noqa: E501
    interface: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The interface to configure the DHCP server for. This field is only necessary when you wantto change the interface (ID) of an existing DHCP server, or you are replacing all DHCP server objects with a new configuration. Note that specifying an interface in this field will update the ID of the DHCP server to match the interface specified here. Leaving this field empty will retain the existing interface.<br>")
    enable: Optional[StrictBool] = Field(default=None, description="Enable the DHCP server for this interface.<br>")
    range_from: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=15)]] = Field(default=None, description="The starting IP address for the primary DHCP pool. This address must be less than or equal to the `range_to` field.<br>")
    range_to: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=15)]] = Field(default=None, description="The ending IP address for the primary DHCP pool. This address must be greater than or equal to the `range_to` field.<br>")
    domain: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=255)]] = Field(default=None, description="The domain to be assigned via DHCP.<br>")
    failover_peerip: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=255)]] = Field(default=None, description="The interface IP address of the other firewall (failover peer) in this subnet. Leave empty to disable failover peering.<br>")
    mac_allow: Optional[Annotated[List[Annotated[str, Field(min_length=0, strict=True, max_length=17)]], Field(min_length=0, max_length=128)]] = Field(default=None, description="MAC addresses this DHCP server is allowed to provide leases for.<br>")
    mac_deny: Optional[Annotated[List[Annotated[str, Field(min_length=0, strict=True, max_length=17)]], Field(min_length=0, max_length=128)]] = Field(default=None, description="MAC addresses this DHCP server is not allowed to provide leases for.<br>")
    domainsearchlist: Optional[Annotated[List[Annotated[str, Field(min_length=0, strict=True, max_length=255)]], Field(min_length=0, max_length=128)]] = Field(default=None, description="The domain search list to provide via DHCP.<br>")
    defaultleasetime: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=60)]] = Field(default=7200, description="The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.<br>")
    maxleasetime: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=60)]] = Field(default=86400, description="The maximum DHCP lease validity period (in seconds) a client can request.<br>")
    gateway: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=15)]] = Field(default=None, description="The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.<br>")
    dnsserver: Optional[Annotated[List[Annotated[str, Field(min_length=0, strict=True, max_length=15)]], Field(min_length=0, max_length=4)]] = Field(default=None, description="The DNS servers to provide via DHCP. Leave empty to default to system nameservers.<br>")
    winsserver: Optional[Annotated[List[Annotated[str, Field(min_length=0, strict=True, max_length=15)]], Field(min_length=0, max_length=2)]] = Field(default=None, description="The WINS servers to provide via DHCP.<br>")
    ntpserver: Optional[Annotated[List[Annotated[str, Field(min_length=0, strict=True, max_length=256)]], Field(min_length=0, max_length=4)]] = Field(default=None, description="The NTP servers to provide via DHCP.<br>")
    staticarp: Optional[StrictBool] = Field(default=None, description="Assign static ARP entries for DHCP leases provided by this server.<br>")
    ignorebootp: Optional[StrictBool] = Field(default=None, description="Force this DHCP server to ignore BOOTP queries.<br>")
    ignoreclientuids: Optional[StrictBool] = Field(default=None, description="Prevent recording a unique identifier (UID) in client lease data if present in the client DHCP request. This option may be useful when a client can dual boot using different client identifiers but the same hardware (MAC) address. Note that the resulting server behavior violates the official DHCP specification.<br>")
    nonak: Optional[StrictBool] = Field(default=None, description="Ignore denied clients rather than reject. This option is not compatible with failover and cannot be enabled when a Failover Peer IP address is configured.<br>")
    disablepingcheck: Optional[StrictBool] = Field(default=None, description="Prevent the DHCP server from sending a ping to the address being assigned, where if no response has been heard, it assigns the address.<br>")
    dhcpleaseinlocaltime: Optional[StrictBool] = Field(default=None, description="Display the DHCP lease times in local time instead of UTC.<br>")
    statsgraph: Optional[StrictBool] = Field(default=None, description="Enable adding DHCP lease statistics to the pfSense Monitoring graphs.<br>")
    denyunknown: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="Define how to handle unknown clients requesting DHCP leases. When set to `null`, any DHCP client will get an IP address within this scope/range on this interface. If set to `enabled`, any DHCP client with a MAC address listed in a static mapping on any scope(s)/interface(s) will get an IP address. If set to `class`, only MAC addresses listed in static mappings on this interface will get an IP address within this scope/range.<br>")
    pool: Optional[Annotated[List[DHCPServerPoolInner], Field(min_length=0, max_length=65535)]] = Field(default=None, description="Additional address pools applied to this DHCP server.<br>")
    numberoptions: Optional[Annotated[List[DHCPServerNumberoptionsInner], Field(min_length=0, max_length=65535)]] = Field(default=None, description="The custom DHCP options to apply to this DHCP server.<br>")
    staticmap: Optional[Annotated[List[DHCPServerStaticmapInner], Field(min_length=0, max_length=65535)]] = Field(default=None, description="Static mappings applied to this DHCP server.<br>")
    __properties: ClassVar[List[str]] = ["interface", "enable", "range_from", "range_to", "domain", "failover_peerip", "mac_allow", "mac_deny", "domainsearchlist", "defaultleasetime", "maxleasetime", "gateway", "dnsserver", "winsserver", "ntpserver", "staticarp", "ignorebootp", "ignoreclientuids", "nonak", "disablepingcheck", "dhcpleaseinlocaltime", "statsgraph", "denyunknown", "pool", "numberoptions", "staticmap"]

    @field_validator('denyunknown')
    def denyunknown_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['enabled', 'class']):
            raise ValueError("must be one of enum values ('enabled', 'class')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DHCPServer from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in pool (list)
        _items = []
        if self.pool:
            for _item_pool in self.pool:
                if _item_pool:
                    _items.append(_item_pool.to_dict())
            _dict['pool'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in numberoptions (list)
        _items = []
        if self.numberoptions:
            for _item_numberoptions in self.numberoptions:
                if _item_numberoptions:
                    _items.append(_item_numberoptions.to_dict())
            _dict['numberoptions'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in staticmap (list)
        _items = []
        if self.staticmap:
            for _item_staticmap in self.staticmap:
                if _item_staticmap:
                    _items.append(_item_staticmap.to_dict())
            _dict['staticmap'] = _items
        # set to None if defaultleasetime (nullable) is None
        # and model_fields_set contains the field
        if self.defaultleasetime is None and "defaultleasetime" in self.model_fields_set:
            _dict['defaultleasetime'] = None

        # set to None if maxleasetime (nullable) is None
        # and model_fields_set contains the field
        if self.maxleasetime is None and "maxleasetime" in self.model_fields_set:
            _dict['maxleasetime'] = None

        # set to None if denyunknown (nullable) is None
        # and model_fields_set contains the field
        if self.denyunknown is None and "denyunknown" in self.model_fields_set:
            _dict['denyunknown'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DHCPServer from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "interface": obj.get("interface"),
            "enable": obj.get("enable"),
            "range_from": obj.get("range_from"),
            "range_to": obj.get("range_to"),
            "domain": obj.get("domain"),
            "failover_peerip": obj.get("failover_peerip"),
            "mac_allow": obj.get("mac_allow"),
            "mac_deny": obj.get("mac_deny"),
            "domainsearchlist": obj.get("domainsearchlist"),
            "defaultleasetime": obj.get("defaultleasetime") if obj.get("defaultleasetime") is not None else 7200,
            "maxleasetime": obj.get("maxleasetime") if obj.get("maxleasetime") is not None else 86400,
            "gateway": obj.get("gateway"),
            "dnsserver": obj.get("dnsserver"),
            "winsserver": obj.get("winsserver"),
            "ntpserver": obj.get("ntpserver"),
            "staticarp": obj.get("staticarp"),
            "ignorebootp": obj.get("ignorebootp"),
            "ignoreclientuids": obj.get("ignoreclientuids"),
            "nonak": obj.get("nonak"),
            "disablepingcheck": obj.get("disablepingcheck"),
            "dhcpleaseinlocaltime": obj.get("dhcpleaseinlocaltime"),
            "statsgraph": obj.get("statsgraph"),
            "denyunknown": obj.get("denyunknown"),
            "pool": [DHCPServerPoolInner.from_dict(_item) for _item in obj["pool"]] if obj.get("pool") is not None else None,
            "numberoptions": [DHCPServerNumberoptionsInner.from_dict(_item) for _item in obj["numberoptions"]] if obj.get("numberoptions") is not None else None,
            "staticmap": [DHCPServerStaticmapInner.from_dict(_item) for _item in obj["staticmap"]] if obj.get("staticmap") is not None else None
        })
        return _obj


