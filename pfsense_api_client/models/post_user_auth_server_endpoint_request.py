# coding: utf-8

"""
    pfSense REST API Documentation

    ### Getting Started<br>- [Authentication and Authorization](https://pfrest.org/AUTHENTICATION_AND_AUTHORIZATION/)<br>- [Working with Object IDs](https://pfrest.org/WORKING_WITH_OBJECT_IDS/)<br>- [Queries, Filters, and Sorting](https://pfrest.org/QUERIES_FILTERS_AND_SORTING/)<br>- [Common Control Parameters](https://pfrest.org/COMMON_CONTROL_PARAMETERS/)<br>- [Working with HATEOAS](https://pfrest.org/WORKING_WITH_HATEOAS/)<br>

    The version of the OpenAPI document: v2.4.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class PostUserAuthServerEndpointRequest(BaseModel):
    """
    PostUserAuthServerEndpointRequest
    """ # noqa: E501
    refid: Optional[StrictStr] = Field(default='67ed081aa92b7', description="The unique reference ID for this authentication server. This value is only used internally and cannot be manually set or changed.<br>")
    type: Annotated[str, Field(min_length=0, strict=True, max_length=1024)] = Field(description="The type of this authentication server.<br>")
    name: Annotated[str, Field(min_length=0, strict=True, max_length=1024)] = Field(description="The descriptive name for this authentication server.<br>")
    host: Annotated[str, Field(min_length=0, strict=True, max_length=1024)] = Field(description="The remote IP address or hostname of the authentication server.<br>")
    ldap_port: StrictStr = Field(description="The LDAP port to connect to on this LDAP authentication server. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>")
    ldap_urltype: Annotated[str, Field(min_length=0, strict=True, max_length=1024)] = Field(description="The encryption mode to use when connecting to this authentication server. Use `Standard TCP` for unencrypted LDAP connections, use `STARTTLS Encrypt` to start an encrypted connection via STARTTLS if it's available, or `SSL/TLS Encrypted` to only use LDAPS encrypted connections.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>")
    ldap_protver: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=3, description="The LDAP protocol version to use for connections to this LDAP authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>")
    ldap_timeout: Optional[Annotated[int, Field(le=300, strict=True, ge=1)]] = Field(default=25, description="The timeout (in seconds) for connections to the LDAP authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>")
    ldap_caref: Optional[StrictStr] = Field(default='global', description="The certificate authority used to validate the LDAP server certificate.<br><br>This field is only available when the following conditions are met:<br>- `ldap_urltype` must be one of [ starttls, encrypted ]<br>")
    ldap_scope: Annotated[str, Field(min_length=0, strict=True, max_length=1024)] = Field(description="The LDAP search scope. Use `one` to limit the scope to a single level, or `subtree` to allow the entire subtree to be searched.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>")
    ldap_basedn: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The root for LDAP searches on this authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>")
    ldap_authcn: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The LDAP authentication container.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>")
    ldap_extended_enabled: Optional[StrictBool] = Field(default=None, description="Enable LDAP extended queries.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>")
    ldap_extended_query: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The extended LDAP query to make during LDAP searches.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_extended_enabled` must be equal to `true`<br>")
    ldap_binddn: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The DN to use when binding to this authentication server. Set to `null` to bind anonymously.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>")
    ldap_bindpw: Annotated[str, Field(min_length=0, strict=True, max_length=1024)] = Field(description="The password to use when binding to this authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_binddn` must not be equal to `NULL`<br>")
    ldap_attr_user: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='cn', description="The LDAP user attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>")
    ldap_attr_group: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='cn', description="The LDAP group attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>")
    ldap_attr_member: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='member', description="The LDAP member attribute.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>")
    ldap_rfc2307: Optional[StrictBool] = Field(default=None, description="Enables or disable RFC2307 LDAP options.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>")
    ldap_rfc2307_userdn: Optional[StrictBool] = Field(default=None, description="Enables or disable the use of DNs for username searches.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_rfc2307` must be equal to `true`<br>")
    ldap_attr_groupobj: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='posixGroup', description="The group object class for groups in RFC2307 mode.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>- `ldap_rfc2307` must be equal to `true`<br>")
    ldap_pam_groupdn: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The group DN to use for shell authentication. Users must be a member of this group and have valid posixAccount attributes to sign in.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>")
    ldap_utf8: Optional[StrictBool] = Field(default=None, description="Enables or disables UTF-8 encoding LDAP parameters before sending them to this authentication server<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>")
    ldap_nostrip_at: Optional[StrictBool] = Field(default=None, description="Do not strip away parts of the username after the @ symbol.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>")
    ldap_allow_unauthenticated: Optional[StrictBool] = Field(default=True, description="Enables or disables unauthenticated binding. Unauthenticated binds are bind with an existing login but with an empty password. Some LDAP servers (Microsoft AD) allow this type of bind without any possibility to disable it.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'ldap'`<br>")
    radius_secret: Annotated[str, Field(min_length=0, strict=True, max_length=1024)] = Field(description="The shared secret to use when authenticating to this RADIUS server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>")
    radius_auth_port: Optional[StrictStr] = Field(default='1812', description="The port used by RADIUS for authentication. Set to `null` to disable use of authentication services. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>")
    radius_acct_port: Optional[StrictStr] = Field(default='1813', description="The port used by RADIUS for accounting. Set to `null` to disable use of accounting services. Valid options are: a TCP/UDP port number<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>")
    radius_protocol: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='MSCHAPv2', description="The RADIUS protocol to use when authenticating.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>")
    radius_timeout: Optional[Annotated[int, Field(le=300, strict=True, ge=1)]] = Field(default=5, description="The timeout (in seconds) for connections to this RADIUS authentication server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>")
    radius_nasip_attribute: Annotated[str, Field(min_length=0, strict=True, max_length=1024)] = Field(description="The interface whose IP will be used as the 'NAS-IP-Address' attribute during RADIUS Access-Requests. This choice will not change the interface used for contacting the RADIUS server.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'radius'`<br>")
    __properties: ClassVar[List[str]] = ["refid", "type", "name", "host", "ldap_port", "ldap_urltype", "ldap_protver", "ldap_timeout", "ldap_caref", "ldap_scope", "ldap_basedn", "ldap_authcn", "ldap_extended_enabled", "ldap_extended_query", "ldap_binddn", "ldap_bindpw", "ldap_attr_user", "ldap_attr_group", "ldap_attr_member", "ldap_rfc2307", "ldap_rfc2307_userdn", "ldap_attr_groupobj", "ldap_pam_groupdn", "ldap_utf8", "ldap_nostrip_at", "ldap_allow_unauthenticated", "radius_secret", "radius_auth_port", "radius_acct_port", "radius_protocol", "radius_timeout", "radius_nasip_attribute"]

    @field_validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['ldap', 'radius']):
            raise ValueError("must be one of enum values ('ldap', 'radius')")
        return value

    @field_validator('ldap_urltype')
    def ldap_urltype_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['Standard TCP', 'STARTTLS Encrypt', 'SSL/TLS Encrypted']):
            raise ValueError("must be one of enum values ('Standard TCP', 'STARTTLS Encrypt', 'SSL/TLS Encrypted')")
        return value

    @field_validator('ldap_protver')
    def ldap_protver_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set([2, 3]):
            raise ValueError("must be one of enum values (2, 3)")
        return value

    @field_validator('ldap_scope')
    def ldap_scope_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['one', 'subtree']):
            raise ValueError("must be one of enum values ('one', 'subtree')")
        return value

    @field_validator('radius_protocol')
    def radius_protocol_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['MSCHAPv2', 'MSCHAPv1', 'CHAP_MD5', 'PAP']):
            raise ValueError("must be one of enum values ('MSCHAPv2', 'MSCHAPv1', 'CHAP_MD5', 'PAP')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PostUserAuthServerEndpointRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "refid",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if refid (nullable) is None
        # and model_fields_set contains the field
        if self.refid is None and "refid" in self.model_fields_set:
            _dict['refid'] = None

        # set to None if ldap_binddn (nullable) is None
        # and model_fields_set contains the field
        if self.ldap_binddn is None and "ldap_binddn" in self.model_fields_set:
            _dict['ldap_binddn'] = None

        # set to None if radius_auth_port (nullable) is None
        # and model_fields_set contains the field
        if self.radius_auth_port is None and "radius_auth_port" in self.model_fields_set:
            _dict['radius_auth_port'] = None

        # set to None if radius_acct_port (nullable) is None
        # and model_fields_set contains the field
        if self.radius_acct_port is None and "radius_acct_port" in self.model_fields_set:
            _dict['radius_acct_port'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PostUserAuthServerEndpointRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "refid": obj.get("refid") if obj.get("refid") is not None else '67ed081aa92b7',
            "type": obj.get("type"),
            "name": obj.get("name"),
            "host": obj.get("host"),
            "ldap_port": obj.get("ldap_port"),
            "ldap_urltype": obj.get("ldap_urltype"),
            "ldap_protver": obj.get("ldap_protver") if obj.get("ldap_protver") is not None else 3,
            "ldap_timeout": obj.get("ldap_timeout") if obj.get("ldap_timeout") is not None else 25,
            "ldap_caref": obj.get("ldap_caref") if obj.get("ldap_caref") is not None else 'global',
            "ldap_scope": obj.get("ldap_scope"),
            "ldap_basedn": obj.get("ldap_basedn"),
            "ldap_authcn": obj.get("ldap_authcn"),
            "ldap_extended_enabled": obj.get("ldap_extended_enabled"),
            "ldap_extended_query": obj.get("ldap_extended_query"),
            "ldap_binddn": obj.get("ldap_binddn"),
            "ldap_bindpw": obj.get("ldap_bindpw"),
            "ldap_attr_user": obj.get("ldap_attr_user") if obj.get("ldap_attr_user") is not None else 'cn',
            "ldap_attr_group": obj.get("ldap_attr_group") if obj.get("ldap_attr_group") is not None else 'cn',
            "ldap_attr_member": obj.get("ldap_attr_member") if obj.get("ldap_attr_member") is not None else 'member',
            "ldap_rfc2307": obj.get("ldap_rfc2307"),
            "ldap_rfc2307_userdn": obj.get("ldap_rfc2307_userdn"),
            "ldap_attr_groupobj": obj.get("ldap_attr_groupobj") if obj.get("ldap_attr_groupobj") is not None else 'posixGroup',
            "ldap_pam_groupdn": obj.get("ldap_pam_groupdn"),
            "ldap_utf8": obj.get("ldap_utf8"),
            "ldap_nostrip_at": obj.get("ldap_nostrip_at"),
            "ldap_allow_unauthenticated": obj.get("ldap_allow_unauthenticated") if obj.get("ldap_allow_unauthenticated") is not None else True,
            "radius_secret": obj.get("radius_secret"),
            "radius_auth_port": obj.get("radius_auth_port") if obj.get("radius_auth_port") is not None else '1812',
            "radius_acct_port": obj.get("radius_acct_port") if obj.get("radius_acct_port") is not None else '1813',
            "radius_protocol": obj.get("radius_protocol") if obj.get("radius_protocol") is not None else 'MSCHAPv2',
            "radius_timeout": obj.get("radius_timeout") if obj.get("radius_timeout") is not None else 5,
            "radius_nasip_attribute": obj.get("radius_nasip_attribute")
        })
        return _obj


