# coding: utf-8

"""
    pfSense REST API Documentation

    ### Getting Started<br>- [Authentication and Authorization](https://pfrest.org/AUTHENTICATION_AND_AUTHORIZATION/)<br>- [Working with Object IDs](https://pfrest.org/WORKING_WITH_OBJECT_IDS/)<br>- [Queries, Filters, and Sorting](https://pfrest.org/QUERIES_FILTERS_AND_SORTING/)<br>- [Common Control Parameters](https://pfrest.org/COMMON_CONTROL_PARAMETERS/)<br>- [Working with HATEOAS](https://pfrest.org/WORKING_WITH_HATEOAS/)<br>

    The version of the OpenAPI document: v2.4.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from pfsense_api_client.models.ha_proxy_frontend_a_actionitems_inner import HAProxyFrontendAActionitemsInner
from pfsense_api_client.models.ha_proxy_frontend_a_errorfiles_inner import HAProxyFrontendAErrorfilesInner
from pfsense_api_client.models.ha_proxy_frontend_a_extaddr_inner import HAProxyFrontendAExtaddrInner
from pfsense_api_client.models.ha_proxy_frontend_ha_acls_inner import HAProxyFrontendHaAclsInner
from pfsense_api_client.models.ha_proxy_frontend_ha_certificates_inner import HAProxyFrontendHaCertificatesInner
from typing import Optional, Set
from typing_extensions import Self

class PostServicesHAProxyFrontendEndpointRequest(BaseModel):
    """
    PostServicesHAProxyFrontendEndpointRequest
    """ # noqa: E501
    name: Annotated[str, Field(min_length=2, strict=True, max_length=1024)] = Field(description="The unique name for this HAProxy frontend.<br>")
    descr: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The description for this HAProxy frontend.<br>")
    status: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='active', description="The activation status for this HAProxy frontend.<br>")
    a_extaddr: Optional[Annotated[List[HAProxyFrontendAExtaddrInner], Field(min_length=0, max_length=65535)]] = Field(default=None, description="The external addresses assigned to this frontend.<br>")
    max_connections: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=None, description="The maximum number of connections allowed by this frontend.<br>")
    type: Annotated[str, Field(min_length=0, strict=True, max_length=1024)] = Field(description="The processing type for this frontend.<br>")
    ha_acls: Optional[Annotated[List[HAProxyFrontendHaAclsInner], Field(min_length=0, max_length=65535)]] = Field(default=None, description="The ACLs to apply to this frontend.<br>")
    a_actionitems: Optional[Annotated[List[HAProxyFrontendAActionitemsInner], Field(min_length=0, max_length=65535)]] = Field(default=None, description="The actions to take when an ACL match is found.<br>")
    backend_serverpool: Optional[StrictStr] = Field(default=None, description="The default backend to use for this frontend.<br>")
    socket_stats: Optional[StrictBool] = Field(default=None, description="Enables or disables collecting and providing separate statistics for each socket.<br>")
    dontlognull: Optional[StrictBool] = Field(default=None, description="Enables or disables logging connections with no data transferred.<br>")
    dontlog_normal: Optional[StrictBool] = Field(default=None, description="Enables or disables only logging anomalous (not normal) connection.<br>")
    log_separate_errors: Optional[StrictBool] = Field(default=None, description="Enables or disables changing the log level from info to err on potentially interesting info.<br>")
    log_detailed: Optional[StrictBool] = Field(default=None, description="Enables or disables more detailed logging.<br>")
    a_errorfiles: Optional[Annotated[List[HAProxyFrontendAErrorfilesInner], Field(min_length=0, max_length=65535)]] = Field(default=None, description="The custom error files to use for this frontend.<br>")
    client_timeout: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=30000, description="The amount of time (in milliseconds) to wait for data from the client.<br>")
    forwardfor: Optional[StrictBool] = Field(default=None, description="Enables or disables the HTTP X-Forwarded-For header which contains the client's IP address.<br><br>This field is only available when the following conditions are met:<br>- `type` must be equal to `'http'`<br>")
    httpclose: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='http-keep-alive', description="The `httpclose` option this frontend will operate.<br>")
    advanced_bind: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="Custom value to pass behind each bind option.<br>")
    advanced: Optional[StrictStr] = Field(default=None, description="Custom configuration to pass to this frontend.<br>")
    ssloffloadcert: Optional[StrictStr] = Field(default=None, description="The default SSL/TLS certificate refid to use for this frontend.<br>")
    ha_certificates: Optional[Annotated[List[HAProxyFrontendHaCertificatesInner], Field(min_length=0, max_length=65535)]] = Field(default=None, description="The additional SSL/TLS certificates to use on this frontend.<br>")
    __properties: ClassVar[List[str]] = ["name", "descr", "status", "a_extaddr", "max_connections", "type", "ha_acls", "a_actionitems", "backend_serverpool", "socket_stats", "dontlognull", "dontlog_normal", "log_separate_errors", "log_detailed", "a_errorfiles", "client_timeout", "forwardfor", "httpclose", "advanced_bind", "advanced", "ssloffloadcert", "ha_certificates"]

    @field_validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['active', 'disabled']):
            raise ValueError("must be one of enum values ('active', 'disabled')")
        return value

    @field_validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['http', 'https', 'tcp']):
            raise ValueError("must be one of enum values ('http', 'https', 'tcp')")
        return value

    @field_validator('httpclose')
    def httpclose_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['http-keep-alive', 'http-tunnel', 'httpclose', 'http-server-close', 'forceclose']):
            raise ValueError("must be one of enum values ('http-keep-alive', 'http-tunnel', 'httpclose', 'http-server-close', 'forceclose')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PostServicesHAProxyFrontendEndpointRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in a_extaddr (list)
        _items = []
        if self.a_extaddr:
            for _item_a_extaddr in self.a_extaddr:
                if _item_a_extaddr:
                    _items.append(_item_a_extaddr.to_dict())
            _dict['a_extaddr'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in ha_acls (list)
        _items = []
        if self.ha_acls:
            for _item_ha_acls in self.ha_acls:
                if _item_ha_acls:
                    _items.append(_item_ha_acls.to_dict())
            _dict['ha_acls'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in a_actionitems (list)
        _items = []
        if self.a_actionitems:
            for _item_a_actionitems in self.a_actionitems:
                if _item_a_actionitems:
                    _items.append(_item_a_actionitems.to_dict())
            _dict['a_actionitems'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in a_errorfiles (list)
        _items = []
        if self.a_errorfiles:
            for _item_a_errorfiles in self.a_errorfiles:
                if _item_a_errorfiles:
                    _items.append(_item_a_errorfiles.to_dict())
            _dict['a_errorfiles'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in ha_certificates (list)
        _items = []
        if self.ha_certificates:
            for _item_ha_certificates in self.ha_certificates:
                if _item_ha_certificates:
                    _items.append(_item_ha_certificates.to_dict())
            _dict['ha_certificates'] = _items
        # set to None if max_connections (nullable) is None
        # and model_fields_set contains the field
        if self.max_connections is None and "max_connections" in self.model_fields_set:
            _dict['max_connections'] = None

        # set to None if backend_serverpool (nullable) is None
        # and model_fields_set contains the field
        if self.backend_serverpool is None and "backend_serverpool" in self.model_fields_set:
            _dict['backend_serverpool'] = None

        # set to None if client_timeout (nullable) is None
        # and model_fields_set contains the field
        if self.client_timeout is None and "client_timeout" in self.model_fields_set:
            _dict['client_timeout'] = None

        # set to None if advanced_bind (nullable) is None
        # and model_fields_set contains the field
        if self.advanced_bind is None and "advanced_bind" in self.model_fields_set:
            _dict['advanced_bind'] = None

        # set to None if advanced (nullable) is None
        # and model_fields_set contains the field
        if self.advanced is None and "advanced" in self.model_fields_set:
            _dict['advanced'] = None

        # set to None if ssloffloadcert (nullable) is None
        # and model_fields_set contains the field
        if self.ssloffloadcert is None and "ssloffloadcert" in self.model_fields_set:
            _dict['ssloffloadcert'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PostServicesHAProxyFrontendEndpointRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "name": obj.get("name"),
            "descr": obj.get("descr"),
            "status": obj.get("status") if obj.get("status") is not None else 'active',
            "a_extaddr": [HAProxyFrontendAExtaddrInner.from_dict(_item) for _item in obj["a_extaddr"]] if obj.get("a_extaddr") is not None else None,
            "max_connections": obj.get("max_connections"),
            "type": obj.get("type"),
            "ha_acls": [HAProxyFrontendHaAclsInner.from_dict(_item) for _item in obj["ha_acls"]] if obj.get("ha_acls") is not None else None,
            "a_actionitems": [HAProxyFrontendAActionitemsInner.from_dict(_item) for _item in obj["a_actionitems"]] if obj.get("a_actionitems") is not None else None,
            "backend_serverpool": obj.get("backend_serverpool"),
            "socket_stats": obj.get("socket_stats"),
            "dontlognull": obj.get("dontlognull"),
            "dontlog_normal": obj.get("dontlog_normal"),
            "log_separate_errors": obj.get("log_separate_errors"),
            "log_detailed": obj.get("log_detailed"),
            "a_errorfiles": [HAProxyFrontendAErrorfilesInner.from_dict(_item) for _item in obj["a_errorfiles"]] if obj.get("a_errorfiles") is not None else None,
            "client_timeout": obj.get("client_timeout") if obj.get("client_timeout") is not None else 30000,
            "forwardfor": obj.get("forwardfor"),
            "httpclose": obj.get("httpclose") if obj.get("httpclose") is not None else 'http-keep-alive',
            "advanced_bind": obj.get("advanced_bind"),
            "advanced": obj.get("advanced"),
            "ssloffloadcert": obj.get("ssloffloadcert"),
            "ha_certificates": [HAProxyFrontendHaCertificatesInner.from_dict(_item) for _item in obj["ha_certificates"]] if obj.get("ha_certificates") is not None else None
        })
        return _obj


