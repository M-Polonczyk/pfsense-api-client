# coding: utf-8

"""
    pfSense REST API Documentation

    ### Getting Started<br>- [Authentication and Authorization](https://pfrest.org/AUTHENTICATION_AND_AUTHORIZATION/)<br>- [Working with Object IDs](https://pfrest.org/WORKING_WITH_OBJECT_IDS/)<br>- [Queries, Filters, and Sorting](https://pfrest.org/QUERIES_FILTERS_AND_SORTING/)<br>- [Common Control Parameters](https://pfrest.org/COMMON_CONTROL_PARAMETERS/)<br>- [Working with HATEOAS](https://pfrest.org/WORKING_WITH_HATEOAS/)<br>

    The version of the OpenAPI document: v2.4.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class PatchStatusLogsSettingsEndpointRequest(BaseModel):
    """
    PatchStatusLogsSettingsEndpointRequest
    """ # noqa: E501
    format: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='rfc3164', description="The format of the log entries.<br>")
    reverseorder: Optional[StrictBool] = Field(default=None, description="Reverse the order of log entries.<br>")
    nentries: Optional[Annotated[int, Field(le=20000, strict=True, ge=5)]] = Field(default=500, description="The number of log entries to display in the UI.<br>")
    nologdefaultblock: Optional[StrictBool] = Field(default=None, description="Do not log packets that are blocked by the implicit default block rule.<br>")
    nologdefaultpass: Optional[StrictBool] = Field(default=None, description="Do not log packets that are allowed by the implicit default pass rule.<br>")
    nologbogons: Optional[StrictBool] = Field(default=None, description="Log packets blocked by Block Bogon Networks rules.<br>")
    nologprivatenets: Optional[StrictBool] = Field(default=None, description="Log packets blocked by Block Private Networks rules.<br>")
    nolognginx: Optional[StrictBool] = Field(default=None, description="Do not Log errors from the web server process.<br>")
    rawfilter: Optional[StrictBool] = Field(default=None, description="Display logs in the UI as they are generated by the packet filter, without any formatting.<br>")
    disablelocallogging: Optional[StrictBool] = Field(default=None, description="Disable writing log entries to the local disk. WARNING: This will also disable Login Protection!<br>")
    logconfigchanges: Optional[StrictBool] = Field(default=None, description="Log changes made to the pfSense configuration.<br>")
    filterdescriptions: Optional[Annotated[int, Field(le=99999999999999, strict=True, ge=0)]] = Field(default=None, description="Display filter descriptions in the log entries Use `0` to not load descriptions, `1` to display descriptions in their own column, or `2` to display the description in a second row.<br>")
    logfilesize: Optional[Annotated[int, Field(le=2147483648, strict=True, ge=100000)]] = Field(default=512000, description="The maximum size of the log file in kilobytes.<br>")
    rotatecount: Optional[Annotated[int, Field(le=99, strict=True, ge=0)]] = Field(default=5, description="The number of log file rotations to keep.<br>")
    logcompressiontype: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='bzip2', description="The type of compression to use for log files.<br>")
    enableremotelogging: Optional[StrictBool] = Field(default=None, description="Enable remote logging.<br>")
    ipprotocol: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default='ipv4', description="The IP protocol to use for remote logging.<br><br>This field is only available when the following conditions are met:<br>- `enableremotelogging` must be equal to `true`<br>")
    sourceip: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The interface to use as the source IP address for remote logging.<br><br>This field is only available when the following conditions are met:<br>- `enableremotelogging` must be equal to `true`<br>")
    remoteserver: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The first remote syslog server to send log entries to.<br><br>This field is only available when the following conditions are met:<br>- `enableremotelogging` must be equal to `true`<br>")
    remoteserver2: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The second remote syslog server to send log entries to.<br><br>This field is only available when the following conditions are met:<br>- `enableremotelogging` must be equal to `true`<br>- `remoteserver` must not be equal to `NULL`<br>")
    remoteserver3: Optional[Annotated[str, Field(min_length=0, strict=True, max_length=1024)]] = Field(default=None, description="The third remote syslog server to send log entries to.<br><br>This field is only available when the following conditions are met:<br>- `enableremotelogging` must be equal to `true`<br>- `remoteserver` must not be equal to `NULL`<br>- `remoteserver2` must not be equal to `NULL`<br>")
    logall: Optional[StrictBool] = Field(default=None, description="Log everything to the remote syslog server(s).<br><br>This field is only available when the following conditions are met:<br>- `enableremotelogging` must be equal to `true`<br>")
    filter: Optional[StrictBool] = Field(default=None, description="Log filter events to the remote syslog server(s).<br><br>This field is only available when the following conditions are met:<br>- `enableremotelogging` must be equal to `true`<br>- `logall` must not be equal to `true`<br>")
    dhcp: Optional[StrictBool] = Field(default=None, description="Log DHCP events to the remote syslog server(s).<br><br>This field is only available when the following conditions are met:<br>- `enableremotelogging` must be equal to `true`<br>- `logall` must not be equal to `true`<br>")
    auth: Optional[StrictBool] = Field(default=None, description="Log authentication events to the remote syslog server(s).<br><br>This field is only available when the following conditions are met:<br>- `enableremotelogging` must be equal to `true`<br>- `logall` must not be equal to `true`<br>")
    portalauth: Optional[StrictBool] = Field(default=None, description="Log captive portal authentication events to the remote syslog server(s).<br><br>This field is only available when the following conditions are met:<br>- `enableremotelogging` must be equal to `true`<br>- `logall` must not be equal to `true`<br>")
    vpn: Optional[StrictBool] = Field(default=None, description="Log VPN events to the remote syslog server(s).<br><br>This field is only available when the following conditions are met:<br>- `enableremotelogging` must be equal to `true`<br>- `logall` must not be equal to `true`<br>")
    dpinger: Optional[StrictBool] = Field(default=None, description="Log gateway monitoring events to the remote syslog server(s).<br><br>This field is only available when the following conditions are met:<br>- `enableremotelogging` must be equal to `true`<br>- `logall` must not be equal to `true`<br>")
    hostapd: Optional[StrictBool] = Field(default=None, description="Log wireless authentication events to the remote syslog server(s).<br><br>This field is only available when the following conditions are met:<br>- `enableremotelogging` must be equal to `true`<br>- `logall` must not be equal to `true`<br>")
    system: Optional[StrictBool] = Field(default=None, description="Log system events to the remote syslog server(s).<br><br>This field is only available when the following conditions are met:<br>- `enableremotelogging` must be equal to `true`<br>- `logall` must not be equal to `true`<br>")
    resolver: Optional[StrictBool] = Field(default=None, description="Log DNS resolver events to the remote syslog server(s).<br><br>This field is only available when the following conditions are met:<br>- `enableremotelogging` must be equal to `true`<br>- `logall` must not be equal to `true`<br>")
    ppp: Optional[StrictBool] = Field(default=None, description="Log PPP events to the remote syslog server(s).<br><br>This field is only available when the following conditions are met:<br>- `enableremotelogging` must be equal to `true`<br>- `logall` must not be equal to `true`<br>")
    routing: Optional[StrictBool] = Field(default=None, description="Log routing events to the remote syslog server(s).<br><br>This field is only available when the following conditions are met:<br>- `enableremotelogging` must be equal to `true`<br>- `logall` must not be equal to `true`<br>")
    ntpd: Optional[StrictBool] = Field(default=None, description="Log NTP events to the remote syslog server(s).<br><br>This field is only available when the following conditions are met:<br>- `enableremotelogging` must be equal to `true`<br>- `logall` must not be equal to `true`<br>")
    __properties: ClassVar[List[str]] = ["format", "reverseorder", "nentries", "nologdefaultblock", "nologdefaultpass", "nologbogons", "nologprivatenets", "nolognginx", "rawfilter", "disablelocallogging", "logconfigchanges", "filterdescriptions", "logfilesize", "rotatecount", "logcompressiontype", "enableremotelogging", "ipprotocol", "sourceip", "remoteserver", "remoteserver2", "remoteserver3", "logall", "filter", "dhcp", "auth", "portalauth", "vpn", "dpinger", "hostapd", "system", "resolver", "ppp", "routing", "ntpd"]

    @field_validator('format')
    def format_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['rfc3164', 'rfc5424']):
            raise ValueError("must be one of enum values ('rfc3164', 'rfc5424')")
        return value

    @field_validator('filterdescriptions')
    def filterdescriptions_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set([0, 1, 2]):
            raise ValueError("must be one of enum values (0, 1, 2)")
        return value

    @field_validator('logcompressiontype')
    def logcompressiontype_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['bzip2', 'gzip', 'xz', 'zstd', 'none']):
            raise ValueError("must be one of enum values ('bzip2', 'gzip', 'xz', 'zstd', 'none')")
        return value

    @field_validator('ipprotocol')
    def ipprotocol_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['ipv4', 'ipv6']):
            raise ValueError("must be one of enum values ('ipv4', 'ipv6')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PatchStatusLogsSettingsEndpointRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if remoteserver (nullable) is None
        # and model_fields_set contains the field
        if self.remoteserver is None and "remoteserver" in self.model_fields_set:
            _dict['remoteserver'] = None

        # set to None if remoteserver2 (nullable) is None
        # and model_fields_set contains the field
        if self.remoteserver2 is None and "remoteserver2" in self.model_fields_set:
            _dict['remoteserver2'] = None

        # set to None if remoteserver3 (nullable) is None
        # and model_fields_set contains the field
        if self.remoteserver3 is None and "remoteserver3" in self.model_fields_set:
            _dict['remoteserver3'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PatchStatusLogsSettingsEndpointRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "format": obj.get("format") if obj.get("format") is not None else 'rfc3164',
            "reverseorder": obj.get("reverseorder"),
            "nentries": obj.get("nentries") if obj.get("nentries") is not None else 500,
            "nologdefaultblock": obj.get("nologdefaultblock"),
            "nologdefaultpass": obj.get("nologdefaultpass"),
            "nologbogons": obj.get("nologbogons"),
            "nologprivatenets": obj.get("nologprivatenets"),
            "nolognginx": obj.get("nolognginx"),
            "rawfilter": obj.get("rawfilter"),
            "disablelocallogging": obj.get("disablelocallogging"),
            "logconfigchanges": obj.get("logconfigchanges"),
            "filterdescriptions": obj.get("filterdescriptions"),
            "logfilesize": obj.get("logfilesize") if obj.get("logfilesize") is not None else 512000,
            "rotatecount": obj.get("rotatecount") if obj.get("rotatecount") is not None else 5,
            "logcompressiontype": obj.get("logcompressiontype") if obj.get("logcompressiontype") is not None else 'bzip2',
            "enableremotelogging": obj.get("enableremotelogging"),
            "ipprotocol": obj.get("ipprotocol") if obj.get("ipprotocol") is not None else 'ipv4',
            "sourceip": obj.get("sourceip"),
            "remoteserver": obj.get("remoteserver"),
            "remoteserver2": obj.get("remoteserver2"),
            "remoteserver3": obj.get("remoteserver3"),
            "logall": obj.get("logall"),
            "filter": obj.get("filter"),
            "dhcp": obj.get("dhcp"),
            "auth": obj.get("auth"),
            "portalauth": obj.get("portalauth"),
            "vpn": obj.get("vpn"),
            "dpinger": obj.get("dpinger"),
            "hostapd": obj.get("hostapd"),
            "system": obj.get("system"),
            "resolver": obj.get("resolver"),
            "ppp": obj.get("ppp"),
            "routing": obj.get("routing"),
            "ntpd": obj.get("ntpd")
        })
        return _obj


